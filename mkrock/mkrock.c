/* mkrock - make an idb format boot file for the Rockchip RK3399
 *
 * Tom Trebisky 1-16-2022
 *
 * All of this is done by u-boot/tools/mkimage
 * This program is based on a careful study of that, and some code
 * is indeed derived especially from rkcommon.c
 * Why write a new program if mkimage does the job?
 * Mostly because I want to learn and understand how all this works.
 *
 * The file generated by this should be written to
 *  and SD card at offset 64, or at the start of SPI flash (NAND).
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void rock_encode ( char *, int );

/* This would have been header0_info in u-boot/mkimage.
 * This is a 512 byte header that starts the file.
 */
struct rock_header {
	unsigned int magic;
	int _pad0;
	unsigned int disable_rc4;
	unsigned short init_offset;
	char _pad1[492];
	unsigned short init_size;
	unsigned short init_boot_size;
	short _pad2;
};

#define ROCK_MAGIC	0x0ff0aa55

#ifdef notdef
/**
 * struct header0_info - header block for boot ROM
 *
 * This is stored at SD card block 64 (where each block is 512 bytes, or at
 * the start of SPI flash. It is encoded with RC4.
 *
 * @magic:              Magic (must be RK_MAGIC)
 * @disable_rc4:        0 to use rc4 for boot image,  1 to use plain binary
 * @init_offset:        Offset in blocks of the SPL code from this header
 *                      block. E.g. 4 means 2KB after the start of this header.
 * Other fields are not used by U-Boot
 */
struct header0_info {
        uint32_t magic;
        uint8_t reserved[4];
        uint32_t disable_rc4;
        uint16_t init_offset;
        uint8_t reserved1[492];
        uint16_t init_size;
        uint16_t init_boot_size;
        uint8_t reserved2[2];
};
enum {
        RK_BLK_SIZE             = 512,
        RK_SIZE_ALIGN           = 2048,
        RK_INIT_OFFSET          = 4,
        RK_MAX_BOOT_SIZE        = 512 << 10,
        RK_SPL_HDR_START        = RK_INIT_OFFSET * RK_BLK_SIZE,
        RK_SPL_HDR_SIZE         = 4,
};
#endif

void
error ( char *msg )
{
	fprintf ( stderr, "%s\n", msg );
	exit ( 1 );
}

/* count is in bytes */
void
write_zero_pad ( int fd, int count )
{
}

#define INIT_OFFSET	4	/* 512 blocks from start of file */

/* I run this on an Intel machine, so I don't worry about byte order routines
 * as both my host and the target are both little endian.
 */
void
make_header ( struct rock_header *rh )
{
	memset ( (char *) rh, '\0', sizeof ( struct rock_header) );

	rh->magic = ROCK_MAGIC;
	rh->disable_rc4 = 0;	/* The SPL is not encrypted */
	rh->init_offset = INIT_OFFSET;

	rh->init_size = 99;
	rh->init_boot_size = 99;

	rock_encode ( (char *) rh, sizeof(struct rock_header) );
}

#ifdef notdef
	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
        hdr->magic = cpu_to_le32(RK_MAGIC);
        printf ( "TJT - magic = %08x\n", cpu_to_le32(RK_MAGIC) );
        hdr->disable_rc4 = cpu_to_le32(!rkcommon_need_rc4_spl(params));
        hdr->init_offset = cpu_to_le16(RK_INIT_OFFSET);
        hdr->init_size   = cpu_to_le16(spl_params.init_size / RK_BLK_SIZE);

        /*
         * init_boot_size needs to be set, as it is read by the BootROM
         * to determine the size of the next-stage bootloader (e.g. U-Boot
         * proper), when used with the back-to-bootrom functionality.
         *
         * see https://lists.denx.de/pipermail/u-boot/2017-May/293267.html
         * for a more detailed explanation by Andy Yan
         */
        if (spl_params.boot_file)
                init_boot_size = spl_params.init_size + spl_params.boot_size;
        else
                init_boot_size = spl_params.init_size + RK_MAX_BOOT_SIZE;
        hdr->init_boot_size = cpu_to_le16(init_boot_size / RK_BLK_SIZE);

        printf ( "TJT - encode header, %d bytes\n", RK_BLK_SIZE );
        rc4_encode(buf, RK_BLK_SIZE, rc4_key);
#endif


/*
#define BUF_SIZE	64*1024
char buffer[BUF_SIZE];
*/


/* Quick and dirty, no error messages */
int
main ( int argc, char **argv )
{
	int fd, n;
	struct rock_header hdr;

	--argc;
	++argv;
	if ( argc < 2 ) {
	    error ( "usage: mkrock infile outfile" );
	}

	make_header ( &hdr );
	write ( fd, (char *) &hdr, sizeof(hdr) );
	write_zero_pad ( fd, INIT_OFFSET - 1 );

#ifdef notdef
	fd = open ( *argv, O_RDONLY );
	if ( fd < 0 )
	    return 1;
	n = read ( fd, buffer, BUF_SIZE );
	if ( n <= 0 )
	    return 1;

	rock_encode ( buffer, n );
	write ( 1, buffer, n );
#endif

	return 0;
}

/* THE END */
