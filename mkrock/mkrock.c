/* mkrock - make an idb format boot file for the Rockchip RK3399
 *
 * Tom Trebisky 1-16-2022
 *
 * All of this is done by u-boot/tools/mkimage
 * This program is based on a careful study of that, and some code
 * is indeed derived especially from rkcommon.c
 * Why write a new program if mkimage does the job?
 * Mostly because I want to learn and understand how all this works.
 *
 * The file generated by this should be written to
 *  and SD card at offset 64, or at the start of SPI flash (NAND).
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void rock_encode ( char *, int );

/* This would have been header0_info in u-boot/mkimage.
 * This is a 512 byte header that starts the file.
 */
struct rock_header {
	unsigned int magic;
	int _pad0;
	unsigned int disable_rc4;
	unsigned short init_offset;
	char _pad1[492];
	unsigned short init_size;
	unsigned short init_boot_size;
	short _pad2;
};

#define ROCK_MAGIC	0x0ff0aa55
#define	SIZE_ALIGN	2048

#define ROUNDUP(x, y)	(((x) + ((y) - 1)) & ~((y) - 1))

#ifdef notdef
/**
 * struct header0_info - header block for boot ROM
 *
 * This is stored at SD card block 64 (where each block is 512 bytes, or at
 * the start of SPI flash. It is encoded with RC4.
 *
 * @magic:              Magic (must be RK_MAGIC)
 * @disable_rc4:        0 to use rc4 for boot image,  1 to use plain binary
 * @init_offset:        Offset in blocks of the SPL code from this header
 *                      block. E.g. 4 means 2KB after the start of this header.
 * Other fields are not used by U-Boot
 */
struct header0_info {
        uint32_t magic;
        uint8_t reserved[4];
        uint32_t disable_rc4;
        uint16_t init_offset;
        uint8_t reserved1[492];
        uint16_t init_size;
        uint16_t init_boot_size;
        uint8_t reserved2[2];
};
enum {
        RK_BLK_SIZE             = 512,
        RK_SIZE_ALIGN           = 2048,
        RK_INIT_OFFSET          = 4,
        RK_MAX_BOOT_SIZE        = 512 << 10,
        RK_SPL_HDR_START        = RK_INIT_OFFSET * RK_BLK_SIZE,
        RK_SPL_HDR_SIZE         = 4,
};
#endif

void
error ( char *msg )
{
	fprintf ( stderr, "%s\n", msg );
	exit ( 1 );
}

/* count is in bytes */
void
write_zero_pad ( int fd, int count )
{
	char *zeros;

	zeros = (char *) malloc ( count );
	memset ( zeros, '\0', count );
	write ( fd, zeros, count );
	free ( zeros );
}

#define INIT_OFFSET	4	/* 512 blocks from start of file */

/* I run this on an Intel machine, so I don't worry about byte order routines
 * as both my host and the target are both little endian.
 *
 * The following link discusses the size values in this header.
 *   https://lists.denx.de/pipermail/u-boot/2017-May/293267.html
 *
 * Adding size to the init_boot_size value, allows a feature this
 * describes as BACK_TO_BROM to cause a second loader to be executed.
 *
 * Also note that init_size must be a multiple of 4*512 (i.e. 2K)
 *  or the bootrom will not load it.  So the image must be padded
 *  to a 2K multiple.
 */
void
make_header ( struct rock_header *rh )
{
	memset ( (char *) rh, '\0', sizeof ( struct rock_header) );

	rh->magic = ROCK_MAGIC;
	rh->disable_rc4 = 0;	/* The SPL is not encrypted */
	rh->init_offset = INIT_OFFSET;

	rh->init_size = 99;
	rh->init_boot_size = 99;

	rock_encode ( (char *) rh, sizeof(struct rock_header) );
}

#ifdef notdef
	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
        hdr->magic = cpu_to_le32(RK_MAGIC);
        printf ( "TJT - magic = %08x\n", cpu_to_le32(RK_MAGIC) );
        hdr->disable_rc4 = cpu_to_le32(!rkcommon_need_rc4_spl(params));
        hdr->init_offset = cpu_to_le16(RK_INIT_OFFSET);
        hdr->init_size   = cpu_to_le16(spl_params.init_size / RK_BLK_SIZE);

        /*
         * init_boot_size needs to be set, as it is read by the BootROM
         * to determine the size of the next-stage bootloader (e.g. U-Boot
         * proper), when used with the back-to-bootrom functionality.
         *
         * see https://lists.denx.de/pipermail/u-boot/2017-May/293267.html
         * for a more detailed explanation by Andy Yan
         */
        if (spl_params.boot_file)
                init_boot_size = spl_params.init_size + spl_params.boot_size;
        else
                init_boot_size = spl_params.init_size + RK_MAX_BOOT_SIZE;
        hdr->init_boot_size = cpu_to_le16(init_boot_size / RK_BLK_SIZE);

        printf ( "TJT - encode header, %d bytes\n", RK_BLK_SIZE );
        rc4_encode(buf, RK_BLK_SIZE, rc4_key);
#endif

struct image {
	int size;
	int pad_size;
} image_info;

void
setup_image_sizes ( int ifd )
{
	struct stat stbuf;
	int size;
	int pad_size;

	if ( fstat(ifd, &stbuf) < 0)
	    error ( "Cannot get input image size" );

	image_info.size = stbuf.st_size;

	image_info.pad_size = ROUNDUP ( image_info.size, SIZE_ALIGN );

	printf ( "size, aligned size = %d %d\n", image_info.size, image_info.pad_size );
}

void
write_image ( int ifd, int ofd )
{
	char *imp;

	/* Here is a clever way to copy a file,
	 * stolen from u-boot.  mmap the input file,
	 * then write from that mapped address.
	 */
	imp = mmap(0, image_info.size, PROT_READ, MAP_SHARED, ifd, 0);
        if ( imp == MAP_FAILED )
	    error ( "Cannot map/read image" );

	write ( ofd, imp, image_info.size );
	munmap ( (void *)imp, image_info.size);
        close ( ifd );

	write_zero_pad ( ofd, image_info.pad_size - image_info.size );
}

/* Quick and dirty, no error messages */
int
main ( int argc, char **argv )
{
	int in_fd, out_fd;
	struct rock_header hdr;

	--argc;
	++argv;
	if ( argc < 2 ) {
	    error ( "usage: mkrock infile outfile" );
	}

	in_fd = open ( argv[0], O_RDONLY );
	if ( in_fd < 0 )
	    error ( "Cannot open input file" );

	out_fd = open ( argv[1], O_WRONLY | O_CREAT, 0664 );
	if ( out_fd < 0 )
	    error ( "Cannot open output file" );

	setup_image_sizes ( in_fd );

	make_header ( &hdr );
	write ( out_fd, (char *) &hdr, sizeof(hdr) );
	write_zero_pad ( out_fd, 512 * (INIT_OFFSET - 1) );

	write_image ( in_fd, out_fd );

	close ( out_fd );
	close ( in_fd );

	return 0;
}

/* THE END */
