; RK3399 bootrom
; disassembled 1-21-2022 by tjt

; This is 64 bit (aarch64) ARM code
; They say it is entirely dependent on the SoC designer
; whether a processor comes out of reset running 32 or 64 bit code.
; apparently for the RK3399 it is 64 bit code from the very start.

; The bootrom is located at ffff0000 (and fffd0000)
; The location at ffff0000 is required, as that is where the
; processor fires up.
; This is a 64k address space, but the ROM is only 32K
; We see two identical copies, the second starts at ffff8000
; and we just ignore it.
; Also we fill just a bit over half of the 32K space,
; there is a big block of zeros from ffff5150 to ffff7fec
;
; Some code I wrote that runs immediately after this bootloader
; shows:
; mpidr_el1 = 80000000
; currentel = 0000000c  (el3)
; which is no particular surprise.
; So this code is run by core 0 of the A53 cluster.

; ff8c0000 is on chip SRAM (192K)
;  the stack gets initialized in here at ff8c2000
;  and grows to smaller addresses.
;  ff8c0004 is special.
;
; As a side note.  Once we are running U-Boot, we cannot access
; the SRAM, attempting to do so yields synchronous aborts.
; This will make it hard to poke at the special memory locations
; that will bring other cores out of the WFE loop.
; So, we can only hope that someone else has done that for us,
; and parked them someplace where we can get at them.

; Interestingly, the bootrom does very little with processor registers
;  via the mrs and msr instruction.  It never enables caches for example.
; It messes with mpidr_el1, elr_el3 and vbar_el2 and that is it.

; The claim is that the bootrom can boot from:
; - SPI (such as NAND flash)
; - eMMC
; - SD/MMC
; - USB OTG system download

; =======================================================================

; Here are some base addresses of hardware items that arise
;  (or don't arise) in the bootrom code
;
;  0xff750000 - PMUCRU
;  0xff760000 - CRU (clock and reset unit)
;  0xff770000 - GRF (general register file)
;  0xff8b0000 - Crypto0
;  0xff320000 - PMU_GRF
;  0xff330000 - PMU_SGRF
;  0xfe320000 - SD MMC
;  0xfe330000 - MMC
;  0xfe80xxxx - USB_OTG0
;  0xff790000 - GPIO4
;  0xfffa0000 - Efuse1
;
;  0xfe380000 - USB2 host 0 - never seen
;  0xfe3c0000 - USB2 host 1 - never seen
;  0xfe90xxxx - USB_OTG1 - never seen
;  0xff6D0000 - DMA0 -- never seen
;  0xff6E0000 - DMA1 -- never seen
;  0xff100000 - SARADC - never seen
;  0xff720000 - GPIO0 - never seen
;  0xff730000 - GPIO1 - never seen
;  0xff780000 - GPIO2 - never seen
;  0xff788000 - GPIO3 - never seen
;  0xfe310000 - SD IO - never seen

; =======================================================================

; So what about aarch64, this is a poor place for it, but I won't
; let that stop me.  Here is a brief tutorial.
; There is actually no better way to learn a processor instruction
;  set other than studying disassembled code like this.
; You certainly can learn by writing code, but until you gain a
;  lot of experience you are likely to only use a part of the
;  instruction set.
; And this is a great place given that it is closely
; followed by a lot of example code to see the instruction
; set in use!
;
; We have 31 general registers x0 to x30
; with "x" in the name, we are talking about a 64 bit register
; with "w" in the name, we are talking about a 32 bit register
; Some are special (as per compiler use) --
;  x29 is the FP (frame pointer)
;  x30 is the LR (link register)
; We also have xzr, wzr, which is a permanently zero register when read.
; We have the sp, but it is not associated with a general register.
; We also have the pc, also not available as a general register.
;
; instructions "flow" from right to left, as:
; name dest, src1, src2
; name dest, src1, immediate
;
; ldr dest, [src] -- load from address in src register
; str src, [dest] -- store to address in src register
; stp src1, src2, [dest] -- store a pair of registers
; strh, ldrh -- store and load half words
; strb, ldrb -- store and load bytes
; 
; So, what happens when you load a small thing into a 64 bit register.
;  as near as I can tell you get zeros filling the rest of the register.
;  if the instruction ends with an "s" you get sign extension
;
; It is worth noting that aarch64 has nothing like the stm/ldm
;  multiple register load and store instructions
;
; cbz, cbnz -- compare register to zero and branch
; tbz, tbnz -- test bit and branch if zero
;
; Note that "ldr" instructions load a 64 bit value from memory,
; typically from an address given as an offset from the location
; of the current instruction, but we would never know that.
;
; What we do need to pay attention to on 64 bit loads is how the
; values are displayed.  The ARM runs little endian in our case,
; so our memory dump shows the low 32 bit value (swapped to big endian)
; first, followed by the high 32 bit value (also swapped big endian).
;
; I wrote a little program to dump areas with 64 bit constants
; and I think patched this into the relevant areas, so this is
; no longer a source of confusion reading this listing.
;
; adrp is an interesting instruction.  The idea is to load
; a 64 bit constand into a register within a single 32 bit
; instruction.  The disassembly shows the final value that
; will be placed into the register, and the trickery can be
; viewed as a black box.  However, you get the base address
; of a 4K page, so you will need to add an offset.
; A pair of instructions such as this are often used:
;		adrp	x0, 0xff8c0000
;		add	x1, x0, #0x18
; Another scheme is to use adrp to load the page base address
; as the following, then use an offset in the addressing
; mode of a subsequent instruction, like this:
;
;		adrp	x1, 0xffff4000
;		ldr	w1, [x1, #3692]
;
; Early code in the bootrom eschews using the adrp instruction scheme
; and relies on a block of 64 bit constants that follow the code.
; This early code was probably written in assembler, and the bulk
; of the code was generated by a compiler which used the adrp scheme.
;
; Note also the annoying business of the assembler in objdump using
; decimal base offsets, I would much prefer these as hex, and intend
; to write a post-processor to make them so.
;
; ARM is as bad as the m68k for addressing modes.
; to start with, what is the difference here:
;		ldr	w3, [x0, #4]
;		ldr	w3, [x0], #4
;		ldr	w3, [x1, #4]!
;
; The first is easy, we add 4 to the value in x0 and fetch from that location.
; The second is called "post indexing".  We fetch from the address in x0,
; then after the fetch, add 4 to x0.
; The third is called "pre indexing".  We add 4 to x1 first, then use
; that changed value to fetch from memory
;
; bl and ret handle subroutines
; bl is "branch and link" and places the return in lr (x30)
; ret returns by copying x30 into the pc
; note that the stack is not involved at all,
;  a subroutine which intends to call other subroutines will
;  need to free up lr by pushing it onto the stack and restoring it
;  a leaf subroutine won't need to do this at all.
; 
; br reg -- branches to address in reg
;   this is just what we need to run code we just loaded
;
; csel is "condition select"
;   if the condition is true, the first register gets copied to the destination
;   otherwise the second register gets copied.
;   This requires a previous "cmp" instruction or some such to set the condition
;   Here is an example:
;       csel    x20, x1, x0, eq
; cset
;  This sets a register to 1 if a condition is true, else it sets 0
;  this will need to follow a cmp or some other instruction that sets
;  condition codes.  I see it used in 2 places in this code as follows.
;  The following test asks if register w19 is non-zero
;  The following "and" seems like belt and suspenders
;  It seems to me we could just specify x0 in the cset instruction
;
;	cmp	w19, #0x0
;	cset	w0, ne
;	and	x0, x0, #0x1
;
; -----------
; Here are some notes on the stack and subroutine conventions
;  apparently the sp needs to stay 16 bit aligned, so you will
;  always see a multiple of 16 bytes being subtracted on
; subroutine entry.
; Now consider this:
;	sub	sp, sp, #0x20
;	stp	x29, x30, [sp, #16]
;	add	x29, sp, #0x10
; Here we allocate 16 bytes more than the bare minimum
; We dump x29 (FP) and x30 (LR) at the bottom of this area
; remember these are 64 bit registers, so this takes 16 bytes
; then we set up x29 (the FP) to point to where these two registers
; were saved.  The sp thus points to a block of memory above
; these two registers which can be used for anything local.
; The case where we sub 0x10 is a degenerate case where no
; local memory is being allocated.
;
; This rigamarole suggests that code like this was generated by a
; compiler, but this is by no means certain.
;
; -----------
; Condition codes
; like any good processor, the ARM 64 has these.
;    and it has 4 bits (N,Z,C,V)
; The ARM 32 allowed almost any instruction to be conditionally executed
;  based on the CC, but ARM 64 has done away with that, which I think
;  is a good thing.
; Testing the CC is done by branch, select, and compare instructions
; We have mnemonics for certain CC combinations, as follows
;
;  EQ - Z set
;  NE - Z clear
;  CS - C set (unsigned ge)
;  CC - C clear (unsigned lt)
;  MI - N set (negative)
;  PL - N clear (zero or positive)
;  VS - V set (overflow)
;  VC - V clear
;  HI - C set,Z clear (unsigned gt)
;  LS - not (C set and Z clear) (unsigned le)
;  GE - N, V the same (signed ge)
;  LT - N, V different (signed lt)
;  GT - Z clear, N,V the same (signed gt)
;  LE - not (Z clear, N,V the same) (signed le)
;  AL - always (unconditional branch) - any CC
;    (in this case, we just have "b"
;
; Note that the notations of GE, LT in the above are completely useless
; without some convention of what is being compared to what.
; The way to think about it is as the result of a preceding "cmp"
; where we compare "cmp A, B", in this case GE refers to A >= B
;
; Note that I never see vs or vc (in this code anyway)
; The condition codes are used by b, cset, csel (others?).
;
; I always get annoyed at this whole condition code business.
;  so I am going to go on at some length in the following.
; There are endless opportunities for double think depending
;  on what order the operands are compared and whether you
;  are talking about signed or unsigned values.
;
; The way to get your mind around these is to realize that you
;  really need to think about multi-instruction "idioms".
; If you think about C programming, you never deal with condition codes,
;  you just compare numbers, so what are the idioms for comparing numbers?
; A conditional branch will almost invariably be preceeded by a
;  cmp instruction like the following:

;	ffff0fdc:	71000b9f 	cmp	w28, #0x2
;	ffff0fe0:	54fffb83 	b.cc	0xffff0f50  // b.lo, b.ul, b.last

; The above says to branch if w28 < 2  (if we have unsigned values)

;	ffff0298:	6b3342df 	cmp	w22, w19, uxtw
;	ffff029c:	54fffec3 	b.cc	0xffff0274  // b.lo, b.ul, b.last

; And the above will branch if w22 < w19 (given unsigned values)
;  the uxtw notation (to do an unsigned extend) comfirms the unsigned context

; It is vital to know whether the values are intended to be treated as signed or unsigned
; It is also vital to consider the order of the two items.

; Let's talk about  "cmp reg, #val", which is a common idiom.
; In this case (thinking unsigned) b.cs is a branch if reg >= val
; In the other case (thinking unsigned) b.cc is a branch if reg < val

; A note on the uxtw notation in the above is in order.
; We can have uxt[b,h,w].
; These indicate to zero extend a byte, halfword (16 bits), or word (32 bits)
;  from the source element
;
; I also see "uxtx" in a handful of adds, as in the following
;  add     x6, x0, x1, uxtx #4
; These are all already 64 bit registers, so I don't see the point,
;  but I am going to pass this by for now.
;
; ubfx is a "bitfield extract" instruction
;	ubfx	w1, w0, #6, #4
;  the above extracts from w0 to w1
;  6 is the starting bit, 4 is the number of bits
;  this is a nice way to replace the usual mask and shift
;  In C code, this would be:
;	dest = (src >> lsb) & ((1 << width) - 1);

;	lsr	w0, w0, #0
;  the above raises an interesting issue, this particular case is a noop.
;  but consider the following
;	lsr	w0, w7, #0
;  this just moves w7 to w0.  Why not just use a mov instruction?
;  some sources say that only values of 1-31 are allowed.
;  I wrote some test code and convinced myself by experiment that
;  this just copies registers.
;  It is odd that this is used in several places.

; ==========================================================================
; ==========================================================================

; All cores start here (address ffff0000)
;
; We first read a register in the PMUSGRF at offset c000
; The PMU_GRF is at ff320000
; The PMU_SGRF is at ff330000
; The PMU_CRU is at ff750000
;  the PMUGRF regs are described on pp. 443 .. in the TRM
;  as near as I can tell the SGRF are registers that may
;  be manipulated in secure mode, and I have yet to find documentation

ffff0000 <.text>:
ffff0000:	580009c0 	ldr	x0, 0xffff0138 	; ff33c000 (PMUSGRF)
ffff0004:	b9400000 	ldr	w0, [x0]
ffff0008:	367800a0 	tbz	w0, #15, 0xffff001c

; We are here if the mystery register is non-zero
ffff000c:	58000920 	ldr	x0, 0xffff0130 	; ff760514 (CRU)
ffff0010:	b9400000 	ldr	w0, [x0]
ffff0014:	12001400 	and	w0, w0, #0x3f
ffff0018:	34000220 	cbz	w0, 0xffff005c

; Which core are we ?
; mpidr_el1 is the "multiprocessor affinity register"
; reading it lets us determine which core is running.
; The low 8 bits tell us which core (0,1,2,3) in a cluster
; The next 8 bits enable to to determine which cluster
ffff001c:	d53800a0 	mrs	x0, mpidr_el1
ffff0020:	92402000 	and	x0, x0, #0x1ff
ffff0024:	f100001f 	cmp	x0, #0x0
ffff0028:	54000200 	b.eq	0xffff0068

; We are some core other than cluster 0, core 0
; Cores other than cluster 0, core 0 will spin here.
; The mechanism for awakening one of these cores is as follows:
;
; Write the address to run to 0xff8c0008 (in SRAM)
; Write 0xdeadbeaf to 0xff8c0004 (in SRAM)
;
; Note that we write 0xdeadbeaf, not 0xdeadbeef
;
; It seems to me that this will wake up all the cores and
; take them to this other address, which will then have to
; sort them all out via the mpidr_el1 register.
; It is a little surprising that we cannot select a single core
; to bring out of this WFE spin loop, but it is what it is.
ffff002c:	58000760 	ldr	x0, 0xffff0118	;  ff8c0004
ffff0030:	52800021 	mov	w1, #0x1	; w1 = 1
ffff0034:	b9000001 	str	w1, [x0]	;  write the "1"
ffff0038:	d503205f 	wfe
ffff003c:	18000762 	ldr	w2, 0xffff0128	;  w2 = 0xdeadbeaf
ffff0040:	580006c0 	ldr	x0, 0xffff0118	;  ff8c0004
ffff0044:	b9400001 	ldr	w1, [x0]
ffff0048:	6b02003f 	cmp	w1, w2
ffff004c:	54ffff61 	b.ne	0xffff0038	; go back to sleep

ffff0050:	58000681 	ldr	x1, 0xffff0120	;  ff8c0008
ffff0054:	b9400020 	ldr	w0, [x1]
ffff0058:	d61f0000 	br	x0		; go run at that address

; Mystery register code continues here
; and we have another mystery register
; This is some mechanism to intercept a core coming out of reset
; without having it parked in the spin loop above.
ffff005c:	58000721 	ldr	x1, 0xffff0140 ;  ff33c180
ffff0060:	b9400020 	ldr	w0, [x1]
ffff0064:	d61f0000 	br	x0		; go run at that address

; cluster 0, core 0 comes here.
; This is the mainstream startup thread.
;
; zero each and every register

ffff0068:	aa1f03e0 	mov	x0, xzr
ffff006c:	aa1f03e1 	mov	x1, xzr
ffff0070:	aa1f03e2 	mov	x2, xzr
ffff0074:	aa1f03e3 	mov	x3, xzr
ffff0078:	aa1f03e4 	mov	x4, xzr
ffff007c:	aa1f03e5 	mov	x5, xzr
ffff0080:	aa1f03e6 	mov	x6, xzr
ffff0084:	aa1f03e7 	mov	x7, xzr
ffff0088:	aa1f03e8 	mov	x8, xzr
ffff008c:	aa1f03e9 	mov	x9, xzr
ffff0090:	aa1f03ea 	mov	x10, xzr
ffff0094:	aa1f03eb 	mov	x11, xzr
ffff0098:	aa1f03ec 	mov	x12, xzr
ffff009c:	aa1f03ed 	mov	x13, xzr
ffff00a0:	aa1f03ee 	mov	x14, xzr
ffff00a4:	aa1f03ef 	mov	x15, xzr
ffff00a8:	aa1f03f0 	mov	x16, xzr
ffff00ac:	aa1f03f1 	mov	x17, xzr
ffff00b0:	aa1f03f2 	mov	x18, xzr
ffff00b4:	aa1f03f3 	mov	x19, xzr
ffff00b8:	aa1f03f4 	mov	x20, xzr
ffff00bc:	aa1f03f5 	mov	x21, xzr
ffff00c0:	aa1f03f6 	mov	x22, xzr
ffff00c4:	aa1f03f7 	mov	x23, xzr
ffff00c8:	aa1f03f8 	mov	x24, xzr
ffff00cc:	aa1f03f9 	mov	x25, xzr
ffff00d0:	aa1f03fa 	mov	x26, xzr
ffff00d4:	aa1f03fb 	mov	x27, xzr
ffff00d8:	aa1f03fc 	mov	x28, xzr
ffff00dc:	aa1f03fd 	mov	x29, xzr
ffff00e0:	aa1f03fe 	mov	x30, xzr

; initialize our stack
ffff00e4:	58000120 	ldr	x0, 0xffff0108 ; ff8c2000
ffff00e8:	9100001f 	mov	sp, x0

; Initialize our vector table
ffff00ec:	58000120 	ldr	x0, 0xffff0110 ; ffff4800
ffff00f0:	d51ec000 	msr	vbar_el3, x0

; Go !
ffff00f4:	14001092 	b	0xffff433c
ffff00f8:	d503201f 	nop
ffff00fc:	d503201f 	nop

; No path to here that I can see ...
ffff0100:	14000f1a 	b	0xffff3d68
ffff0104:	d503201f 	nop

; Here are a bunch of 64 bit constants referenced above.

ffff0108: 00000000 ff8c2000	; this loads to the SP
ffff0110: 00000000 ffff4800	; this points to a vector table
ffff0118: 00000000 ff8c0004
ffff0120: 00000000 ff8c0008
ffff0128: 00000000 deadbeaf
ffff0130: 00000000 ff760514
ffff0138: 00000000 ff33c000
ffff0140: 00000000 ff33c180

; subroutine, called from below

ffff0148:	d10103ff 	sub	sp, sp, #0x40
ffff014c:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff0150:	9100c3fd 	add	x29, sp, #0x30
ffff0154:	a9025ff6 	stp	x22, x23, [sp, #32]
ffff0158:	a90157f4 	stp	x20, x21, [sp, #16]
ffff015c:	f90007f3 	str	x19, [sp, #8]
ffff0160:	aa0103f3 	mov	x19, x1
ffff0164:	aa0003f4 	mov	x20, x0
ffff0168:	b90007ff 	str	wzr, [sp, #4]
ffff016c:	52800020 	mov	w0, #0x1                   	// #1
ffff0170:	b4000353 	cbz	x19, 0xffff01d8
ffff0174:	52800315 	mov	w21, #0x18                  	// #24
ffff0178:	7100069f 	cmp	w20, #0x1
ffff017c:	54000080 	b.eq	0xffff018c  // b.none
ffff0180:	71000a9f 	cmp	w20, #0x2
ffff0184:	540002a1 	b.ne	0xffff01d8  // b.any
ffff0188:	52800335 	mov	w21, #0x19                  	// #25
ffff018c:	2a1f03f6 	mov	w22, wzr
ffff0190:	2a1f03f7 	mov	w23, wzr
ffff0194:	0b3542e1 	add	w1, w23, w21, uxtw
ffff0198:	910013e0 	add	x0, sp, #0x4
ffff019c:	52800022 	mov	w2, #0x1	; read 1 word
ffff01a0:	94000f73 	bl	0xffff3f6c	; read_efuse()
ffff01a4:	b94007e0 	ldr	w0, [sp, #4]
ffff01a8:	2a1f03e1 	mov	w1, wzr
ffff01ac:	340000a0 	cbz	w0, 0xffff01c0
ffff01b0:	51000402 	sub	w2, w0, #0x1
ffff01b4:	0a000040 	and	w0, w2, w0
ffff01b8:	11000421 	add	w1, w1, #0x1
ffff01bc:	35ffffa0 	cbnz	w0, 0xffff01b0
ffff01c0:	0b364036 	add	w22, w1, w22, uxtw
ffff01c4:	110006f7 	add	w23, w23, #0x1
ffff01c8:	6b3442ff 	cmp	w23, w20, uxtw
ffff01cc:	54fffe41 	b.ne	0xffff0194  // b.any
ffff01d0:	2a1f03e0 	mov	w0, wzr
ffff01d4:	b9000276 	str	w22, [x19]
ffff01d8:	f94007f3 	ldr	x19, [sp, #8]
ffff01dc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff01e0:	a9425ff6 	ldp	x22, x23, [sp, #32]
ffff01e4:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff01e8:	910103ff 	add	sp, sp, #0x40
ffff01ec:	d65f03c0 	ret

; subroutine
ffff01f0:	d10143ff 	sub	sp, sp, #0x50
ffff01f4:	a9047bfd 	stp	x29, x30, [sp, #64]
ffff01f8:	910103fd 	add	x29, sp, #0x40
ffff01fc:	a90367f8 	stp	x24, x25, [sp, #48]
ffff0200:	a9025ff6 	stp	x22, x23, [sp, #32]
ffff0204:	a90157f4 	stp	x20, x21, [sp, #16]
ffff0208:	f90007f3 	str	x19, [sp, #8]
ffff020c:	90ffc680 	adrp	x0, 0xff8c0000
ffff0210:	91006001 	add	x1, x0, #0x18
ffff0214:	39403022 	ldrb	w2, [x1, #12]
ffff0218:	34000442 	cbz	w2, 0xffff02a0
ffff021c:	b9400822 	ldr	w2, [x1, #8]
ffff0220:	b9400434 	ldr	w20, [x1, #4]
ffff0224:	6b34405f 	cmp	w2, w20, uxtw
ffff0228:	54000408 	b.hi	0xffff02a8  // b.pmore
ffff022c:	540003a0 	b.eq	0xffff02a0  // b.none
ffff0230:	b9401800 	ldr	w0, [x0, #24]
ffff0234:	7100081f 	cmp	w0, #0x2
ffff0238:	540000c1 	b.ne	0xffff0250  // b.any
ffff023c:	7100fe9f 	cmp	w20, #0x3f
ffff0240:	54000348 	b.hi	0xffff02a8  // b.pmore
ffff0244:	52800053 	mov	w19, #0x2                   	// #2
ffff0248:	52800335 	mov	w21, #0x19                  	// #25
ffff024c:	14000007 	b	0xffff0268
ffff0250:	7100041f 	cmp	w0, #0x1
ffff0254:	540002a1 	b.ne	0xffff02a8  // b.any
ffff0258:	52800315 	mov	w21, #0x18                  	// #24
ffff025c:	52800033 	mov	w19, #0x1                   	// #1
ffff0260:	71007e9f 	cmp	w20, #0x1f
ffff0264:	54000248 	b.hi	0xffff02ac  // b.pmore
ffff0268:	2a1f03f6 	mov	w22, wzr
ffff026c:	52800417 	mov	w23, #0x20                  	// #32
ffff0270:	12800018 	mov	w24, #0xffffffff            	// #-1
ffff0274:	7100829f 	cmp	w20, #0x20
ffff0278:	1a973299 	csel	w25, w20, w23, cc  // cc = lo, ul, last
ffff027c:	4b3942e0 	sub	w0, w23, w25, uxtw
ffff0280:	1ac02701 	lsr	w1, w24, w0
ffff0284:	0b3642a0 	add	w0, w21, w22, uxtw
ffff0288:	94001006 	bl	0xffff42a0
ffff028c:	350000e0 	cbnz	w0, 0xffff02a8
ffff0290:	4b394294 	sub	w20, w20, w25, uxtw
ffff0294:	110006d6 	add	w22, w22, #0x1
ffff0298:	6b3342df 	cmp	w22, w19, uxtw
ffff029c:	54fffec3 	b.cc	0xffff0274  // b.lo, b.ul, b.last
ffff02a0:	2a1f03f3 	mov	w19, wzr
ffff02a4:	14000002 	b	0xffff02ac
ffff02a8:	52800033 	mov	w19, #0x1                   	// #1
ffff02ac:	aa1303e0 	mov	x0, x19
ffff02b0:	f94007f3 	ldr	x19, [sp, #8]
ffff02b4:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff02b8:	a9425ff6 	ldp	x22, x23, [sp, #32]
ffff02bc:	a94367f8 	ldp	x24, x25, [sp, #48]
ffff02c0:	a9447bfd 	ldp	x29, x30, [sp, #64]
ffff02c4:	910143ff 	add	sp, sp, #0x50
ffff02c8:	d65f03c0 	ret

; ===============================================
; subroutine
;  -- called from 2 places.
;  -- in "try_four" loop, and from USB code

ffff02cc:	d10203ff 	sub	sp, sp, #0x80
ffff02d0:	a9077bfd 	stp	x29, x30, [sp, #112]
ffff02d4:	9101c3fd 	add	x29, sp, #0x70
ffff02d8:	a9065ff6 	stp	x22, x23, [sp, #96]
ffff02dc:	a90557f4 	stp	x20, x21, [sp, #80]
ffff02e0:	f90027f3 	str	x19, [sp, #72]

ffff02e4:	aa0003f4 	mov	x20, x0
ffff02e8:	b90007ff 	str	wzr, [sp, #4]
ffff02ec:	b9400280 	ldr	w0, [x20]

;	ffff4e6c:	5253 414b           "RSAK"

ffff02f0:	90000021 	adrp	x1, 0xffff4000
ffff02f4:	b94e6c21 	ldr	w1, [x1, #0xe6c]

; bail out with return code 1 if the first
; 4 bytes do not match "RSAK"
ffff02f8:	52800033 	mov	w19, #0x1
ffff02fc:	6b21401f 	cmp	w0, w1, uxtw
ffff0300:	54000761 	b.ne	0xffff03ec  // b.any

ffff0304:	90ffc696 	adrp	x22, 0xff8c0000
ffff0308:	b9001adf 	str	wzr, [x22, #24]

ffff030c:	910062d7 	add	x23, x22, #0x18		; SRAM + 0x18
ffff0310:	b9000eff 	str	wzr, [x23, #12]
ffff0314:	b9000aff 	str	wzr, [x23, #8]
ffff0318:	b90006ff 	str	wzr, [x23, #4]

ffff031c:	b9400a80 	ldr	w0, [x20, #8]
ffff0320:	364002c0 	tbz	w0, #8, 0xffff0378
ffff0324:	79402281 	ldrh	w1, [x20, #16]
ffff0328:	79402682 	ldrh	w2, [x20, #18]
ffff032c:	6b22403f 	cmp	w1, w2, uxtw
ffff0330:	540005e3 	b.cc	0xffff03ec
ffff0334:	53092c15 	ubfx	w21, w0, #9, #3
ffff0338:	910013e1 	add	x1, sp, #0x4
ffff033c:	aa1503e0 	mov	x0, x21
ffff0340:	97ffff82 	bl	0xffff0148		; call
ffff0344:	35000540 	cbnz	w0, 0xffff03ec
ffff0348:	79402281 	ldrh	w1, [x20, #16]
ffff034c:	b94007e0 	ldr	w0, [sp, #4]
ffff0350:	6b20403f 	cmp	w1, w0, uxtw
ffff0354:	540004c3 	b.cc	0xffff03ec
ffff0358:	39402681 	ldrb	w1, [x20, #9]
ffff035c:	372000e1 	tbnz	w1, #4, 0xffff0378
ffff0360:	79402681 	ldrh	w1, [x20, #18]
ffff0364:	b90006e1 	str	w1, [x23, #4]
ffff0368:	b9000ae0 	str	w0, [x23, #8]
ffff036c:	b9001ad5 	str	w21, [x22, #24]
ffff0370:	52800020 	mov	w0, #0x1                   	// #1
ffff0374:	390032e0 	strb	w0, [x23, #12]
ffff0378:	91008295 	add	x21, x20, #0x20
ffff037c:	910023f6 	add	x22, sp, #0x8
ffff0380:	52800101 	mov	w1, #0x8	; efuse offset
ffff0384:	52800102 	mov	w2, #0x8	; read 8 words
ffff0388:	aa1603e0 	mov	x0, x22		; put it here
ffff038c:	94000ef8 	bl	0xffff3f6c	; read_efuse()

ffff0390:	52804000 	mov	w0, #0x200
ffff0394:	94000050 	bl	0xffff04d4		; crypto_set_hash_len

ffff0398:	52804001 	mov	w1, #0x200
ffff039c:	aa1503e0 	mov	x0, x21
ffff03a0:	94000061 	bl	0xffff0524		; crypto2

ffff03a4:	9100a3f5 	add	x21, sp, #0x28
ffff03a8:	aa1503e0 	mov	x0, x21
ffff03ac:	94000071 	bl	0xffff0570		; crypto3

ffff03b0:	d2800402 	mov	x2, #0x20
ffff03b4:	aa1503e0 	mov	x0, x21
ffff03b8:	aa1603e1 	mov	x1, x22
ffff03bc:	94000fef 	bl	0xffff4378
ffff03c0:	35000160 	cbnz	w0, 0xffff03ec
ffff03c4:	b9400e80 	ldr	w0, [x20, #12]
ffff03c8:	321e3fe1 	mov	w1, #0x3fffc               	// #262140
ffff03cc:	0a000821 	and	w1, w1, w0, lsl #2
ffff03d0:	711c003f 	cmp	w1, #0x700
ffff03d4:	540000c8 	b.hi	0xffff03ec  // b.pmore
ffff03d8:	aa1403e0 	mov	x0, x20
ffff03dc:	94000150 	bl	0xffff091c
ffff03e0:	7100001f 	cmp	w0, #0x0
ffff03e4:	1a9f07e0 	cset	w0, ne
ffff03e8:	12000013 	and	w19, w0, #0x1

; done
ffff03ec:	aa1303e0 	mov	x0, x19
ffff03f0:	f94027f3 	ldr	x19, [sp, #72]
ffff03f4:	a94557f4 	ldp	x20, x21, [sp, #80]
ffff03f8:	a9465ff6 	ldp	x22, x23, [sp, #96]
ffff03fc:	a9477bfd 	ldp	x29, x30, [sp, #112]
ffff0400:	910203ff 	add	sp, sp, #0x80
ffff0404:	d65f03c0 	ret

; subroutine, 2 calls during initialization
ffff0408:	d10083ff 	sub	sp, sp, #0x20
ffff040c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff0410:	910043fd 	add	x29, sp, #0x10
ffff0414:	f90007f3 	str	x19, [sp, #8]
ffff0418:	b90007ff 	str	wzr, [sp, #4]

ffff041c:	d2bfef20 	mov	x0, #0xff790000		; GPIO4
ffff0420:	b9400001 	ldr	w1, [x0]		; read data register
ffff0424:	90000022 	adrp	x2, 0xffff4000
ffff0428:	b94e7042 	ldr	w2, [x2, #0xe70]	; ffff4e70: ff790004
ffff042c:	12047821 	and	w1, w1, #0xf7ffffff	; clear bit
ffff0430:	b9000001 	str	w1, [x0]		; write to data register
ffff0434:	b9400040 	ldr	w0, [x2]		; read dir register
ffff0438:	32050000 	orr	w0, w0, #0x8000000	; make this an output
ffff043c:	b9000040 	str	w0, [x2]

ffff0440:	52807d00 	mov	w0, #0x3e8
ffff0444:	9400017b 	bl	0xffff0a30	; xxdelay(1000)
ffff0448:	94000e85 	bl	0xffff3e5c	; read efuse (waste)
ffff044c:	52800033 	mov	w19, #0x1
ffff0450:	910013e0 	add	x0, sp, #0x4	; put fuse here
ffff0454:	52800022 	mov	w2, #0x1	; read 1 word
ffff0458:	aa1f03e1 	mov	x1, xzr		; read fuse 0
ffff045c:	94000ec4 	bl	0xffff3f6c	; read_efuse()
ffff0460:	394013e0 	ldrb	w0, [sp, #4]	; get the fuse
ffff0464:	7103fc1f 	cmp	w0, #0xff
ffff0468:	540000a1 	b.ne	0xffff047c
ffff046c:	90ffc680 	adrp	x0, 0xff8c0000	; fuse was 0xff
ffff0470:	b9000c13 	str	w19, [x0, #12]	; SRAM[3] = 1
ffff0474:	9400015f 	bl	0xffff09f0
ffff0478:	14000009 	b	0xffff049c

; fuse was not 0xff
; mess with registers in PMUSGRF
ffff047c:	90000020 	adrp	x0, 0xffff4000
ffff0480:	b94e7400 	ldr	w0, [x0, #0xe74]	; ffff4e74: ff33c000
ffff0484:	90000021 	adrp	x1, 0xffff4000
ffff0488:	b94e7821 	ldr	w1, [x1, #0xe78]	; ffff4e78: ff33e00c
ffff048c:	320d8fe2 	mov	w2, #0x780078
ffff0490:	b9000002 	str	w2, [x0]
ffff0494:	32048fe0 	mov	w0, #0xf000f000
ffff0498:	b9000020 	str	w0, [x1]
ffff049c:	b90007ff 	str	wzr, [sp, #4]

ffff04a0:	910013e0 	add	x0, sp, #0x4	; put fuse here
ffff04a4:	528003e1 	mov	w1, #0x1f	; read fuse 0x1f
ffff04a8:	52800022 	mov	w2, #0x1	; read 1 word
ffff04ac:	94000eb0 	bl	0xffff3f6c	; read_efuse()
ffff04b0:	b94007e0 	ldr	w0, [sp, #4]	; get the ruse
ffff04b4:	90000021 	adrp	x1, 0xffff4000
ffff04b8:	b94e7c21 	ldr	w1, [x1, #0xe7c]	; ffff4e7c: ff33c200
ffff04bc:	b9000020 	str	w0, [x1]

ffff04c0:	aa1f03e0 	mov	x0, xzr
ffff04c4:	f94007f3 	ldr	x19, [sp, #8]
ffff04c8:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff04cc:	910083ff 	add	sp, sp, #0x20
ffff04d0:	d65f03c0 	ret

; =======================================================================

; A number of routines follow which manipulate registers in the "crypto"
; hardware in the SoC.

; Here is what the datasheet says about this hardware:
; -- Embedded dual-channel encryption and decryption engine
; --  Support AES 128/192/256 bits key mode, ECB/CBC/CTR/XTS chain mode,
;         Slave/FIFO mode
; --  Support DES/3DES (ECB and CBC chain mode), 3DES (EDE/EEE key mode),
;         Slave/FIFO mode
; --  Support SHA1/SHA256/MD5(with hardware padding) HASH function,
;         FIFO mode only
; --  Support 160-bit Pseudo Random Number Generator (PRNG)
; --  Support 256-bit True Random Number Generator (TRNG)
; --  Support PKA 512/1024/2048 bit Exp Modulator
;
; Base address 0xff8b0000 is crypto0
; Base address 0xff8b8000 is crypto1
;
; There are two units, hence crypto0 and crypto1
; So far I have found no documentation in the TRM.
; However the register offsets and use match the RK3328

; only the first unit (crypto0) is used in this code

;  =======================================

; Here is what I see in "crypto_set_hash_len () which follows

;  crypt + 0xc |= 0x20
;    crypt + 0x188 = w0
;  crypt + 0x180 = 0xa
;  crypt + 0x8 = 0x40_0040
;  spin until crypt + 0x8 goes 0
;  return 0

; Now, looking at a driver for the rk3328 crypto
; c + 0xc is the config register, the above sets "address mode"
; c + 0x8 is the control register,
;	the above sets "hash flush"
;	note the business of the top 16 bits being an enable mask
; c + 0x0180 is the hash control register,
; c + 0x0188 is the hash length register,


;  =======================================

; subroutine crypto_set_hash_len ( length )

; set the length in bytes - 2 of something that will follow

ffff04d4:	90000021 	adrp	x1, 0xffff4000
ffff04d8:	b94e8021 	ldr	w1, [x1, #0xe80]	; ffff4e80: ff8b000c
ffff04dc:	b9400022 	ldr	w2, [x1]
ffff04e0:	321b0042 	orr	w2, w2, #0x20
ffff04e4:	b9000022 	str	w2, [x1]		; config |= 0x20

ffff04e8:	90000021 	adrp	x1, 0xffff4000
ffff04ec:	b94e8421 	ldr	w1, [x1, #0xe84]	; ffff4e84: ff8b0188
ffff04f0:	b9000020 	str	w0, [x1]		; hlen = arg

ffff04f4:	90000020 	adrp	x0, 0xffff4000
ffff04f8:	b94e8801 	ldr	w1, [x0, #0xe88]	; ffff4e88: ff8b0180

ffff04fc:	90000020 	adrp	x0, 0xffff4000
ffff0500:	b94e8c00 	ldr	w0, [x0, #0xe8c]	; ffff4e8c: ff8b0008

ffff0504:	52800142 	mov	w2, #0xa
ffff0508:	b9000022 	str	w2, [x1]		; hctl = 0xa

ffff050c:	320a83e1 	mov	w1, #0x400040
ffff0510:	b9000001 	str	w1, [x0]		; ctl = 0x40_0040

ffff0514:	b9400001 	ldr	w1, [x0]
ffff0518:	3737ffe1 	tbnz	w1, #6, 0xffff0514	; loop on ctl, bit 0x40

ffff051c:	aa1f03e0 	mov	x0, xzr			; return 0 (always)
ffff0520:	d65f03c0 	ret

;  =======================================

; subroutine crypto2 ( buf, len )

; spin reading control register until bit 3 (0x08) clears
; this bit is "hash start"
ffff0524:	90000022 	adrp	x2, 0xffff4000
ffff0528:	b94e9042 	ldr	w2, [x2, #0xe90]	; ffff4e90: ff8b0008
ffff052c:	b9400043 	ldr	w3, [x2]
ffff0530:	371fffa3 	tbnz	w3, #3, 0xffff0524

; write to clear "hash done" interrupt
ffff0534:	d2bff163 	mov	x3, #0xff8b0000		; crypto hw
ffff0538:	52800204 	mov	w4, #0x10
ffff053c:	b9000064 	str	w4, [x3]

; write "rcv dma start address"
ffff0540:	90000023 	adrp	x3, 0xffff4000
ffff0544:	b94e9463 	ldr	w3, [x3, #0xe94]	; ffff4e94: ff8b001c
ffff0548:	b9000060 	str	w0, [x3]

; write "rcv dma length"
ffff054c:	11000c20 	add	w0, w1, #0x3
ffff0550:	90000021 	adrp	x1, 0xffff4000
ffff0554:	b94e9821 	ldr	w1, [x1, #0xe98]	; ffff4e98: ff8b0020
ffff0558:	53027c00 	lsr	w0, w0, #2
ffff055c:	b9000020 	str	w0, [x1]

; write control register, set "hash start"
ffff0560:	320d83e0 	mov	w0, #0x80008
ffff0564:	b9000040 	str	w0, [x2]

ffff0568:	aa1f03e0 	mov	x0, xzr			; return 0 (always)
ffff056c:	d65f03c0 	ret

; subroutine "crypto3" -- only called once
; ffff4e9c: ff8b0008
; ffff4ea0: ff8b0184
; ffff4ea4: ff8b018c

ffff0570:	90000021 	adrp	x1, 0xffff4000
ffff0574:	b94e9c21 	ldr	w1, [x1, #0xe9c]	; ffff4e9c: ff8b0008
ffff0578:	b9400021 	ldr	w1, [x1]
ffff057c:	371fffa1 	tbnz	w1, #3, 0xffff0570
; loop
ffff0580:	90000021 	adrp	x1, 0xffff4000
ffff0584:	b94ea021 	ldr	w1, [x1, #0xea0]	; ffff4ea0: ff8b0184
ffff0588:	b9400021 	ldr	w1, [x1]
ffff058c:	34ffffa1 	cbz	w1, 0xffff0580
ffff0590:	aa1f03e1 	mov	x1, xzr
; loop
ffff0594:	90000022 	adrp	x2, 0xffff4000
ffff0598:	b94ea442 	ldr	w2, [x2, #0xea4]	; ffff4ea4: ff8b018c
ffff059c:	b8626822 	ldr	w2, [x1, x2]
ffff05a0:	b8216802 	str	w2, [x0, x1]
ffff05a4:	91001021 	add	x1, x1, #0x4
ffff05a8:	f100803f 	cmp	x1, #0x20
ffff05ac:	54ffff41 	b.ne	0xffff0594  // b.any
ffff05b0:	aa1f03e0 	mov	x0, xzr
ffff05b4:	d65f03c0 	ret

; subroutine "crypto4"
ffff05b8:	d100c3ff 	sub	sp, sp, #0x30
ffff05bc:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff05c0:	910083fd 	add	x29, sp, #0x20

ffff05c4:	90000021 	adrp	x1, 0xffff4000
ffff05c8:	b94ea821 	ldr	w1, [x1, #0xea8]	; ffff4ea8: ff8b0008
ffff05cc:	b9400021 	ldr	w1, [x1]
ffff05d0:	371fffa1 	tbnz	w1, #3, 0xffff05c4
ffff05d4:	90000021 	adrp	x1, 0xffff4000
ffff05d8:	b94eac21 	ldr	w1, [x1, #0xeac]	; ffff4eac: ff8b0184
ffff05dc:	b9400021 	ldr	w1, [x1]
ffff05e0:	34ffffa1 	cbz	w1, 0xffff05d4
ffff05e4:	aa1f03e1 	mov	x1, xzr
ffff05e8:	90000022 	adrp	x2, 0xffff4000
ffff05ec:	b94eb042 	ldr	w2, [x2, #0xeb0]	; ffff4eb0: ff8b018c
ffff05f0:	b8626822 	ldr	w2, [x1, x2]
ffff05f4:	910003e3 	mov	x3, sp
ffff05f8:	b8216862 	str	w2, [x3, x1]
ffff05fc:	91001021 	add	x1, x1, #0x4
ffff0600:	f100803f 	cmp	x1, #0x20
ffff0604:	54ffff21 	b.ne	0xffff05e8  // b.any
ffff0608:	910003e1 	mov	x1, sp
ffff060c:	d2800402 	mov	x2, #0x20                  	// #32
ffff0610:	94000f5a 	bl	0xffff4378
ffff0614:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff0618:	9100c3ff 	add	sp, sp, #0x30
ffff061c:	d65f03c0 	ret

; subroutine "crypto5" - never called
ffff0620:	d100c3ff 	sub	sp, sp, #0x30
ffff0624:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff0628:	910083fd 	add	x29, sp, #0x20
ffff062c:	a90157f4 	stp	x20, x21, [sp, #16]
ffff0630:	f90007f3 	str	x19, [sp, #8]
ffff0634:	aa0303f3 	mov	x19, x3
ffff0638:	aa0203f4 	mov	x20, x2
ffff063c:	aa0103f5 	mov	x21, x1
ffff0640:	aa0003e1 	mov	x1, x0
ffff0644:	d2bff160 	mov	x0, #0xff8b0000		; Crypto0
ffff0648:	52800402 	mov	w2, #0x20                  	// #32
ffff064c:	b9000002 	str	w2, [x0]
ffff0650:	90000020 	adrp	x0, 0xffff4000
ffff0654:	b94eb400 	ldr	w0, [x0, #0xeb4]	; ffff4eb4: ff8b0400
ffff0658:	d2802002 	mov	x2, #0x100                 	// #256
ffff065c:	94000f7d 	bl	0xffff4450	; memcpy
ffff0660:	90000020 	adrp	x0, 0xffff4000
ffff0664:	b94eb800 	ldr	w0, [x0, #0xeb8]	; ffff4eb8: ff8b0600
ffff0668:	d2802002 	mov	x2, #0x100                 	// #256
ffff066c:	aa1503e1 	mov	x1, x21
ffff0670:	94000f78 	bl	0xffff4450	; memcpy
ffff0674:	90000020 	adrp	x0, 0xffff4000
ffff0678:	b94ebc00 	ldr	w0, [x0, #0xebc]	; ffff4ebc: ff8b0700
ffff067c:	d2802002 	mov	x2, #0x100                 	// #256
ffff0680:	aa1403e1 	mov	x1, x20
ffff0684:	94000f73 	bl	0xffff4450	; memcpy
ffff0688:	90000020 	adrp	x0, 0xffff4000
ffff068c:	b94ec000 	ldr	w0, [x0, #0xec0]	; ffff4ec0: ff8b0500
ffff0690:	d2802002 	mov	x2, #0x100                 	// #256
ffff0694:	aa1303e1 	mov	x1, x19
ffff0698:	94000f6e 	bl	0xffff4450	; memcpy
ffff069c:	90000020 	adrp	x0, 0xffff4000
ffff06a0:	b94ec400 	ldr	w0, [x0, #0xec4]	; ffff4ec4: ff8b0008
ffff06a4:	b9400001 	ldr	w1, [x0]
ffff06a8:	3727ffa1 	tbnz	w1, #4, 0xffff069c
ffff06ac:	320c83e1 	mov	w1, #0x100010              	// #1048592
ffff06b0:	b9000001 	str	w1, [x0]
ffff06b4:	aa1f03e0 	mov	x0, xzr
ffff06b8:	f94007f3 	ldr	x19, [sp, #8]
ffff06bc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff06c0:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff06c4:	9100c3ff 	add	sp, sp, #0x30
ffff06c8:	d65f03c0 	ret

; loop -- but how do we get here?
ffff06cc:	90000021 	adrp	x1, 0xffff4000
ffff06d0:	b94ec821 	ldr	w1, [x1, #0xec8]	; ffff4ec8: ff8b0008
ffff06d4:	b9400021 	ldr	w1, [x1]
ffff06d8:	3727ffa1 	tbnz	w1, #4, 0xffff06cc

; ? how do we get here ?
ffff06dc:	aa1f03e1 	mov	x1, xzr
ffff06e0:	90000022 	adrp	x2, 0xffff4000
ffff06e4:	b94ecc42 	ldr	w2, [x2, #0xecc]	;ffff4ecc: ff8b0400
ffff06e8:	b8626822 	ldr	w2, [x1, x2]
ffff06ec:	b8216802 	str	w2, [x0, x1]
ffff06f0:	91001021 	add	x1, x1, #0x4
ffff06f4:	f100803f 	cmp	x1, #0x20
ffff06f8:	54ffff41 	b.ne	0xffff06e0  // b.any
ffff06fc:	aa1f03e0 	mov	x0, xzr
ffff0700:	d65f03c0 	ret

ffff0704:	d10103ff 	sub	sp, sp, #0x40
ffff0708:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff070c:	9100c3fd 	add	x29, sp, #0x30
ffff0710:	a90263f7 	stp	x23, x24, [sp, #32]
ffff0714:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff0718:	a90053f3 	stp	x19, x20, [sp]
ffff071c:	aa0303f3 	mov	x19, x3
ffff0720:	aa0203f4 	mov	x20, x2
ffff0724:	aa0103f5 	mov	x21, x1
ffff0728:	aa0003f6 	mov	x22, x0
ffff072c:	90000020 	adrp	x0, 0xffff4000
ffff0730:	b94ed017 	ldr	w23, [x0, #0xed0]
ffff0734:	90000020 	adrp	x0, 0xffff4000
ffff0738:	b94ed418 	ldr	w24, [x0, #0xed4]
ffff073c:	320287e0 	mov	w0, #0xc000c000            	// #-1073692672
ffff0740:	b90002e0 	str	w0, [x23]
ffff0744:	320b83e0 	mov	w0, #0x200020              	// #2097184
ffff0748:	b9000300 	str	w0, [x24]
ffff074c:	528000a0 	mov	w0, #0x5                   	// #5
ffff0750:	940000b8 	bl	0xffff0a30		; xxdelay(5)
ffff0754:	52a00400 	mov	w0, #0x200000              	// #2097152
ffff0758:	b9000300 	str	w0, [x24]
ffff075c:	52b80000 	mov	w0, #0xc0000000            	// #-1073741824
ffff0760:	b90002e0 	str	w0, [x23]
ffff0764:	90000020 	adrp	x0, 0xffff4000
ffff0768:	b94ed800 	ldr	w0, [x0, #0xed8]	; ffff4ed8: ff8b0280
ffff076c:	52800041 	mov	w1, #0x2                   	// #2
ffff0770:	b9000001 	str	w1, [x0]
ffff0774:	90000020 	adrp	x0, 0xffff4000
ffff0778:	b94edc17 	ldr	w23, [x0, #0xedc]
ffff077c:	320a87e0 	mov	w0, #0xc000c0              	// #12583104
ffff0780:	b90002e0 	str	w0, [x23]
ffff0784:	d2bff160 	mov	x0, #0xff8b0000		; Crypto0
ffff0788:	12800001 	mov	w1, #0xffffffff            	// #-1
ffff078c:	b9000001 	str	w1, [x0]
ffff0790:	52801200 	mov	w0, #0x90                  	// #144
ffff0794:	b94002e1 	ldr	w1, [x23]
ffff0798:	0a000021 	and	w1, w1, w0
ffff079c:	35ffffc1 	cbnz	w1, 0xffff0794
ffff07a0:	d2bff160 	mov	x0, #0xff8b0000		; Crypto0
ffff07a4:	52800401 	mov	w1, #0x20                  	// #32
ffff07a8:	b9000001 	str	w1, [x0]
ffff07ac:	90000020 	adrp	x0, 0xffff4000
ffff07b0:	b94ee000 	ldr	w0, [x0, #0xee0]
ffff07b4:	d2802002 	mov	x2, #0x100                 	// #256
ffff07b8:	aa1603e1 	mov	x1, x22
ffff07bc:	94000f25 	bl	0xffff4450	; memcpy
ffff07c0:	90000020 	adrp	x0, 0xffff4000
ffff07c4:	b94ee400 	ldr	w0, [x0, #0xee4]
ffff07c8:	d2802002 	mov	x2, #0x100                 	// #256
ffff07cc:	aa1503e1 	mov	x1, x21
ffff07d0:	94000f20 	bl	0xffff4450	; memcpy
ffff07d4:	90000020 	adrp	x0, 0xffff4000
ffff07d8:	b94ee800 	ldr	w0, [x0, #0xee8]
ffff07dc:	d2802002 	mov	x2, #0x100                 	// #256
ffff07e0:	aa1403e1 	mov	x1, x20
ffff07e4:	94000f1b 	bl	0xffff4450	; memcpy
ffff07e8:	90000020 	adrp	x0, 0xffff4000
ffff07ec:	b94eec00 	ldr	w0, [x0, #0xeec]
ffff07f0:	d2802002 	mov	x2, #0x100                 	// #256
ffff07f4:	aa1303e1 	mov	x1, x19
ffff07f8:	94000f16 	bl	0xffff4450	; memcpy
ffff07fc:	b94002e0 	ldr	w0, [x23]
ffff0800:	3727ffe0 	tbnz	w0, #4, 0xffff07fc
ffff0804:	320c83e0 	mov	w0, #0x100010              	// #1048592
ffff0808:	b90002e0 	str	w0, [x23]
ffff080c:	aa1f03e0 	mov	x0, xzr
ffff0810:	a94053f3 	ldp	x19, x20, [sp]
ffff0814:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff0818:	a94263f7 	ldp	x23, x24, [sp, #32]
ffff081c:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff0820:	910103ff 	add	sp, sp, #0x40
ffff0824:	d65f03c0 	ret

ffff0828:	d10143ff 	sub	sp, sp, #0x50
ffff082c:	a9047bfd 	stp	x29, x30, [sp, #64]
ffff0830:	910103fd 	add	x29, sp, #0x40
ffff0834:	90000020 	adrp	x0, 0xffff4000
ffff0838:	b94ef000 	ldr	w0, [x0, #0xef0]
ffff083c:	b9400001 	ldr	w1, [x0]
ffff0840:	371fffa1 	tbnz	w1, #3, 0xffff0834
ffff0844:	90000021 	adrp	x1, 0xffff4000
ffff0848:	b94ef421 	ldr	w1, [x1, #0xef4]
ffff084c:	b9400021 	ldr	w1, [x1]
ffff0850:	34ffffa1 	cbz	w1, 0xffff0844
ffff0854:	aa1f03e1 	mov	x1, xzr
ffff0858:	90000022 	adrp	x2, 0xffff4000
ffff085c:	b94ef842 	ldr	w2, [x2, #0xef8]
ffff0860:	b8626822 	ldr	w2, [x1, x2]
ffff0864:	910083e3 	add	x3, sp, #0x20
ffff0868:	b8216862 	str	w2, [x3, x1]
ffff086c:	91001021 	add	x1, x1, #0x4
ffff0870:	f100803f 	cmp	x1, #0x20
ffff0874:	54ffff21 	b.ne	0xffff0858  // b.any
ffff0878:	b9400001 	ldr	w1, [x0]
ffff087c:	3727ffe1 	tbnz	w1, #4, 0xffff0878
ffff0880:	90000020 	adrp	x0, 0xffff4000
ffff0884:	b94efc00 	ldr	w0, [x0, #0xefc]
ffff0888:	b9400000 	ldr	w0, [x0]
ffff088c:	90000021 	adrp	x1, 0xffff4000
ffff0890:	b94f0021 	ldr	w1, [x1, #0xf00]
ffff0894:	b9400021 	ldr	w1, [x1]
ffff0898:	aa008021 	orr	x1, x1, x0, lsl #32
ffff089c:	910003e0 	mov	x0, sp
ffff08a0:	f9000c01 	str	x1, [x0, #24]
ffff08a4:	90000021 	adrp	x1, 0xffff4000
ffff08a8:	b94f0421 	ldr	w1, [x1, #0xf04]
ffff08ac:	90000022 	adrp	x2, 0xffff4000
ffff08b0:	b94f0842 	ldr	w2, [x2, #0xf08]
ffff08b4:	b9400021 	ldr	w1, [x1]
ffff08b8:	b9400042 	ldr	w2, [x2]
ffff08bc:	aa018041 	orr	x1, x2, x1, lsl #32
ffff08c0:	f9000801 	str	x1, [x0, #16]
ffff08c4:	90000021 	adrp	x1, 0xffff4000
ffff08c8:	b94f0c21 	ldr	w1, [x1, #0xf0c]
ffff08cc:	90000022 	adrp	x2, 0xffff4000
ffff08d0:	b94f1042 	ldr	w2, [x2, #0xf10]
ffff08d4:	b9400021 	ldr	w1, [x1]
ffff08d8:	b9400042 	ldr	w2, [x2]
ffff08dc:	90000023 	adrp	x3, 0xffff4000
ffff08e0:	b94f1463 	ldr	w3, [x3, #0xf14]
ffff08e4:	90000024 	adrp	x4, 0xffff4000
ffff08e8:	b94f1884 	ldr	w4, [x4, #0xf18]
ffff08ec:	aa018041 	orr	x1, x2, x1, lsl #32
ffff08f0:	f9000401 	str	x1, [x0, #8]
ffff08f4:	b9400061 	ldr	w1, [x3]
ffff08f8:	b9400082 	ldr	w2, [x4]
ffff08fc:	aa018041 	orr	x1, x2, x1, lsl #32
ffff0900:	f90003e1 	str	x1, [sp]
ffff0904:	910083e1 	add	x1, sp, #0x20
ffff0908:	d2800402 	mov	x2, #0x20                  	// #32
ffff090c:	94000e9b 	bl	0xffff4378
ffff0910:	a9447bfd 	ldp	x29, x30, [sp, #64]
ffff0914:	910143ff 	add	sp, sp, #0x50
ffff0918:	d65f03c0 	ret
ffff091c:	d10083ff 	sub	sp, sp, #0x20
ffff0920:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff0924:	910043fd 	add	x29, sp, #0x10
ffff0928:	a90053f3 	stp	x19, x20, [sp]
ffff092c:	aa0103f3 	mov	x19, x1
ffff0930:	aa0003f4 	mov	x20, x0
ffff0934:	0b334280 	add	w0, w20, w19, uxtw
ffff0938:	53007c00 	lsr	w0, w0, #0
ffff093c:	91008281 	add	x1, x20, #0x20
ffff0940:	91048282 	add	x2, x20, #0x120
ffff0944:	91088283 	add	x3, x20, #0x220
ffff0948:	97ffff6f 	bl	0xffff0704
ffff094c:	90000020 	adrp	x0, 0xffff4000
ffff0950:	b94f1c00 	ldr	w0, [x0, #0xf1c]
ffff0954:	b9400001 	ldr	w1, [x0]
ffff0958:	321b0021 	orr	w1, w1, #0x20
ffff095c:	b9000001 	str	w1, [x0]
ffff0960:	90000020 	adrp	x0, 0xffff4000
ffff0964:	b94f2000 	ldr	w0, [x0, #0xf20]
ffff0968:	b9000013 	str	w19, [x0]
ffff096c:	90000020 	adrp	x0, 0xffff4000
ffff0970:	b94f2401 	ldr	w1, [x0, #0xf24]
ffff0974:	90000020 	adrp	x0, 0xffff4000
ffff0978:	b94f2800 	ldr	w0, [x0, #0xf28]
ffff097c:	52800142 	mov	w2, #0xa                   	// #10
ffff0980:	b9000022 	str	w2, [x1]
ffff0984:	320a83e1 	mov	w1, #0x400040              	// #4194368
ffff0988:	b9000001 	str	w1, [x0]
ffff098c:	b9400001 	ldr	w1, [x0]
ffff0990:	3737ffe1 	tbnz	w1, #6, 0xffff098c
ffff0994:	b9400001 	ldr	w1, [x0]
ffff0998:	371fffe1 	tbnz	w1, #3, 0xffff0994
ffff099c:	d2bff161 	mov	x1, #0xff8b0000		; Crypto0
ffff09a0:	52800202 	mov	w2, #0x10                  	// #16
ffff09a4:	b9000022 	str	w2, [x1]
ffff09a8:	90000021 	adrp	x1, 0xffff4000
ffff09ac:	b94f2c21 	ldr	w1, [x1, #0xf2c]
ffff09b0:	b9000034 	str	w20, [x1]
ffff09b4:	11000e61 	add	w1, w19, #0x3
ffff09b8:	90000022 	adrp	x2, 0xffff4000
ffff09bc:	b94f3042 	ldr	w2, [x2, #0xf30]
ffff09c0:	53027c21 	lsr	w1, w1, #2
ffff09c4:	b9000041 	str	w1, [x2]
ffff09c8:	320d83e1 	mov	w1, #0x80008               	// #524296
ffff09cc:	b9000001 	str	w1, [x0]
ffff09d0:	97ffff96 	bl	0xffff0828
ffff09d4:	7100001f 	cmp	w0, #0x0
ffff09d8:	1a9f07e0 	cset	w0, ne  // ne = any
ffff09dc:	92400000 	and	x0, x0, #0x1
ffff09e0:	a94053f3 	ldp	x19, x20, [sp]
ffff09e4:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff09e8:	910083ff 	add	sp, sp, #0x20
ffff09ec:	d65f03c0 	ret

; subroutine - one call above during init
ffff09f0:	90000020 	adrp	x0, 0xffff4000
ffff09f4:	b94f3400 	ldr	w0, [x0, #0xf34]	; ffff4f34: 00df0043
ffff09f8:	90000021 	adrp	x1, 0xffff4000
ffff09fc:	b94f3821 	ldr	w1, [x1, #0xf38]	; ffff4f38: ff760160
ffff0a00:	90000022 	adrp	x2, 0xffff4000
ffff0a04:	b94f3c42 	ldr	w2, [x2, #0xf3c]	; ffff4f3c: ff33e018
ffff0a08:	b9000020 	str	w0, [x1]
ffff0a0c:	52a10000 	mov	w0, #0x8000000
ffff0a10:	b9000040 	str	w0, [x2]
ffff0a14:	d65f03c0 	ret

; ==============================================================
; subroutine - read first 4 bytes of SRAM (SRAM[0])
; this is the posted CPU clock speed in Mhz

ffff0a18:	90ffc680 	adrp	x0, 0xff8c0000
ffff0a1c:	b9400000 	ldr	w0, [x0]
ffff0a20:	d65f03c0 	ret

; subroutine - write first 4 bytes of SRAM (SRAM[0])
; only called in 2 places.
; one writes the value 24, the other 400 or 200
; this is the CPU clock speed in Mhz

ffff0a24:	90ffc681 	adrp	x1, 0xff8c0000
ffff0a28:	b9000020 	str	w0, [x1]		; SRAM[0] = arg
ffff0a2c:	d65f03c0 	ret

; ==============================================================
; Many calls to this routine.
; I will call it "xxdelay()"
;
; it is commonly called with xxdelay(1)
; but values of 10, 100, 500, 1000, 2000 are used.
;
; In essence it is some kind of variable delay loop
; that depends on the argument in w0 as well as
; the value stored in SRAM[0] (the cpu speed in Mhz)
;
; As near as I can tell, only 3 values are ever stored into SRAM[0]
; either 24 or 200 or 400
; so the first branch below is used when SRAM[0] = 24 and xxdelay(1)
;  is the call, i.e. for a very short delay.
;
; The "madd" instruction is the star of the show
; this is the only place in this code that "madd" is used.
; In the code here, it essentially does:
;     w0 = w1 + w0 * w2

ffff0a30:	d10043ff 	sub	sp, sp, #0x10
ffff0a34:	a9007bfd 	stp	x29, x30, [sp]
ffff0a38:	910003fd 	mov	x29, sp			; why ?

ffff0a3c:	90ffc681 	adrp	x1, 0xff8c0000		; SRAM
ffff0a40:	b9400021 	ldr	w1, [x1]		; read SRAM[0]
ffff0a44:	1b007c20 	mul	w0, w1, w0

; Here we have calculated w0 = arg*mhz
; We compare the cpu mhz to 0x18 (24)
; if it matches, w0 = (0x1fff + w0 * 0x75) >> 13
; otherwise ---  w0 = (0x7fff + w0 * 0xb9) >> 15
; if this result is non-zero, we use it to delay
;
; Just out of curiosity, what happens when this is called with xxdelay(1)
; and the cpu speed is 24?  We calculate 0x1fff + 24 * 117 = 10999
; We shift this right 13 bits to get 1
; This goes to a simple delay that will execute 2 instructions
; per count.  This seems like pretty short delay.
; What if the cpu speed is 400 and we ask for a delay of 10
; calculate 32767 + 4000 * 185 = 772767
; shift this by 2 to get 23, still a very short delay

ffff0a48:	7100603f 	cmp	w1, #0x18
ffff0a4c:	540000c1 	b.ne	0xffff0a64
ffff0a50:	5283ffe1 	mov	w1, #0x1fff                	// #8191
ffff0a54:	52800ea2 	mov	w2, #0x75                  	// #117
ffff0a58:	1b020400 	madd	w0, w0, w2, w1
ffff0a5c:	530d7c00 	lsr	w0, w0, #13
ffff0a60:	14000005 	b	0xffff0a74
ffff0a64:	528fffe1 	mov	w1, #0x7fff                	// #32767
ffff0a68:	52801722 	mov	w2, #0xb9                  	// #185
ffff0a6c:	1b020400 	madd	w0, w0, w2, w1
ffff0a70:	530f7c00 	lsr	w0, w0, #15
ffff0a74:	34000040 	cbz	w0, 0xffff0a7c
ffff0a78:	94000f05 	bl	0xffff468c		; delay on x0
ffff0a7c:	a9407bfd 	ldp	x29, x30, [sp]
ffff0a80:	910043ff 	add	sp, sp, #0x10
ffff0a84:	d65f03c0 	ret

; subroutine mmdelay ( count )
; x0 is argument, and is count of how many times
; to make calls to xxdelay(1000)
ffff0a88:	d10083ff 	sub	sp, sp, #0x20
ffff0a8c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff0a90:	910043fd 	add	x29, sp, #0x10
ffff0a94:	f90007f3 	str	x19, [sp, #8]

ffff0a98:	aa0003f3 	mov	x19, x0			; x19 = arg
ffff0a9c:	340000b3 	cbz	w19, 0xffff0ab0
ffff0aa0:	51000673 	sub	w19, w19, #0x1		; x19--
ffff0aa4:	52807d00 	mov	w0, #0x3e8              ; w0 = 1000
ffff0aa8:	97ffffe2 	bl	0xffff0a30		; xxdelay ( 1000 )
ffff0aac:	35ffffb3 	cbnz	w19, 0xffff0aa0

ffff0ab0:	f94007f3 	ldr	x19, [sp, #8]
ffff0ab4:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff0ab8:	910083ff 	add	sp, sp, #0x20
ffff0abc:	d65f03c0 	ret

; subroutine, called once during startup.
; Writing a variety of stuff to ff76 addresses (CRU)
; CRU is the clock and reset unit
ffff0ac0:	90000020 	adrp	x0, 0xffff4000
ffff0ac4:	b94f4000 	ldr	w0, [x0, #0xf40] 	; ffff4f40: ff76000c
ffff0ac8:	52a06001 	mov	w1, #0x3000000
ffff0acc:	b9000001 	str	w1, [x0]

ffff0ad0:	90000020 	adrp	x0, 0xffff4000
ffff0ad4:	b94f4400 	ldr	w0, [x0, #0xf44]	; ffff4f44: ff76008c
ffff0ad8:	b9000001 	str	w1, [x0]

; This register controls the A53 cluster core clocks
ffff0adc:	90000020 	adrp	x0, 0xffff4000
ffff0ae0:	b94f4800 	ldr	w0, [x0, #0xf48]	; ffff4f48: ff760100
ffff0ae4:	52a3fbe1 	mov	w1, #0x1fdf0000
ffff0ae8:	b9000001 	str	w1, [x0]

ffff0aec:	90000020 	adrp	x0, 0xffff4000
ffff0af0:	b94f4c00 	ldr	w0, [x0, #0xf4c]	; ffff4f4c: ff760104
ffff0af4:	52a3e3e1 	mov	w1, #0x1f1f0000
ffff0af8:	b9000001 	str	w1, [x0]

ffff0afc:	90000020 	adrp	x0, 0xffff4000
ffff0b00:	b94f5000 	ldr	w0, [x0, #0xf50]	; ffff4f50: 00df0040
ffff0b04:	90000021 	adrp	x1, 0xffff4000
ffff0b08:	b94f5421 	ldr	w1, [x1, #0xf54]	; ffff4f54: ff760110
ffff0b0c:	b9000020 	str	w0, [x1]

ffff0b10:	90000020 	adrp	x0, 0xffff4000
ffff0b14:	b94f5800 	ldr	w0, [x0, #0xf58]	; ffff4f58: 9fdf8040
ffff0b18:	90000021 	adrp	x1, 0xffff4000
ffff0b1c:	b94f5c21 	ldr	w1, [x1, #0xf5c]	; ffff4f5c: ff760114
ffff0b20:	b9000020 	str	w0, [x1]

ffff0b24:	90000020 	adrp	x0, 0xffff4000
ffff0b28:	b94f6000 	ldr	w0, [x0, #0xf60]	; ffff4f60: ff760130
ffff0b2c:	52ae73e1 	mov	w1, #0x739f0000
ffff0b30:	b9000001 	str	w1, [x0]

ffff0b34:	90000020 	adrp	x0, 0xffff4000
ffff0b38:	b94f6400 	ldr	w0, [x0, #0xf64]	; ffff4f64: 739f0080
ffff0b3c:	90000021 	adrp	x1, 0xffff4000
ffff0b40:	b94f6821 	ldr	w1, [x1, #0xf68]	; ffff4f68: ff760138
ffff0b44:	b9000020 	str	w0, [x1]

ffff0b48:	90000021 	adrp	x1, 0xffff4000
ffff0b4c:	b94f6c21 	ldr	w1, [x1, #0xf6c]	; ffff4f6c: ff76015c
ffff0b50:	90000022 	adrp	x2, 0xffff4000
ffff0b54:	b94f7042 	ldr	w2, [x2, #0xf70]	; ffff4f70: 079f0080
ffff0b58:	90000023 	adrp	x3, 0xffff4000
ffff0b5c:	b94f7463 	ldr	w3, [x3, #0xf74]	; ffff4f74: ff760164
ffff0b60:	90000024 	adrp	x4, 0xffff4000
ffff0b64:	b94f7884 	ldr	w4, [x4, #0xf78]	; ffff4f78: ff7601e4
ffff0b68:	b9000020 	str	w0, [x1]
ffff0b6c:	b9000062 	str	w2, [x3]

ffff0b70:	52a003e0 	mov	w0, #0x1f0000
ffff0b74:	b9000080 	str	w0, [x4]
ffff0b78:	d65f03c0 	ret
 
; =======================================================
; subroutine, called from 2 places

ffff0b7c:	d10083ff 	sub	sp, sp, #0x20
ffff0b80:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff0b84:	910043fd 	add	x29, sp, #0x10
ffff0b88:	a90053f3 	stp	x19, x20, [sp]

ffff0b8c:	97ffffa3 	bl	0xffff0a18		; get cpu clock speed
ffff0b90:	71031c1f 	cmp	w0, #199
ffff0b94:	54000ce8 	b.hi	0xffff0d30

; set the CRU_LPLL_CON3 register to 0x10001
; as always the upper 16 bits are a mask,
; so we are changing one bit only (the lowest)
; which is (of all things) global power down.
; presumably this powers down the PLL, not the entire SoC
; NOTE that x19 holds a pointer to this register for
;   the end of the routine
ffff0b98:	90000020 	adrp	x0, 0xffff4000
ffff0b9c:	b94f7c13 	ldr	w19, [x0, #0xf7c]	; ffff4f7c: ff76000c
ffff0ba0:	320083e0 	mov	w0, #0x10001
ffff0ba4:	b9000260 	str	w0, [x19]

; Once it is powered down, set another bit
; this is PLL saturation enable, putting it into power down.
ffff0ba8:	320d83e1 	mov	w1, #0x80008
ffff0bac:	b9000261 	str	w1, [x19]

; Now set the feedback divide value in CRU_LPLL_CON0
; we set the value to 0xc8 (reset value is 0x96)
; 0xc8 = 200

ffff0bb0:	90000022 	adrp	x2, 0xffff4000
ffff0bb4:	b94f8042 	ldr	w2, [x2, #0xf80]	; ffff4f80: 0fff00c8
ffff0bb8:	d2bfeec3 	mov	x3, #0xff760000
ffff0bbc:	b9000062 	str	w2, [x3]

; Now the mask is 773f and the value is 1403
; This sets the CRU_LPLL_CON1 register (trm, page 72)
;  postdiv2 = 1
;  postdiv1 = 4
;  refdiv = 3

ffff0bc0:	90000022 	adrp	x2, 0xffff4000
ffff0bc4:	b94f8442 	ldr	w2, [x2, #0xf84]	; ffff4f84: 773f1403
ffff0bc8:	90000023 	adrp	x3, 0xffff4000
ffff0bcc:	b94f8863 	ldr	w3, [x3, #0xf88]	; ffff4f88: ff760004
ffff0bd0:	b9000062 	str	w2, [x3]

; x20 gets a pointer to the CRU_GPLL_CON3 register (trm, p 86) 
; NOTE that x20 retains a pointer to this register for
;   the end of the routine.
; Also note that we write to it the same sequence of values
;  used above for CUR_LPLL_CON3 register
; First we write 0x10001, which sets the global power down
; Then we write 0x80008, which powers down the saturation thing.

ffff0bd4:	90000022 	adrp	x2, 0xffff4000
ffff0bd8:	b94f8c54 	ldr	w20, [x2, #0xf8c]	; ffff4f8c: ff76008c

ffff0bdc:	90000022 	adrp	x2, 0xffff4000
ffff0be0:	b94f9042 	ldr	w2, [x2, #0xf90]	; ffff4f90: 0fff00c0
ffff0be4:	90000023 	adrp	x3, 0xffff4000
ffff0be8:	b94f9463 	ldr	w3, [x3, #0xf94]	; ffff4f94: ff760080
ffff0bec:	90000024 	adrp	x4, 0xffff4000
ffff0bf0:	b94f9884 	ldr	w4, [x4, #0xf98]	; ffff4f98: 773f2302
ffff0bf4:	90000025 	adrp	x5, 0xffff4000
ffff0bf8:	b94f9ca5 	ldr	w5, [x5, #0xf9c]	j ffff4f9c: ff760084
ffff0bfc:	b9000280 	str	w0, [x20]
ffff0c00:	b9000281 	str	w1, [x20]

; write 0fff_00c0 to CRU_GPLL_CON0 (offset 0x80, trm page 84)
; this has one 12 bit field "fbdiv",
; which we set to 0xc0 (reset value is 0xc6)
; write 773f_2302 to CRU_GPLL_CON1 (offset 0x84, trm page 85)
; this has 3 divisors, we set:
; postdiv2 = 2
; postdiv1 = 3
; refdev = 2

ffff0c04:	b9000062 	str	w2, [x3]
ffff0c08:	b90000a4 	str	w4, [x5]

ffff0c0c:	52800140 	mov	w0, #0xa
ffff0c10:	97ffff88 	bl	0xffff0a30		; xxdelay(10)

; clear the global power down bits
ffff0c14:	52a00020 	mov	w0, #0x10000               	// #65536
ffff0c18:	b9000260 	str	w0, [x19]
ffff0c1c:	b9000280 	str	w0, [x20]

ffff0c20:	52807d00 	mov	w0, #0x3e8              ; w0 = 1000
ffff0c24:	97ffff83 	bl	0xffff0a30		; xxdelay(1000)

; now read the "global reset status" register
; CRU_GLB_RST_ST (trm, page 191(
; mask out the low (and only) 5 bits.
; if they are zero set CPU at 400
; otherwise fall through and set 200
ffff0c28:	90000020 	adrp	x0, 0xffff4000
ffff0c2c:	b94fa000 	ldr	w0, [x0, #0xfa0]	; ffff4fa0: ff760514
ffff0c30:	b9400000 	ldr	w0, [x0]
ffff0c34:	12001400 	and	w0, w0, #0x3f
ffff0c38:	34000100 	cbz	w0, 0xffff0c58

; Write to CRU_CLKSEL_CON0 (trm, p. 94)
; We write 1fdf_0101
; the mask is 0001_111_1101_1111
; a 5 bit field = 1 -- aclkm_core_l_div (clk=src/(div+1))
; a 2 bit field = 0 -- clk_core_l_pll_sel = LPLL
; a 5 bit field = 1 -- clk_core_l_div
; setting 1 in the last field gets a divide by 2.
;
; a note here.  the "l" in these is matched by a "b"
; in another register.  So I believe this controls the clock
; for all 4 "little" A53 cores.  The "b" control is for
; the "big" A72 cores.
; This would be handled by the CON2 register at offset 0x108

ffff0c3c:	90000020 	adrp	x0, 0xffff4000
ffff0c40:	b94fa400 	ldr	w0, [x0, #0xfa4]	; ffff4fa4: 1fdf0101
ffff0c44:	90000021 	adrp	x1, 0xffff4000
ffff0c48:	b94fa821 	ldr	w1, [x1, #0xfa8]	; ffff4fa8: ff760100
ffff0c4c:	b9000020 	str	w0, [x1]
ffff0c50:	52801900 	mov	w0, #0xc8               ; declare CPU at 200 Mhz
ffff0c54:	14000007 	b	0xffff0c70

; Write to CRU_CLKSEL_CON0 (trm, p. 94)
; the same mask as above, the only difference is the last field
; where we set the div to 0 (yielding a divide by 1).
ffff0c58:	90000020 	adrp	x0, 0xffff4000
ffff0c5c:	b94fac00 	ldr	w0, [x0, #0xfac]	; ffff4fac: 1fdf0100
ffff0c60:	90000021 	adrp	x1, 0xffff4000
ffff0c64:	b94fa821 	ldr	w1, [x1, #0xfa8]	; ffff4fa8: ff760100
ffff0c68:	b9000020 	str	w0, [x1]
ffff0c6c:	52803200 	mov	w0, #0x190              ; declare CPU at 400 Mhz

; 0xff76---- addresses are in the CRU
; note that there is a PMUCRU with a different base.
;
; The pmu registers are 32 bit.
;  the upper 16 bits are an "enable" mask indicating
;  which bits in the lower 16 ought to be changed.
;
; here is a commentary on the following:
;  ff760104 = 1f1f0303
;    this is CRU_CLKSEL_CON1 (trm, p 95)
;    we have two 5 bit fields, both getting set to 3
;    these set clk = clk_src / (con+1)
;    the upper field is pclk_dbg_l
;    the lower field is atclk_core_l
;
;  ff760110 = 00df0043
;    this is CRU_CLKSEL_CON4 (trm, p. 96)
;    we have a 2 bit field and a 5 bit field
;    the mask is 1101_1111
;    The upper 2 is clk_cs_pll_select
;     we set the bits to 01, selecting GPLL
;    The lower 5 bits go to 3
;     this is clk_cs_div
;
;  ff760114 = 9fdf8341
;    this is CRU_CLKSEL_CON5 (trm, p. 96)
;    the mask is 1001_1111_1101_1111
;    the top bit is clk_cci_trace_pll_sel, 1 selects GPLL
;    the next 5 bits are clk_cci_trace_div = 3
;      where clk = clk_src / (con+1)
;    then 2 bits are aclk_cci_pll_sel = 2 (GPLL)
;    The bottom 5 bits are aclk_cci_div = 1
;      where clk = clk_src / (con+1)
;
;  ff760130 = 739f0100
;    this is CRU_CLKSEL_CON12 (trm, p 100)
;    the mask is 0111_0011_1001_1111
;    the top 2 bits are not fully unmasked (typo/bug?)
;    they are aclk_center_pll_sel = 0 (CPLL)
;    we then have a 5 bit field (also oddly masked), set to 1 (GPLL) maybe
;    this is aclk_center_div
;    then we should have 2 more bits, oddly masked, setting 0 (CPLL) maybe
;    this is clk_rga_core_pll_sel
;    finally the bottom 5 bits, properly masked set 0
;    this is clk_rga_core_div
;
; ff760138 = 739f3181
;    this is CRU_CLKSEL_CON14 (trm, p 102)
;    the mask is 0111_0011_1001_1111 (again)
;    the top bit (neither selected or set) is clk_usbpll_480m_sel
;    the next 3 are a divisor  pclk_periphp_div = 3
;    skip 2 bits
;    the next 2 are a divisor  hclk_perihp_div = 1
;    a single bit (set to 1) is aclk_perihp_pll_sel = CPLL
;    the next 2 bits are unmodified (clk_usbphy_480m_ch_sel)
;    the last 5 bits are a divisor aclk_perihp_div = 1
;
; ff76015c = 739f3181
;    - oddly enough this gets set to the same value as the previous register
;    this is CRU_CLKSEL_CON23 (trm, p 106)
;    the mask is 0111_0011_1001_1111 (again)
;    we skip bit 15
;    then a 3 bit field set to 3 -- pclk_perilp0_div
;    we skip 2 bits
;    then a 2 bit field set to 1 -- hclk_perilp0_div
;    then a 1 bit field set to 1 -- aclk_perilp0_pll_sel = CPLL
;    we skip 2 bits
;    finally a 5 bit field set to 1 -- aclk_perilp0_div
;
; ff760164 = 079f0183
;    this is CRU_CLKSEL_CON25 (trm, p 108)
;    the mask is 1111_1111_0111_0110
;    we skip the top 5 bits
;    the next 3 set to 1 -- pclk_perilp1_div
;    a 1 bit field, not selected by the mask
;    skip 2 bits
;    a 5 bit field, oddly masked (bug?) hclk_perilp1_div
;
; ff7601e0 = 001f8300
;    this is CRU_CLKSEL_CON56 (trm, p 122)
;    the mask is 0000_0000_0001_1111
;    the top 8 bits are unmolested -- aclk_gic_pll and div
;    the next 2 are unmolested -- clk_cif_pll_sel
;    a single bit = 0 -- clk_cif_clk_sel = clk_cif_src
;    the low 5 bits = 0 are clk_cif_div
;    (this looks odd and perhaps buggy to me)
;
; ff7601e4 = 001f0005
;    this is CRU_CLKSEL_CON57 (trm, p 123)
;    the mask is 0000_0000_0001_1111
;    we leave clkout_24m_div alone
;    we set via the low 5 bits = 5 -- pclk_alive_div


ffff0c70:	90000021 	adrp	x1, 0xffff4000
ffff0c74:	b94fb021 	ldr	w1, [x1, #0xfb0]	; ffff4fb0: 1f1f0303
ffff0c78:	90000022 	adrp	x2, 0xffff4000
ffff0c7c:	b94fb442 	ldr	w2, [x2, #0xfb4]	; ffff4fb4: ff760104
ffff0c80:	b9000041 	str	w1, [x2]
ffff0c84:	90000021 	adrp	x1, 0xffff4000
ffff0c88:	b94fb821 	ldr	w1, [x1, #0xfb8]	; ffff4fb8: 00df0043
ffff0c8c:	90000022 	adrp	x2, 0xffff4000
ffff0c90:	b94fbc42 	ldr	w2, [x2, #0xfbc]	; ffff4fbc: ff760110
ffff0c94:	b9000041 	str	w1, [x2]
ffff0c98:	90000021 	adrp	x1, 0xffff4000
ffff0c9c:	b94fc021 	ldr	w1, [x1, #0xfc0]	; ffff4fc0: 9fdf8341
ffff0ca0:	90000022 	adrp	x2, 0xffff4000
ffff0ca4:	b94fc442 	ldr	w2, [x2, #0xfc4]	; ffff4fc4: ff760114
ffff0ca8:	b9000041 	str	w1, [x2]
ffff0cac:	90000021 	adrp	x1, 0xffff4000
ffff0cb0:	b94fc821 	ldr	w1, [x1, #0xfc8]	; ffff4fc8: 739f0100
ffff0cb4:	90000022 	adrp	x2, 0xffff4000
ffff0cb8:	b94fcc42 	ldr	w2, [x2, #0xfcc]	; ffff4fcc: ff760130
ffff0cbc:	b9000041 	str	w1, [x2]
ffff0cc0:	90000021 	adrp	x1, 0xffff4000
ffff0cc4:	b94fd021 	ldr	w1, [x1, #0xfd0]	; ffff4fd0: 739f3181
ffff0cc8:	90000022 	adrp	x2, 0xffff4000
ffff0ccc:	b94fd442 	ldr	w2, [x2, #0xfd4]	; ffff4fd4: ff760138
ffff0cd0:	b9000041 	str	w1, [x2]

ffff0cd4:	90000022 	adrp	x2, 0xffff4000
ffff0cd8:	b94fd842 	ldr	w2, [x2, #0xfd8]	; ffff4fd8: ff76015c
ffff0cdc:	b9000041 	str	w1, [x2]

ffff0ce0:	90000021 	adrp	x1, 0xffff4000
ffff0ce4:	b94fdc21 	ldr	w1, [x1, #0xfdc]	; ffff4fdc: 079f0183
ffff0ce8:	90000022 	adrp	x2, 0xffff4000
ffff0cec:	b94fe042 	ldr	w2, [x2, #0xfe0]	; ffff4fe0: ff760164
ffff0cf0:	b9000041 	str	w1, [x2]

ffff0cf4:	90000021 	adrp	x1, 0xffff4000
ffff0cf8:	b94fe421 	ldr	w1, [x1, #0xfe4]	; ffff4fe4: 001f8300
ffff0cfc:	90000022 	adrp	x2, 0xffff4000
ffff0d00:	b94fe842 	ldr	w2, [x2, #0xfe8]	; ffff4fe8: ff7601e0
ffff0d04:	90000023 	adrp	x3, 0xffff4000
ffff0d08:	b94fec63 	ldr	w3, [x3, #0xfec]	; ffff4fec: 001f0005
ffff0d0c:	90000024 	adrp	x4, 0xffff4000
ffff0d10:	b94ff084 	ldr	w4, [x4, #0xff0]	; ffff4ff0: ff7601e4
ffff0d14:	90000025 	adrp	x5, 0xffff4000
ffff0d18:	b94ff4a5 	ldr	w5, [x5, #0xff4]	; ffff4ff4: 03000100
ffff0d1c:	b9000041 	str	w1, [x2]
ffff0d20:	b9000083 	str	w3, [x4]

; Notes on the following writes.  These are to 
;  the CRU_LPLL_CON3 register and
;  the CRU_GPLL_CON3 register
; the value written to both is 0x03000100
; this enables a 2 bit field (bits 9 and 8)
;  which is PLL work mode, setting it to 1
;        (Normal mode, clock from PLL output)
; Note that nothing has been done to clear the power down bits !?

ffff0d24:	b9000265 	str	w5, [x19]
ffff0d28:	b9000285 	str	w5, [x20]

; call this routine to post the CPU speed we just set
ffff0d2c:	97ffff3e 	bl	0xffff0a24		; SRAM[0] = 400 or 200

; My theory on the above is that 400 (or 200) is the processor speed in Mhz.
; It starts up 24 Mhz, but the above bumps it to 400,
; then posts the running speed in SRAM[0]

; branch to here if cpu clock > 199

ffff0d30:	a94053f3 	ldp	x19, x20, [sp]
ffff0d34:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff0d38:	910083ff 	add	sp, sp, #0x20
ffff0d3c:	d65f03c0 	ret

; subroutine, referenced only in the 32 bit constants
ffff0d40:	d100c3ff 	sub	sp, sp, #0x30
ffff0d44:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff0d48:	910083fd 	add	x29, sp, #0x20
ffff0d4c:	a90157f4 	stp	x20, x21, [sp, #16]
ffff0d50:	f90007f3 	str	x19, [sp, #8]
ffff0d54:	90000020 	adrp	x0, 0xffff4000
ffff0d58:	b94ff800 	ldr	w0, [x0, #0xff8]
ffff0d5c:	90000021 	adrp	x1, 0xffff4000
ffff0d60:	b94ffc21 	ldr	w1, [x1, #0xffc]
ffff0d64:	b9000020 	str	w0, [x1]
ffff0d68:	b0000020 	adrp	x0, 0xffff5000
ffff0d6c:	b9400000 	ldr	w0, [x0]
ffff0d70:	52800054 	mov	w20, #0x2                   	// #2
ffff0d74:	b9000014 	str	w20, [x0]
ffff0d78:	d2bfe3a0 	mov	x0, #0xff1d0000            	// #4280090624
ffff0d7c:	52849821 	mov	w1, #0x24c1                	// #9409
ffff0d80:	b0000022 	adrp	x2, 0xffff5000
ffff0d84:	b9400442 	ldr	w2, [x2, #4]
ffff0d88:	b0000023 	adrp	x3, 0xffff5000
ffff0d8c:	b9400863 	ldr	w3, [x3, #8]
ffff0d90:	b0000024 	adrp	x4, 0xffff5000
ffff0d94:	b9400c84 	ldr	w4, [x4, #12]
ffff0d98:	b0000025 	adrp	x5, 0xffff5000
ffff0d9c:	b94010a5 	ldr	w5, [x5, #16]
ffff0da0:	b9000001 	str	w1, [x0]
ffff0da4:	b9000062 	str	w2, [x3]
ffff0da8:	b90000a4 	str	w4, [x5]
ffff0dac:	52800033 	mov	w19, #0x1                   	// #1
ffff0db0:	52800020 	mov	w0, #0x1                   	// #1
ffff0db4:	97ffff1f 	bl	0xffff0a30		; xxdelay(1)
ffff0db8:	90ffc695 	adrp	x21, 0xff8c0000
ffff0dbc:	b9002ab4 	str	w20, [x21, #0x28]
ffff0dc0:	528013e0 	mov	w0, #0x9f                  	// #159
ffff0dc4:	b90007e0 	str	w0, [sp, #4]
ffff0dc8:	910013e0 	add	x0, sp, #0x4
ffff0dcc:	910007f4 	add	x20, sp, #0x1
ffff0dd0:	52800021 	mov	w1, #0x1                   	// #1
ffff0dd4:	52800063 	mov	w3, #0x3                   	// #3
ffff0dd8:	aa1403e2 	mov	x2, x20
ffff0ddc:	94000048 	bl	0xffff0efc
ffff0de0:	35000220 	cbnz	w0, 0xffff0e24
ffff0de4:	39400a80 	ldrb	w0, [x20, #2]
ffff0de8:	35000080 	cbnz	w0, 0xffff0df8
ffff0dec:	39400680 	ldrb	w0, [x20, #1]
ffff0df0:	350000e0 	cbnz	w0, 0xffff0e0c
ffff0df4:	1400000c 	b	0xffff0e24
ffff0df8:	7103fc1f 	cmp	w0, #0xff
ffff0dfc:	54000081 	b.ne	0xffff0e0c  // b.any
ffff0e00:	39400680 	ldrb	w0, [x20, #1]
ffff0e04:	7103fc1f 	cmp	w0, #0xff
ffff0e08:	540000e0 	b.eq	0xffff0e24  // b.none
ffff0e0c:	394007e0 	ldrb	w0, [sp, #1]
ffff0e10:	2a1f03f3 	mov	w19, wzr
ffff0e14:	7103fc1f 	cmp	w0, #0xff
ffff0e18:	1a9f17e0 	cset	w0, eq  // eq = none
ffff0e1c:	12000000 	and	w0, w0, #0x1
ffff0e20:	b9002aa0 	str	w0, [x21, #0x28]
ffff0e24:	aa1303e0 	mov	x0, x19
ffff0e28:	f94007f3 	ldr	x19, [sp, #8]
ffff0e2c:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff0e30:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff0e34:	9100c3ff 	add	sp, sp, #0x30
ffff0e38:	d65f03c0 	ret

; another subroutine, referenced only in the 32 bit constants
ffff0e3c:	d10103ff 	sub	sp, sp, #0x40
ffff0e40:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff0e44:	9100c3fd 	add	x29, sp, #0x30
ffff0e48:	a90257f4 	stp	x20, x21, [sp, #32]
ffff0e4c:	f9000ff3 	str	x19, [sp, #24]
ffff0e50:	90ffc695 	adrp	x21, 0xff8c0000
ffff0e54:	b9402aa0 	ldr	w0, [x21, #0x28]
ffff0e58:	52800033 	mov	w19, #0x1                   	// #1
ffff0e5c:	7100081f 	cmp	w0, #0x2
ffff0e60:	54000423 	b.cc	0xffff0ee4  // b.lo, b.ul, b.last
ffff0e64:	52801fe0 	mov	w0, #0xff                  	// #255
ffff0e68:	b90013e0 	str	w0, [sp, #16]
ffff0e6c:	52800033 	mov	w19, #0x1                   	// #1
ffff0e70:	910043e0 	add	x0, sp, #0x10
ffff0e74:	52800021 	mov	w1, #0x1                   	// #1
ffff0e78:	aa1f03e2 	mov	x2, xzr
ffff0e7c:	aa1f03e3 	mov	x3, xzr
ffff0e80:	9400001f 	bl	0xffff0efc
ffff0e84:	5280fa00 	mov	w0, #0x7d0                 	// #2000
ffff0e88:	97fffeea 	bl	0xffff0a30		; xxdelay(2000)
ffff0e8c:	528013e0 	mov	w0, #0x9f                  	// #159
ffff0e90:	b90017e0 	str	w0, [sp, #20]
ffff0e94:	910053e0 	add	x0, sp, #0x14
ffff0e98:	910037f4 	add	x20, sp, #0xd
ffff0e9c:	52800021 	mov	w1, #0x1                   	// #1
ffff0ea0:	52800063 	mov	w3, #0x3                   	// #3
ffff0ea4:	aa1403e2 	mov	x2, x20
ffff0ea8:	94000015 	bl	0xffff0efc
ffff0eac:	350001c0 	cbnz	w0, 0xffff0ee4
ffff0eb0:	39400a80 	ldrb	w0, [x20, #2]
ffff0eb4:	35000080 	cbnz	w0, 0xffff0ec4
ffff0eb8:	39400680 	ldrb	w0, [x20, #1]
ffff0ebc:	350000e0 	cbnz	w0, 0xffff0ed8
ffff0ec0:	14000009 	b	0xffff0ee4
ffff0ec4:	7103fc1f 	cmp	w0, #0xff
ffff0ec8:	54000081 	b.ne	0xffff0ed8  // b.any
ffff0ecc:	39400680 	ldrb	w0, [x20, #1]
ffff0ed0:	7103fc1f 	cmp	w0, #0xff
ffff0ed4:	54000080 	b.eq	0xffff0ee4  // b.none
ffff0ed8:	2a1f03f3 	mov	w19, wzr
ffff0edc:	52800020 	mov	w0, #0x1                   	// #1
ffff0ee0:	b9002aa0 	str	w0, [x21, #0x28]
ffff0ee4:	aa1303e0 	mov	x0, x19
ffff0ee8:	f9400ff3 	ldr	x19, [sp, #24]
ffff0eec:	a94257f4 	ldp	x20, x21, [sp, #32]
ffff0ef0:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff0ef4:	910103ff 	add	sp, sp, #0x40
ffff0ef8:	d65f03c0 	ret

; subroutine, several references
ffff0efc:	d10183ff 	sub	sp, sp, #0x60
ffff0f00:	a9057bfd 	stp	x29, x30, [sp, #80]
ffff0f04:	910143fd 	add	x29, sp, #0x50
ffff0f08:	a90473fb 	stp	x27, x28, [sp, #64]
ffff0f0c:	a9036bf9 	stp	x25, x26, [sp, #48]
ffff0f10:	a90263f7 	stp	x23, x24, [sp, #32]
ffff0f14:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff0f18:	a90053f3 	stp	x19, x20, [sp]
ffff0f1c:	aa0303f3 	mov	x19, x3
ffff0f20:	aa0203f4 	mov	x20, x2
ffff0f24:	aa0103f6 	mov	x22, x1
ffff0f28:	aa0003f5 	mov	x21, x0
ffff0f2c:	b0000020 	adrp	x0, 0xffff5000
ffff0f30:	b9401418 	ldr	w24, [x0, #20]
ffff0f34:	b0000020 	adrp	x0, 0xffff5000
ffff0f38:	b9401819 	ldr	w25, [x0, #24]
ffff0f3c:	52800020 	mov	w0, #0x1                   	// #1
ffff0f40:	b9000300 	str	w0, [x24]
ffff0f44:	b9000320 	str	w0, [x25]
ffff0f48:	52801ffa 	mov	w26, #0xff                  	// #255
ffff0f4c:	2a1303fb 	mov	w27, w19
ffff0f50:	35000116 	cbnz	w22, 0xffff0f70
ffff0f54:	340004bb 	cbz	w27, 0xffff0fe8
ffff0f58:	b0000020 	adrp	x0, 0xffff5000
ffff0f5c:	b9401c00 	ldr	w0, [x0, #28]
ffff0f60:	2a1f03f6 	mov	w22, wzr
ffff0f64:	b900001a 	str	w26, [x0]
ffff0f68:	5100077b 	sub	w27, w27, #0x1
ffff0f6c:	14000007 	b	0xffff0f88
ffff0f70:	b94002a0 	ldr	w0, [x21]
ffff0f74:	b0000021 	adrp	x1, 0xffff5000
ffff0f78:	b9401c21 	ldr	w1, [x1, #28]
ffff0f7c:	b9000020 	str	w0, [x1]
ffff0f80:	510006d6 	sub	w22, w22, #0x1
ffff0f84:	910012b5 	add	x21, x21, #0x4
ffff0f88:	2a1f03fc 	mov	w28, wzr
ffff0f8c:	b0000020 	adrp	x0, 0xffff5000
ffff0f90:	b9402000 	ldr	w0, [x0, #32]
ffff0f94:	b9400000 	ldr	w0, [x0]
ffff0f98:	36180100 	tbz	w0, #3, 0xffff0fb8
ffff0f9c:	52800037 	mov	w23, #0x1                   	// #1
ffff0fa0:	52800020 	mov	w0, #0x1                   	// #1
ffff0fa4:	97fffea3 	bl	0xffff0a30		; xxdelay(1)
ffff0fa8:	1100079c 	add	w28, w28, #0x1
ffff0fac:	71000b9f 	cmp	w28, #0x2
ffff0fb0:	54fffee3 	b.cc	0xffff0f8c  // b.lo, b.ul, b.last
ffff0fb4:	1400000e 	b	0xffff0fec
ffff0fb8:	b0000020 	adrp	x0, 0xffff5000
ffff0fbc:	b9402400 	ldr	w0, [x0, #0x24]
ffff0fc0:	b9400000 	ldr	w0, [x0]
ffff0fc4:	6b33437f 	cmp	w27, w19, uxtw
ffff0fc8:	54000082 	b.cs	0xffff0fd8  // b.hs, b.nlast
ffff0fcc:	91000681 	add	x1, x20, #0x1
ffff0fd0:	39000280 	strb	w0, [x20]
ffff0fd4:	aa0103f4 	mov	x20, x1
ffff0fd8:	52800037 	mov	w23, #0x1                   	// #1
ffff0fdc:	71000b9f 	cmp	w28, #0x2
ffff0fe0:	54fffb83 	b.cc	0xffff0f50  // b.lo, b.ul, b.last
ffff0fe4:	14000002 	b	0xffff0fec
ffff0fe8:	2a1f03f7 	mov	w23, wzr
ffff0fec:	b900033f 	str	wzr, [x25]
ffff0ff0:	b900031f 	str	wzr, [x24]
ffff0ff4:	52801040 	mov	w0, #0x82                  	// #130
ffff0ff8:	97fffe8e 	bl	0xffff0a30		; xxdelay(130)
ffff0ffc:	aa1703e0 	mov	x0, x23
ffff1000:	a94053f3 	ldp	x19, x20, [sp]
ffff1004:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff1008:	a94263f7 	ldp	x23, x24, [sp, #32]
ffff100c:	a9436bf9 	ldp	x25, x26, [sp, #48]
ffff1010:	a94473fb 	ldp	x27, x28, [sp, #64]
ffff1014:	a9457bfd 	ldp	x29, x30, [sp, #80]
ffff1018:	910183ff 	add	sp, sp, #0x60
ffff101c:	d65f03c0 	ret

ffff1020:	d10203ff 	sub	sp, sp, #0x80
ffff1024:	a9077bfd 	stp	x29, x30, [sp, #112]
ffff1028:	9101c3fd 	add	x29, sp, #0x70
ffff102c:	a9066bf9 	stp	x25, x26, [sp, #96]
ffff1030:	a90563f7 	stp	x23, x24, [sp, #80]
ffff1034:	a9045bf5 	stp	x21, x22, [sp, #64]
ffff1038:	a90353f3 	stp	x19, x20, [sp, #48]
ffff103c:	f0ffc679 	adrp	x25, 0xff8c0000
ffff1040:	b9402b23 	ldr	w3, [x25, #0x28]
ffff1044:	aa0203f3 	mov	x19, x2
ffff1048:	aa0103f4 	mov	x20, x1
ffff104c:	aa0003f5 	mov	x21, x0
ffff1050:	52800036 	mov	w22, #0x1                   	// #1
ffff1054:	7100047f 	cmp	w3, #0x1
ffff1058:	54000868 	b.hi	0xffff1164  // b.pmore
ffff105c:	340004c3 	cbz	w3, 0xffff10f4
ffff1060:	52800260 	mov	w0, #0x13                  	// #19
ffff1064:	b90013e0 	str	w0, [sp, #16]
ffff1068:	531256a0 	ubfx	w0, w21, #18, #4
ffff106c:	910043f8 	add	x24, sp, #0x10
ffff1070:	b9000700 	str	w0, [x24, #4]
ffff1074:	530a46a0 	ubfx	w0, w21, #10, #8
ffff1078:	b9000b00 	str	w0, [x24, #8]
ffff107c:	530226a0 	ubfx	w0, w21, #2, #8
ffff1080:	b9000f00 	str	w0, [x24, #12]
ffff1084:	52800081 	mov	w1, #0x4                   	// #4
ffff1088:	aa1803e0 	mov	x0, x24
ffff108c:	aa1f03e2 	mov	x2, xzr
ffff1090:	aa1f03e3 	mov	x3, xzr
ffff1094:	97ffff9a 	bl	0xffff0efc
ffff1098:	35000660 	cbnz	w0, 0xffff1164
ffff109c:	2a1f03fa 	mov	w26, wzr
ffff10a0:	91002317 	add	x23, x24, #0x8
ffff10a4:	d2801800 	mov	x0, #0xc0                  	// #192
ffff10a8:	b9000700 	str	w0, [x24, #4]
ffff10ac:	d28001e0 	mov	x0, #0xf                   	// #15
ffff10b0:	b90013e0 	str	w0, [sp, #16]
ffff10b4:	52800036 	mov	w22, #0x1                   	// #1
ffff10b8:	910043f8 	add	x24, sp, #0x10
ffff10bc:	91003fe2 	add	x2, sp, #0xf
ffff10c0:	52800041 	mov	w1, #0x2                   	// #2
ffff10c4:	52800023 	mov	w3, #0x1                   	// #1
ffff10c8:	aa1803e0 	mov	x0, x24
ffff10cc:	97ffff8c 	bl	0xffff0efc
ffff10d0:	350004a0 	cbnz	w0, 0xffff1164
ffff10d4:	39403fe0 	ldrb	w0, [sp, #15]
ffff10d8:	36000240 	tbz	w0, #0, 0xffff1120
ffff10dc:	1100075a 	add	w26, w26, #0x1
ffff10e0:	71004f5f 	cmp	w26, #0x13
ffff10e4:	54fffe89 	b.ls	0xffff10b4  // b.plast
ffff10e8:	52800040 	mov	w0, #0x2                   	// #2
ffff10ec:	b9002b20 	str	w0, [x25, #0x28]
ffff10f0:	1400001d 	b	0xffff1164
ffff10f4:	52800060 	mov	w0, #0x3                   	// #3
ffff10f8:	b90013e0 	str	w0, [sp, #16]
ffff10fc:	530636a1 	ubfx	w1, w21, #6, #8
ffff1100:	910043e0 	add	x0, sp, #0x10
ffff1104:	b9000401 	str	w1, [x0, #4]
ffff1108:	52801f81 	mov	w1, #0xfc                  	// #252
ffff110c:	0a150821 	and	w1, w1, w21, lsl #2
ffff1110:	b9000801 	str	w1, [x0, #8]
ffff1114:	b9000c1f 	str	wzr, [x0, #12]
ffff1118:	52800081 	mov	w1, #0x4                   	// #4
ffff111c:	1400000e 	b	0xffff1154
ffff1120:	52800076 	mov	w22, #0x3                   	// #3
ffff1124:	b90013f6 	str	w22, [sp, #16]
ffff1128:	52800180 	mov	w0, #0xc                   	// #12
ffff112c:	0a150800 	and	w0, w0, w21, lsl #2
ffff1130:	b9000700 	str	w0, [x24, #4]
ffff1134:	d2800302 	mov	x2, #0x18                  	// #24
ffff1138:	aa1703e0 	mov	x0, x23
ffff113c:	aa1f03e1 	mov	x1, xzr
ffff1140:	94000ccf 	bl	0xffff447c		; memset
ffff1144:	f0ffc660 	adrp	x0, 0xff8c0000
ffff1148:	b9402c00 	ldr	w0, [x0, #0x2c]
ffff114c:	0b400ec1 	add	w1, w22, w0, lsr #3
ffff1150:	aa1803e0 	mov	x0, x24
ffff1154:	aa1403e2 	mov	x2, x20
ffff1158:	aa1303e3 	mov	x3, x19
ffff115c:	97ffff68 	bl	0xffff0efc
ffff1160:	aa0003f6 	mov	x22, x0
ffff1164:	aa1603e0 	mov	x0, x22
ffff1168:	a94353f3 	ldp	x19, x20, [sp, #48]
ffff116c:	a9445bf5 	ldp	x21, x22, [sp, #64]
ffff1170:	a94563f7 	ldp	x23, x24, [sp, #80]
ffff1174:	a9466bf9 	ldp	x25, x26, [sp, #96]
ffff1178:	a9477bfd 	ldp	x29, x30, [sp, #112]
ffff117c:	910203ff 	add	sp, sp, #0x80
ffff1180:	d65f03c0 	ret
ffff1184:	d100c3ff 	sub	sp, sp, #0x30
ffff1188:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff118c:	910083fd 	add	x29, sp, #0x20
ffff1190:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff1194:	a90053f3 	stp	x19, x20, [sp]
ffff1198:	aa0103f3 	mov	x19, x1
ffff119c:	aa0003f4 	mov	x20, x0
ffff11a0:	53097c55 	lsr	w21, w2, #9
ffff11a4:	52800020 	mov	w0, #0x1                   	// #1
ffff11a8:	34000195 	cbz	w21, 0xffff11d8
ffff11ac:	2a1f03f6 	mov	w22, wzr
ffff11b0:	0b364280 	add	w0, w20, w22, uxtw
ffff11b4:	52810002 	mov	w2, #0x800                 	// #2048
ffff11b8:	aa1303e1 	mov	x1, x19
ffff11bc:	97ffff99 	bl	0xffff1020
ffff11c0:	350000c0 	cbnz	w0, 0xffff11d8
ffff11c4:	91200273 	add	x19, x19, #0x800
ffff11c8:	110012d6 	add	w22, w22, #0x4
ffff11cc:	6b3542df 	cmp	w22, w21, uxtw
ffff11d0:	54ffff03 	b.cc	0xffff11b0  // b.lo, b.ul, b.last
ffff11d4:	2a1f03e0 	mov	w0, wzr
ffff11d8:	a94053f3 	ldp	x19, x20, [sp]
ffff11dc:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff11e0:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff11e4:	9100c3ff 	add	sp, sp, #0x30
ffff11e8:	d65f03c0 	ret
ffff11ec:	d10103ff 	sub	sp, sp, #0x40
ffff11f0:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff11f4:	9100c3fd 	add	x29, sp, #0x30
ffff11f8:	a9025ff6 	stp	x22, x23, [sp, #32]
ffff11fc:	a90157f4 	stp	x20, x21, [sp, #16]
ffff1200:	f90007f3 	str	x19, [sp, #8]
ffff1204:	aa0203f4 	mov	x20, x2
ffff1208:	aa0103f6 	mov	x22, x1
ffff120c:	f0ffc677 	adrp	x23, 0xff8c0000
ffff1210:	b9002eff 	str	wzr, [x23, #0x2c]
ffff1214:	52800033 	mov	w19, #0x1                   	// #1
ffff1218:	1ac02260 	lsl	w0, w19, w0
ffff121c:	128000e1 	mov	w1, #0xfffffff8            	// #-8
ffff1220:	0a000835 	and	w21, w1, w0, lsl #2
ffff1224:	52800402 	mov	w2, #0x20                  	// #32
ffff1228:	aa1503e0 	mov	x0, x21
ffff122c:	aa1603e1 	mov	x1, x22
ffff1230:	97ffff7c 	bl	0xffff1020
ffff1234:	35000400 	cbnz	w0, 0xffff12b4
ffff1238:	2a1f03e0 	mov	w0, wzr
ffff123c:	2a1f03e1 	mov	w1, wzr
ffff1240:	91000ec2 	add	x2, x22, #0x3
ffff1244:	385fd043 	ldurb	w3, [x2, #-3]
ffff1248:	7100ec7f 	cmp	w3, #0x3b
ffff124c:	54000141 	b.ne	0xffff1274  // b.any
ffff1250:	385fe043 	ldurb	w3, [x2, #-2]
ffff1254:	7102307f 	cmp	w3, #0x8c
ffff1258:	540000e1 	b.ne	0xffff1274  // b.any
ffff125c:	385ff043 	ldurb	w3, [x2, #-1]
ffff1260:	7103707f 	cmp	w3, #0xdc
ffff1264:	54000081 	b.ne	0xffff1274  // b.any
ffff1268:	39400043 	ldrb	w3, [x2]
ffff126c:	7103f07f 	cmp	w3, #0xfc
ffff1270:	540000e0 	b.eq	0xffff128c  // b.none
ffff1274:	11002021 	add	w1, w1, #0x8
ffff1278:	11000400 	add	w0, w0, #0x1
ffff127c:	91000442 	add	x2, x2, #0x1
ffff1280:	7100741f 	cmp	w0, #0x1d
ffff1284:	54fffe03 	b.cc	0xffff1244  // b.lo, b.ul, b.last
ffff1288:	1400000b 	b	0xffff12b4
ffff128c:	b9002ee1 	str	w1, [x23, #0x2c]
ffff1290:	7100701f 	cmp	w0, #0x1c
ffff1294:	54000108 	b.hi	0xffff12b4  // b.pmore
ffff1298:	52804002 	mov	w2, #0x200                 	// #512
ffff129c:	aa1503e0 	mov	x0, x21
ffff12a0:	aa1603e1 	mov	x1, x22
ffff12a4:	97ffff5f 	bl	0xffff1020
ffff12a8:	35000060 	cbnz	w0, 0xffff12b4
ffff12ac:	2a1f03f3 	mov	w19, wzr
ffff12b0:	b9000295 	str	w21, [x20]
ffff12b4:	aa1303e0 	mov	x0, x19
ffff12b8:	f94007f3 	ldr	x19, [sp, #8]
ffff12bc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff12c0:	a9425ff6 	ldp	x22, x23, [sp, #32]
ffff12c4:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff12c8:	910103ff 	add	sp, sp, #0x40
ffff12cc:	d65f03c0 	ret

ffff12d0:	d10083ff 	sub	sp, sp, #0x20
ffff12d4:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff12d8:	910043fd 	add	x29, sp, #0x10
ffff12dc:	a90053f3 	stp	x19, x20, [sp]
ffff12e0:	aa0203f4 	mov	x20, x2
ffff12e4:	aa0103e5 	mov	x5, x1
ffff12e8:	f0ffc661 	adrp	x1, 0xff8c0000
ffff12ec:	7940f421 	ldrh	w1, [x1, #0x7a]
ffff12f0:	52800482 	mov	w2, #0x24                  	// #36
ffff12f4:	6a02003f 	tst	w1, w2
ffff12f8:	52800121 	mov	w1, #0x9                   	// #9
ffff12fc:	90000022 	adrp	x2, 0xffff5000
ffff1300:	b9402842 	ldr	w2, [x2, #0x28]
ffff1304:	90000023 	adrp	x3, 0xffff5000
ffff1308:	b9402c63 	ldr	w3, [x3, #0x2c]
ffff130c:	1a8113e1 	csel	w1, wzr, w1, ne  // ne = any
ffff1310:	1ac12001 	lsl	w1, w0, w1
ffff1314:	7108029f 	cmp	w20, #0x200
ffff1318:	1a828060 	csel	w0, w3, w2, hi  // hi = pmore
ffff131c:	52804003 	mov	w3, #0x200                 	// #512
ffff1320:	aa1f03e2 	mov	x2, xzr
ffff1324:	aa1403e4 	mov	x4, x20
ffff1328:	94000297 	bl	0xffff1d84
ffff132c:	aa0003f3 	mov	x19, x0
ffff1330:	7108069f 	cmp	w20, #0x201
ffff1334:	540000e3 	b.cc	0xffff1350  // b.lo, b.ul, b.last
ffff1338:	12087a60 	and	w0, w19, #0xff7fffff
ffff133c:	350000a0 	cbnz	w0, 0xffff1350
ffff1340:	52819b60 	mov	w0, #0xcdb                 	// #3291
ffff1344:	aa1f03e1 	mov	x1, xzr
ffff1348:	aa1f03e2 	mov	x2, xzr
ffff134c:	9400039a 	bl	0xffff21b4
ffff1350:	7100027f 	cmp	w19, #0x0
ffff1354:	1a9f07e0 	cset	w0, ne  // ne = any
ffff1358:	92400000 	and	x0, x0, #0x1
ffff135c:	a94053f3 	ldp	x19, x20, [sp]
ffff1360:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff1364:	910083ff 	add	sp, sp, #0x20
ffff1368:	d65f03c0 	ret

ffff136c:	d10083ff 	sub	sp, sp, #0x20
ffff1370:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff1374:	910043fd 	add	x29, sp, #0x10
ffff1378:	a90053f3 	stp	x19, x20, [sp]
ffff137c:	aa0203f3 	mov	x19, x2
ffff1380:	aa0103e5 	mov	x5, x1
ffff1384:	52800801 	mov	w1, #0x40                  	// #64
ffff1388:	2a002834 	orr	w20, w1, w0, lsl #10
ffff138c:	f0ffc660 	adrp	x0, 0xff8c0000
ffff1390:	7940f400 	ldrh	w0, [x0, #0x7a]
ffff1394:	52800481 	mov	w1, #0x24                  	// #36
ffff1398:	6a01001f 	tst	w0, w1
ffff139c:	90000020 	adrp	x0, 0xffff5000
ffff13a0:	b9403000 	ldr	w0, [x0, #0x30]
ffff13a4:	52800121 	mov	w1, #0x9                   	// #9
ffff13a8:	1a8113e1 	csel	w1, wzr, w1, ne  // ne = any
ffff13ac:	1ac12281 	lsl	w1, w20, w1
ffff13b0:	52804003 	mov	w3, #0x200                 	// #512
ffff13b4:	52804004 	mov	w4, #0x200                 	// #512
ffff13b8:	aa1f03e2 	mov	x2, xzr
ffff13bc:	94000272 	bl	0xffff1d84
ffff13c0:	aa0003e1 	mov	x1, x0
ffff13c4:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff13c8:	35000061 	cbnz	w1, 0xffff13d4
ffff13cc:	2a1f03e0 	mov	w0, wzr
ffff13d0:	b9000274 	str	w20, [x19]
ffff13d4:	a94053f3 	ldp	x19, x20, [sp]
ffff13d8:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff13dc:	910083ff 	add	sp, sp, #0x20
ffff13e0:	d65f03c0 	ret

ffff13e4:	d10103ff 	sub	sp, sp, #0x40
ffff13e8:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff13ec:	9100c3fd 	add	x29, sp, #0x30
ffff13f0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffff13f4:	a90153f3 	stp	x19, x20, [sp, #16]
ffff13f8:	94000373 	bl	0xffff21c4
ffff13fc:	b9000bff 	str	wzr, [sp, #8]
ffff1400:	f0ffc674 	adrp	x20, 0xff8c0000
ffff1404:	7900f29f 	strh	wzr, [x20, #0x78]
ffff1408:	f0ffc673 	adrp	x19, 0xff8c0000
ffff140c:	7900f67f 	strh	wzr, [x19, #0x7a]
ffff1410:	aa1f03e0 	mov	x0, xzr
ffff1414:	aa1f03e1 	mov	x1, xzr
ffff1418:	aa1f03e2 	mov	x2, xzr
ffff141c:	94000366 	bl	0xffff21b4
ffff1420:	350009e0 	cbnz	w0, 0xffff155c
ffff1424:	52800c80 	mov	w0, #0x64                  	// #100
ffff1428:	97fffd82 	bl	0xffff0a30		; xxdelay(100)
ffff142c:	2a1f03f6 	mov	w22, wzr
ffff1430:	90000020 	adrp	x0, 0xffff5000
ffff1434:	b9403401 	ldr	w1, [x0, #0x34]
ffff1438:	910023e2 	add	x2, sp, #0x8
ffff143c:	52802040 	mov	w0, #0x102                 	// #258
ffff1440:	9400035d 	bl	0xffff21b4
ffff1444:	aa0003e1 	mov	x1, x0
ffff1448:	52800020 	mov	w0, #0x1                   	// #1
ffff144c:	35000881 	cbnz	w1, 0xffff155c
ffff1450:	b9400be1 	ldr	w1, [sp, #8]
ffff1454:	3100043f 	cmn	w1, #0x1
ffff1458:	540000ed 	b.le	0xffff1474
ffff145c:	110006d6 	add	w22, w22, #0x1
ffff1460:	53067ec0 	lsr	w0, w22, #6
ffff1464:	7101f01f 	cmp	w0, #0x7c
ffff1468:	54fffe49 	b.ls	0xffff1430  // b.plast
ffff146c:	2a1f03f5 	mov	w21, wzr
ffff1470:	1400000c 	b	0xffff14a0
ffff1474:	90000022 	adrp	x2, 0xffff5000
ffff1478:	b9403842 	ldr	w2, [x2, #0x38]
ffff147c:	12187821 	and	w1, w1, #0xffffff7f
ffff1480:	52800815 	mov	w21, #0x40                  	// #64
ffff1484:	6b22403f 	cmp	w1, w2, uxtw
ffff1488:	540000c0 	b.eq	0xffff14a0  // b.none
ffff148c:	90000022 	adrp	x2, 0xffff5000
ffff1490:	b9403c42 	ldr	w2, [x2, #0x3c]
ffff1494:	52800415 	mov	w21, #0x20                  	// #32
ffff1498:	6b22403f 	cmp	w1, w2, uxtw
ffff149c:	54000601 	b.ne	0xffff155c  // b.any
ffff14a0:	52840000 	mov	w0, #0x2000                	// #8192
ffff14a4:	5283e801 	mov	w1, #0x1f40                	// #8000
ffff14a8:	6b2142df 	cmp	w22, w1, uxtw
ffff14ac:	54000580 	b.eq	0xffff155c  // b.none
ffff14b0:	52804120 	mov	w0, #0x209                 	// #521
ffff14b4:	aa1f03e1 	mov	x1, xzr
ffff14b8:	aa1f03e2 	mov	x2, xzr
ffff14bc:	9400033e 	bl	0xffff21b4
ffff14c0:	350004e0 	cbnz	w0, 0xffff155c
ffff14c4:	52800040 	mov	w0, #0x2                   	// #2
ffff14c8:	7900f280 	strh	w0, [x20, #0x78]
ffff14cc:	52806340 	mov	w0, #0x31a                 	// #794
ffff14d0:	52a00041 	mov	w1, #0x20000               	// #131072
ffff14d4:	aa1f03e2 	mov	x2, xzr
ffff14d8:	94000337 	bl	0xffff21b4
ffff14dc:	35000400 	cbnz	w0, 0xffff155c
ffff14e0:	94000208 	bl	0xffff1d00
ffff14e4:	350003c0 	cbnz	w0, 0xffff155c
ffff14e8:	7940f280 	ldrh	w0, [x20, #0x78]
ffff14ec:	53103c01 	lsl	w1, w0, #16
ffff14f0:	910023e2 	add	x2, sp, #0x8
ffff14f4:	5280e360 	mov	w0, #0x71b                 	// #1819
ffff14f8:	9400032f 	bl	0xffff21b4
ffff14fc:	35000300 	cbnz	w0, 0xffff155c
ffff1500:	910023e2 	add	x2, sp, #0x8
ffff1504:	52820340 	mov	w0, #0x101a                	// #4122
ffff1508:	52804001 	mov	w1, #0x200                 	// #512
ffff150c:	9400032a 	bl	0xffff21b4
ffff1510:	35000260 	cbnz	w0, 0xffff155c
ffff1514:	b9000fff 	str	wzr, [sp, #12]
ffff1518:	52800100 	mov	w0, #0x8                   	// #8
ffff151c:	940001e5 	bl	0xffff1cb0
ffff1520:	90000020 	adrp	x0, 0xffff5000
ffff1524:	b9404001 	ldr	w1, [x0, #0x40]
ffff1528:	910033e2 	add	x2, sp, #0xc
ffff152c:	5280c360 	mov	w0, #0x61b                 	// #1563
ffff1530:	94000321 	bl	0xffff21b4
ffff1534:	35000100 	cbnz	w0, 0xffff1554
ffff1538:	394033e0 	ldrb	w0, [sp, #12]
ffff153c:	373800c0 	tbnz	w0, #7, 0xffff1554
ffff1540:	7940f280 	ldrh	w0, [x20, #0x78]
ffff1544:	53103c01 	lsl	w1, w0, #16
ffff1548:	910033e2 	add	x2, sp, #0xc
ffff154c:	5281a340 	mov	w0, #0xd1a                 	// #3354
ffff1550:	94000319 	bl	0xffff21b4
ffff1554:	2a1f03e0 	mov	w0, wzr
ffff1558:	7900f675 	strh	w21, [x19, #0x7a]
ffff155c:	7100001f 	cmp	w0, #0x0
ffff1560:	1a9f07e0 	cset	w0, ne  // ne = any
ffff1564:	92400000 	and	x0, x0, #0x1
ffff1568:	a94153f3 	ldp	x19, x20, [sp, #16]
ffff156c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffff1570:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff1574:	910103ff 	add	sp, sp, #0x40
ffff1578:	d65f03c0 	ret

ffff157c:	d10103ff 	sub	sp, sp, #0x40
ffff1580:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff1584:	9100c3fd 	add	x29, sp, #0x30
ffff1588:	a9025bf5 	stp	x21, x22, [sp, #32]
ffff158c:	a90153f3 	stp	x19, x20, [sp, #16]
ffff1590:	aa0103f4 	mov	x20, x1
ffff1594:	aa0003f3 	mov	x19, x0
ffff1598:	2a1f03f6 	mov	w22, wzr
ffff159c:	90000020 	adrp	x0, 0xffff5000
ffff15a0:	b9404400 	ldr	w0, [x0, #0x44]
ffff15a4:	7100069f 	cmp	w20, #0x1
ffff15a8:	321123e1 	mov	w1, #0xff8000              	// #16744448
ffff15ac:	1a810015 	csel	w21, w0, w1, eq  // eq = none
ffff15b0:	b9000fff 	str	wzr, [sp, #12]
ffff15b4:	910033e3 	add	x3, sp, #0xc
ffff15b8:	52840d21 	mov	w1, #0x2069                	// #8297
ffff15bc:	aa1303e0 	mov	x0, x19
ffff15c0:	aa1503e2 	mov	x2, x21
ffff15c4:	94000059 	bl	0xffff1728
ffff15c8:	aa0003e1 	mov	x1, x0
ffff15cc:	52800020 	mov	w0, #0x1                   	// #1
ffff15d0:	35000a21 	cbnz	w1, 0xffff1714
ffff15d4:	b9400fe0 	ldr	w0, [sp, #12]
ffff15d8:	3100041f 	cmn	w0, #0x1
ffff15dc:	540000cd 	b.le	0xffff15f4
ffff15e0:	110006d6 	add	w22, w22, #0x1
ffff15e4:	711fdedf 	cmp	w22, #0x7f7
ffff15e8:	54fffe69 	b.ls	0xffff15b4  // b.plast
ffff15ec:	2a1f03f5 	mov	w21, wzr
ffff15f0:	1400000f 	b	0xffff162c
ffff15f4:	52800215 	mov	w21, #0x10                  	// #16
ffff15f8:	7100069f 	cmp	w20, #0x1
ffff15fc:	54000181 	b.ne	0xffff162c  // b.any
ffff1600:	90000021 	adrp	x1, 0xffff5000
ffff1604:	b9404821 	ldr	w1, [x1, #0x48]
ffff1608:	12187800 	and	w0, w0, #0xffffff7f
ffff160c:	52800095 	mov	w21, #0x4                   	// #4
ffff1610:	6b21401f 	cmp	w0, w1, uxtw
ffff1614:	540000c0 	b.eq	0xffff162c  // b.none
ffff1618:	90000021 	adrp	x1, 0xffff5000
ffff161c:	b9404c21 	ldr	w1, [x1, #0x4c]
ffff1620:	6b21401f 	cmp	w0, w1, uxtw
ffff1624:	52800100 	mov	w0, #0x8                   	// #8
ffff1628:	1a9f0015 	csel	w21, w0, wzr, eq  // eq = none
ffff162c:	52840000 	mov	w0, #0x2000                	// #8192
ffff1630:	711fe2df 	cmp	w22, #0x7f8
ffff1634:	54000700 	b.eq	0xffff1714  // b.none
ffff1638:	52843841 	mov	w1, #0x21c2                	// #8642
ffff163c:	aa1303e0 	mov	x0, x19
ffff1640:	aa1f03e2 	mov	x2, xzr
ffff1644:	aa1f03e3 	mov	x3, xzr
ffff1648:	94000145 	bl	0xffff1b5c
ffff164c:	35000640 	cbnz	w0, 0xffff1714
ffff1650:	910033f4 	add	x20, sp, #0xc
ffff1654:	52842861 	mov	w1, #0x2143                	// #8515
ffff1658:	aa1303e0 	mov	x0, x19
ffff165c:	aa1f03e2 	mov	x2, xzr
ffff1660:	aa1403e3 	mov	x3, x20
ffff1664:	9400013e 	bl	0xffff1b5c
ffff1668:	35000560 	cbnz	w0, 0xffff1714
ffff166c:	79400680 	ldrh	w0, [x20, #2]
ffff1670:	f0ffc674 	adrp	x20, 0xff8c0000
ffff1674:	7902fa80 	strh	w0, [x20, #0x17c]
ffff1678:	aa1303e0 	mov	x0, x19
ffff167c:	94000057 	bl	0xffff17d8
ffff1680:	350004a0 	cbnz	w0, 0xffff1714
ffff1684:	7942fa80 	ldrh	w0, [x20, #0x17c]
ffff1688:	90000021 	adrp	x1, 0xffff5000
ffff168c:	b9405021 	ldr	w1, [x1, #0x50]
ffff1690:	53103c02 	lsl	w2, w0, #16
ffff1694:	aa1303e0 	mov	x0, x19
ffff1698:	aa1f03e3 	mov	x3, xzr
ffff169c:	94000130 	bl	0xffff1b5c
ffff16a0:	350003a0 	cbnz	w0, 0xffff1714
ffff16a4:	52842a01 	mov	w1, #0x2150                	// #8528
ffff16a8:	52804002 	mov	w2, #0x200                 	// #512
ffff16ac:	aa1303e0 	mov	x0, x19
ffff16b0:	aa1f03e3 	mov	x3, xzr
ffff16b4:	9400012a 	bl	0xffff1b5c
ffff16b8:	350002e0 	cbnz	w0, 0xffff1714
ffff16bc:	52842d41 	mov	w1, #0x216a                	// #8554
ffff16c0:	aa1303e0 	mov	x0, x19
ffff16c4:	aa1f03e2 	mov	x2, xzr
ffff16c8:	aa1f03e3 	mov	x3, xzr
ffff16cc:	94000017 	bl	0xffff1728		; below ..
ffff16d0:	35000220 	cbnz	w0, 0xffff1714
ffff16d4:	528428c1 	mov	w1, #0x2146                	// #8518
ffff16d8:	52800042 	mov	w2, #0x2                   	// #2
ffff16dc:	aa1303e0 	mov	x0, x19
ffff16e0:	aa1f03e3 	mov	x3, xzr
ffff16e4:	94000011 	bl	0xffff1728		; below ..
ffff16e8:	35000100 	cbnz	w0, 0xffff1708
ffff16ec:	7100027f 	cmp	w19, #0x0
ffff16f0:	d2bfc660 	mov	x0, #0xfe330000		; eMMC base
ffff16f4:	d2bfc641 	mov	x1, #0xfe320000		; SD MMC base
ffff16f8:	9a800020 	csel	x0, x1, x0, eq
ffff16fc:	b27d0400 	orr	x0, x0, #0x18
ffff1700:	52800021 	mov	w1, #0x1
ffff1704:	b9000001 	str	w1, [x0]		; mmc_18 = 1
ffff1708:	2a1f03e0 	mov	w0, wzr
ffff170c:	f0ffc661 	adrp	x1, 0xff8c0000		; SRAM_BASE
ffff1710:	7902fc35 	strh	w21, [x1, #0x17e]
ffff1714:	a94153f3 	ldp	x19, x20, [sp, #16]
ffff1718:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffff171c:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff1720:	910103ff 	add	sp, sp, #0x40
ffff1724:	d65f03c0 	ret

; subroutine, 3 calls (above)

ffff1728:	d10103ff 	sub	sp, sp, #0x40
ffff172c:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff1730:	9100c3fd 	add	x29, sp, #0x30
ffff1734:	a9025bf5 	stp	x21, x22, [sp, #32]
ffff1738:	a90153f3 	stp	x19, x20, [sp, #16]

ffff173c:	f0ffc664 	adrp	x4, 0xff8c0000		; SRAM
ffff1740:	7942f884 	ldrh	w4, [x4, #0x17c]	; w4 = *(SRAM+0x17c)
ffff1744:	aa0303f3 	mov	x19, x3
ffff1748:	aa0203f4 	mov	x20, x2
ffff174c:	aa0103f5 	mov	x21, x1
ffff1750:	aa0003f6 	mov	x22, x0
ffff1754:	b9000fff 	str	wzr, [sp, #12]		; x = 0
ffff1758:	53103c82 	lsl	w2, w4, #16
ffff175c:	910033e3 	add	x3, sp, #0xc		; &x
ffff1760:	52842ee1 	mov	w1, #0x2177
ffff1764:	940000fe 	bl	0xffff1b5c
ffff1768:	35000140 	cbnz	w0, 0xffff1790
ffff176c:	394033e0 	ldrb	w0, [sp, #12]		; w0 = x
ffff1770:	362800e0 	tbz	w0, #5, 0xffff178c
ffff1774:	aa1603e0 	mov	x0, x22
ffff1778:	aa1503e1 	mov	x1, x21
ffff177c:	aa1403e2 	mov	x2, x20
ffff1780:	aa1303e3 	mov	x3, x19
ffff1784:	940000f6 	bl	0xffff1b5c
ffff1788:	14000002 	b	0xffff1790

ffff178c:	2a1f03e0 	mov	w0, wzr			; return 0
ffff1790:	a94153f3 	ldp	x19, x20, [sp, #16]	; return w0
ffff1794:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffff1798:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff179c:	910103ff 	add	sp, sp, #0x40
ffff17a0:	d65f03c0 	ret

; subroutine, referenced in 32 bit constants

ffff17a4:	d10043ff 	sub	sp, sp, #0x10		; standard prolog
ffff17a8:	a9007bfd 	stp	x29, x30, [sp]
ffff17ac:	910003fd 	mov	x29, sp

ffff17b0:	aa1f03e0 	mov	x0, xzr			; x0 = 0
ffff17b4:	940000ee 	bl	0xffff1b6c
ffff17b8:	aa1f03e0 	mov	x0, xzr			; x0 = 0
ffff17bc:	940002c3 	bl	0xffff22c8
ffff17c0:	7100001f 	cmp	w0, #0x0
ffff17c4:	1a9f07e0 	cset	w0, ne			; any bits set ?
ffff17c8:	92400000 	and	x0, x0, #0x1		; return 1 if so.

ffff17cc:	a9407bfd 	ldp	x29, x30, [sp]
ffff17d0:	910043ff 	add	sp, sp, #0x10
ffff17d4:	d65f03c0 	ret

; subroutine
ffff17d8:	d100c3ff 	sub	sp, sp, #0x30
ffff17dc:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff17e0:	910083fd 	add	x29, sp, #0x20
ffff17e4:	a90157f4 	stp	x20, x21, [sp, #16]
ffff17e8:	f90007f3 	str	x19, [sp, #8]
ffff17ec:	aa0003f5 	mov	x21, x0
ffff17f0:	710002bf 	cmp	w21, #0x0
ffff17f4:	d2bfc660 	mov	x0, #0xfe330000		; eMMC base
ffff17f8:	d2bfc641 	mov	x1, #0xfe320000		; SD MMC base
ffff17fc:	90000022 	adrp	x2, 0xffff5000
ffff1800:	b9405453 	ldr	w19, [x2, #0x54]
ffff1804:	9a800034 	csel	x20, x1, x0, eq  // eq = none
ffff1808:	b27c0280 	orr	x0, x20, #0x10
ffff180c:	b900001f 	str	wzr, [x0]
ffff1810:	aa1403e0 	mov	x0, x20
ffff1814:	aa1303e1 	mov	x1, x19
ffff1818:	94000018 	bl	0xffff1878
ffff181c:	aa0003e1 	mov	x1, x0
ffff1820:	52820000 	mov	w0, #0x1000                	// #4096
ffff1824:	35000201 	cbnz	w1, 0xffff1864
ffff1828:	350000d5 	cbnz	w21, 0xffff1840
ffff182c:	90000020 	adrp	x0, 0xffff5000
ffff1830:	b9405800 	ldr	w0, [x0, #0x58]
ffff1834:	90000021 	adrp	x1, 0xffff5000
ffff1838:	b9405c21 	ldr	w1, [x1, #0x5c]
ffff183c:	b9000020 	str	w0, [x1]
ffff1840:	b9000a9f 	str	wzr, [x20, #8]
ffff1844:	52800020 	mov	w0, #0x1                   	// #1
ffff1848:	b9001280 	str	w0, [x20, #16]
ffff184c:	aa1403e0 	mov	x0, x20
ffff1850:	aa1303e1 	mov	x1, x19
ffff1854:	94000009 	bl	0xffff1878
ffff1858:	7100001f 	cmp	w0, #0x0
ffff185c:	52820000 	mov	w0, #0x1000                	// #4096
ffff1860:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
ffff1864:	f94007f3 	ldr	x19, [sp, #8]
ffff1868:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff186c:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff1870:	9100c3ff 	add	sp, sp, #0x30
ffff1874:	d65f03c0 	ret
ffff1878:	d10083ff 	sub	sp, sp, #0x20
ffff187c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff1880:	910043fd 	add	x29, sp, #0x10
ffff1884:	f90007f3 	str	x19, [sp, #8]
ffff1888:	aa0003f3 	mov	x19, x0
ffff188c:	52807d00 	mov	w0, #0x3e8                 	// #1000
ffff1890:	b90007e0 	str	w0, [sp, #4]
ffff1894:	b9002e61 	str	w1, [x19, #0x2c]
ffff1898:	b9402e60 	ldr	w0, [x19, #0x2c]
ffff189c:	3100041f 	cmn	w0, #0x1
ffff18a0:	5400016c 	b.gt	0xffff18cc
ffff18a4:	b94007e0 	ldr	w0, [sp, #4]
ffff18a8:	51000401 	sub	w1, w0, #0x1
ffff18ac:	b90007e1 	str	w1, [sp, #4]
ffff18b0:	7100041f 	cmp	w0, #0x1
ffff18b4:	540000cb 	b.lt	0xffff18cc  // b.tstop
ffff18b8:	52800020 	mov	w0, #0x1                   	// #1
ffff18bc:	97fffc5d 	bl	0xffff0a30		; xxdelay(1)
ffff18c0:	b9402e60 	ldr	w0, [x19, #0x2c]
ffff18c4:	7100001f 	cmp	w0, #0x0
ffff18c8:	54fffeeb 	b.lt	0xffff18a4  // b.tstop
ffff18cc:	b94007e0 	ldr	w0, [sp, #4]
ffff18d0:	7100001f 	cmp	w0, #0x0
ffff18d4:	52820000 	mov	w0, #0x1000                	// #4096
ffff18d8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
ffff18dc:	f94007f3 	ldr	x19, [sp, #8]
ffff18e0:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff18e4:	910083ff 	add	sp, sp, #0x20
ffff18e8:	d65f03c0 	ret

; subroutine
; Do something with SD or eMMC
; called in 3 places
; arguments:
;
;  w0 is 0 for SD, 1 for MMC
;  w1 (x20) is 0x2351 or 0x2352 or many other things
;  w2 (x25)
;  w3 (x19)
;  w4 (x26)
;  w5 (x23)
;  w6 (x22)

ffff18ec:	d10183ff 	sub	sp, sp, #0x60
ffff18f0:	a9057bfd 	stp	x29, x30, [sp, #80]
ffff18f4:	910143fd 	add	x29, sp, #0x50
ffff18f8:	a9046ffa 	stp	x26, x27, [sp, #64]
ffff18fc:	a90367f8 	stp	x24, x25, [sp, #48]
ffff1900:	a9025ff6 	stp	x22, x23, [sp, #32]
ffff1904:	a90157f4 	stp	x20, x21, [sp, #16]
ffff1908:	f90007f3 	str	x19, [sp, #8]
ffff190c:	aa0603f6 	mov	x22, x6
ffff1910:	aa0503f7 	mov	x23, x5
ffff1914:	aa0403fa 	mov	x26, x4
ffff1918:	aa0303f3 	mov	x19, x3
ffff191c:	aa0203f9 	mov	x25, x2
ffff1920:	aa0103f4 	mov	x20, x1

; The MMC hardware has two groups of registers
; One is based at fe330000, the other at fe330200
; the code here sets up base registers for each zone
; apparently in order to be able to use smaller offsets
; for the second zone, though that shouldn't be strictly 
; necessary.


ffff1924:	7100001f 	cmp	w0, #0x0 		; 0 is SD, 1 is mmc
ffff1928:	90000020 	adrp	x0, 0xffff5000
ffff192c:	b9406000 	ldr	w0, [x0, #0x60]		; ffff5060: fe330200
ffff1930:	90000021 	adrp	x1, 0xffff5000
ffff1934:	b9406421 	ldr	w1, [x1, #0x64]		; ffff5064: fe320200

ffff1938:	d2bfc662 	mov	x2, #0xfe330000		; eMMC base
ffff193c:	d2bfc643 	mov	x3, #0xfe320000		; SD MMC base

ffff1940:	9a820075 	csel	x21, x3, x2, eq		; x21 = mmc base 0000
ffff1944:	9a80003b 	csel	x27, x1, x0, eq		; x27 = mmc base 0200
ffff1948:	36680094 	tbz	w20, #13, 0xffff1958

ffff194c:	b9404aa0 	ldr	w0, [x21, #0x48]	; mmc_48
ffff1950:	52808018 	mov	w24, #0x400
ffff1954:	37480d00 	tbnz	w0, #9, 0xffff1af4

ffff1958:	b9402ea0 	ldr	w0, [x21, #0x2c]	; w0 = mmc_2c
ffff195c:	52820018 	mov	w24, #0x1000
ffff1960:	7100001f 	cmp	w0, #0x0
ffff1964:	54000c8b 	b.lt	0xffff1af4

ffff1968:	aa1503e0 	mov	x0, x21
ffff196c:	9400006b 	bl	0xffff1b18
ffff1970:	36480074 	tbz	w20, #9, 0xffff197c
ffff1974:	b9001eba 	str	w26, [x21, #28]
ffff1978:	b90022b7 	str	w23, [x21, #32]
ffff197c:	b9002ab9 	str	w25, [x21, #0x28]
ffff1980:	12b40020 	mov	w0, #0x5ffeffff            	// #1610547199
ffff1984:	0a000280 	and	w0, w20, w0
ffff1988:	52b40001 	mov	w1, #0xa0000000            	// #-1610612736
ffff198c:	2a010001 	orr	w1, w0, w1
ffff1990:	aa1503e0 	mov	x0, x21
ffff1994:	97ffffb9 	bl	0xffff1878
ffff1998:	35000ae0 	cbnz	w0, 0xffff1af4		; return
ffff199c:	52807d00 	mov	w0, #0x3e8		; w0 = 1000
ffff19a0:	b90007e0 	str	w0, [sp, #4]		; x = 1000
ffff19a4:	14000003 	b	0xffff19b0

; loop, but how do we get here ?
ffff19a8:	52800020 	mov	w0, #0x1
ffff19ac:	97fffc21 	bl	0xffff0a30		; xxdelay(1)
ffff19b0:	b94046a0 	ldr	w0, [x21, #0x44]	; mmc_44
ffff19b4:	371000c0 	tbnz	w0, #2, 0xffff19cc
ffff19b8:	b94007e0 	ldr	w0, [sp, #4]
ffff19bc:	51000401 	sub	w1, w0, #0x1		; x--
ffff19c0:	b90007e1 	str	w1, [sp, #4]
ffff19c4:	7100041f 	cmp	w0, #0x1
ffff19c8:	54ffff0a 	b.ge	0xffff19a8

ffff19cc:	52800080 	mov	w0, #0x4
ffff19d0:	b90046a0 	str	w0, [x21, #0x44]	; mmc_44
ffff19d4:	36700074 	tbz	w20, #14, 0xffff19e0
ffff19d8:	aa1503e0 	mov	x0, x21
ffff19dc:	9400004f 	bl	0xffff1b18
ffff19e0:	b94046a0 	ldr	w0, [x21, #0x44]	; mmc_44
ffff19e4:	364000a0 	tbz	w0, #8, 0xffff19f8
ffff19e8:	12800000 	mov	w0, #0xffffffff         ; w0 = -1
ffff19ec:	b90046a0 	str	w0, [x21, #0x44]
ffff19f0:	52800418 	mov	w24, #0x20
ffff19f4:	14000040 	b	0xffff1af4		; return 0x20

ffff19f8:	12170280 	and	w0, w20, #0x200
ffff19fc:	34000500 	cbz	w0, 0xffff1a9c
ffff1a00:	b90007ff 	str	wzr, [sp, #4]		; x = 0
ffff1a04:	53027ef8 	lsr	w24, w23, #2
ffff1a08:	52945017 	mov	w23, #0xa280                	// #41600
ffff1a0c:	34000498 	cbz	w24, 0xffff1a9c
ffff1a10:	b94046a0 	ldr	w0, [x21, #0x44]
ffff1a14:	0a170000 	and	w0, w0, w23
ffff1a18:	350003a0 	cbnz	w0, 0xffff1a8c
ffff1a1c:	b9404aa0 	ldr	w0, [x21, #0x48]	; mmc_48
ffff1a20:	371001a0 	tbnz	w0, #2, 0xffff1a54
ffff1a24:	b9400360 	ldr	w0, [x27]
ffff1a28:	b90002c0 	str	w0, [x22]
ffff1a2c:	b90007ff 	str	wzr, [sp, #4]		; x = 0
ffff1a30:	b9404aa1 	ldr	w1, [x21, #0x48]
ffff1a34:	2a1803e0 	mov	w0, w24
ffff1a38:	910012d6 	add	x22, x22, #0x4
ffff1a3c:	51000418 	sub	w24, w0, #0x1
ffff1a40:	37100061 	tbnz	w1, #2, 0xffff1a4c
ffff1a44:	7100041f 	cmp	w0, #0x1
ffff1a48:	54fffee1 	b.ne	0xffff1a24
ffff1a4c:	7100041f 	cmp	w0, #0x1
ffff1a50:	54000160 	b.eq	0xffff1a7c
ffff1a54:	52800020 	mov	w0, #0x1
ffff1a58:	97fffbf6 	bl	0xffff0a30		; xxdelay(1)
ffff1a5c:	b94007e0 	ldr	w0, [sp, #4]		; w0 = x
ffff1a60:	90000021 	adrp	x1, 0xffff5000

ffff1a64:	b9406821 	ldr	w1, [x1, #0x68]		; w1 = bob
ffff1a68:	11000402 	add	w2, w0, #0x1
ffff1a6c:	b90007e2 	str	w2, [sp, #4]
ffff1a70:	6b21401f 	cmp	w0, w1, uxtw
ffff1a74:	54fffccb 	b.lt	0xffff1a0c
ffff1a78:	14000005 	b	0xffff1a8c

ffff1a7c:	b94046a0 	ldr	w0, [x21, #0x44]
ffff1a80:	52945001 	mov	w1, #0xa280                	// #41600
ffff1a84:	0a010000 	and	w0, w0, w1
ffff1a88:	340000a0 	cbz	w0, 0xffff1a9c
ffff1a8c:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff1a90:	b90046a0 	str	w0, [x21, #0x44]
ffff1a94:	52a01018 	mov	w24, #0x800000              	// #8388608
ffff1a98:	14000017 	b	0xffff1af4		; return

ffff1a9c:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff1aa0:	b90046a0 	str	w0, [x21, #0x44]
ffff1aa4:	368001f4 	tbz	w20, #16, 0xffff1ae0
ffff1aa8:	b90007ff 	str	wzr, [sp, #4]
ffff1aac:	b9404aa0 	ldr	w0, [x21, #0x48]
ffff1ab0:	36480180 	tbz	w0, #9, 0xffff1ae0
ffff1ab4:	52800020 	mov	w0, #0x1                   	// #1
ffff1ab8:	97fffbde 	bl	0xffff0a30		; xxdelay(1)
ffff1abc:	b94007e0 	ldr	w0, [sp, #4]

ffff1ac0:	90000021 	adrp	x1, 0xffff5000
ffff1ac4:	b9406c21 	ldr	w1, [x1, #0x6c]		; ffff506c: 0003d091
ffff1ac8:	11000402 	add	w2, w0, #0x1
ffff1acc:	b90007e2 	str	w2, [sp, #4]
ffff1ad0:	52808018 	mov	w24, #0x400                 	// #1024
ffff1ad4:	6b21401f 	cmp	w0, w1, uxtw
ffff1ad8:	54fffeab 	b.lt	0xffff1aac  // b.tstop
ffff1adc:	14000002 	b	0xffff1ae4

ffff1ae0:	2a1f03f8 	mov	w24, wzr
ffff1ae4:	36300094 	tbz	w20, #6, 0xffff1af4	; return
ffff1ae8:	b4000073 	cbz	x19, 0xffff1af4		; return
ffff1aec:	b94032a0 	ldr	w0, [x21, #0x30]
ffff1af0:	b9000260 	str	w0, [x19]

; We return here.  x24 becomes the return value
ffff1af4:	aa1803e0 	mov	x0, x24
ffff1af8:	f94007f3 	ldr	x19, [sp, #8]
ffff1afc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff1b00:	a9425ff6 	ldp	x22, x23, [sp, #32]
ffff1b04:	a94367f8 	ldp	x24, x25, [sp, #48]
ffff1b08:	a9446ffa 	ldp	x26, x27, [sp, #64]
ffff1b0c:	a9457bfd 	ldp	x29, x30, [sp, #80]
ffff1b10:	910183ff 	add	sp, sp, #0x60
ffff1b14:	d65f03c0 	ret

; subroutine
; Called with x0 the base for SD or eMMC
; called in 2 places
ffff1b18:	d10043ff 	sub	sp, sp, #0x10
ffff1b1c:	b9404801 	ldr	w1, [x0, #0x48]		; mmc_48
ffff1b20:	371001a1 	tbnz	w1, #2, 0xffff1b54	; bail out

; Set this bit, then wait for it to clear, with timeout
ffff1b24:	b9400001 	ldr	w1, [x0]		; mmc_0
ffff1b28:	321f0021 	orr	w1, w1, #0x2
ffff1b2c:	b9000001 	str	w1, [x0]		; mmc_0 |= 0x2

ffff1b30:	52827101 	mov	w1, #0x1388
ffff1b34:	b9000fe1 	str	w1, [sp, #12]		; x = 5000
ffff1b38:	b9400001 	ldr	w1, [x0]		; mmc_0
ffff1b3c:	360800c1 	tbz	w1, #1, 0xffff1b54	; test bit 1
ffff1b40:	b9400fe1 	ldr	w1, [sp, #12]
ffff1b44:	51000422 	sub	w2, w1, #0x1
ffff1b48:	b9000fe2 	str	w2, [sp, #12]		; x--
ffff1b4c:	7100003f 	cmp	w1, #0x0
ffff1b50:	54ffff4c 	b.gt	0xffff1b38		; loop

ffff1b54:	910043ff 	add	sp, sp, #0x10
ffff1b58:	d65f03c0 	ret

; subroutine, many calls.
; bounces to the routine above

ffff1b5c:	aa1f03e4 	mov	x4, xzr
ffff1b60:	aa1f03e5 	mov	x5, xzr
ffff1b64:	aa1f03e6 	mov	x6, xzr
ffff1b68:	17ffff61 	b	0xffff18ec

; subroutine, only called from one place

ffff1b6c:	d10083ff 	sub	sp, sp, #0x20
ffff1b70:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff1b74:	910043fd 	add	x29, sp, #0x10
ffff1b78:	a90053f3 	stp	x19, x20, [sp]
ffff1b7c:	aa0003f3 	mov	x19, x0
ffff1b80:	7100027f 	cmp	w19, #0x0
ffff1b84:	d2bfc660 	mov	x0, #0xfe330000		; eMMC base
ffff1b88:	d2bfc641 	mov	x1, #0xfe320000		; SD MMC base
ffff1b8c:	9a800034 	csel	x20, x1, x0, eq
ffff1b90:	35000373 	cbnz	w19, 0xffff1bfc
ffff1b94:	90000020 	adrp	x0, 0xffff5000
ffff1b98:	b9407000 	ldr	w0, [x0, #0x70]		; ffff5070: 9f008300
ffff1b9c:	90000021 	adrp	x1, 0xffff5000
ffff1ba0:	b9407421 	ldr	w1, [x1, #0x74]		; ffff5074: ff760134
ffff1ba4:	b9000020 	str	w0, [x1]
ffff1ba8:	90000020 	adrp	x0, 0xffff5000
ffff1bac:	b9407800 	ldr	w0, [x0, #0x78]		; ffff5078: 077f051f
ffff1bb0:	90000021 	adrp	x1, 0xffff5000
ffff1bb4:	b9407c21 	ldr	w1, [x1, #0x7c]		; ffff507c: ff760140
ffff1bb8:	b9000020 	str	w0, [x1]
ffff1bbc:	90000020 	adrp	x0, 0xffff5000
ffff1bc0:	b9408000 	ldr	w0, [x0, #0x80]		; ffff5080: 00060004
ffff1bc4:	90000021 	adrp	x1, 0xffff5000
ffff1bc8:	b9408421 	ldr	w1, [x1, #0x84]		; ffff5084: ff760580
ffff1bcc:	90000022 	adrp	x2, 0xffff5000
ffff1bd0:	b9408842 	ldr	w2, [x2, #0x88]		; ffff5088: c0004000
ffff1bd4:	90000023 	adrp	x3, 0xffff5000
ffff1bd8:	b9408c63 	ldr	w3, [x3, #0x8c]		; ffff508c: 0fff0555
ffff1bdc:	90000024 	adrp	x4, 0xffff5000
ffff1be0:	b9409084 	ldr	w4, [x4, #0x90]		; ffff5090: ff77e024
ffff1be4:	b9000020 	str	w0, [x1]
ffff1be8:	d2bfe640 	mov	x0, #0xff320000
ffff1bec:	b9000002 	str	w2, [x0]
ffff1bf0:	b9000083 	str	w3, [x4]
ffff1bf4:	5280fa00 	mov	w0, #0x7d0		; w0 = 2000
ffff1bf8:	97fffb8e 	bl	0xffff0a30		; xxdelay(2000)
ffff1bfc:	f0ffc660 	adrp	x0, 0xff8c0000
ffff1c00:	b9031013 	str	w19, [x0, #0x310]
ffff1c04:	71000e7f 	cmp	w19, #0x3
ffff1c08:	1a9f17e0 	cset	w0, eq  // eq = none
ffff1c0c:	12000000 	and	w0, w0, #0x1
ffff1c10:	b9000680 	str	w0, [x20, #4]
ffff1c14:	52807d00 	mov	w0, #0x3e8                 	// #1000
ffff1c18:	97fffb86 	bl	0xffff0a30		; xxdelay(1000)
ffff1c1c:	52800060 	mov	w0, #0x3                   	// #3
ffff1c20:	b9000280 	str	w0, [x20]
ffff1c24:	52800c80 	mov	w0, #0x64                  	// #100
ffff1c28:	97fffb82 	bl	0xffff0a30		; xxdelay(100)
ffff1c2c:	90000020 	adrp	x0, 0xffff5000
ffff1c30:	b9409400 	ldr	w0, [x0, #0x94]		; ffff5094: 80202000
ffff1c34:	b9000a9f 	str	wzr, [x20, #8]
ffff1c38:	52800021 	mov	w1, #0x1		; w1 = 1
ffff1c3c:	b9001281 	str	w1, [x20, #16]
ffff1c40:	b9002e80 	str	w0, [x20, #0x2c]
ffff1c44:	b9402e80 	ldr	w0, [x20, #0x2c]
ffff1c48:	3100041f 	cmn	w0, #0x1
ffff1c4c:	5400016c 	b.gt	0xffff1c78
ffff1c50:	5284e1f3 	mov	w19, #0x270f                	// #9999
ffff1c54:	52800020 	mov	w0, #0x1                   	// #1
ffff1c58:	97fffb76 	bl	0xffff0a30		; xxdelay(1)
ffff1c5c:	b9402e80 	ldr	w0, [x20, #0x2c]
ffff1c60:	3100041f 	cmn	w0, #0x1
ffff1c64:	540000ac 	b.gt	0xffff1c78
ffff1c68:	51000660 	sub	w0, w19, #0x1
ffff1c6c:	7100027f 	cmp	w19, #0x0
ffff1c70:	2a0003f3 	mov	w19, w0
ffff1c74:	54ffff0c 	b.gt	0xffff1c54
ffff1c78:	52803e80 	mov	w0, #0x1f4                 	// #500
ffff1c7c:	97fffb6d 	bl	0xffff0a30		; xxdelay(500)
ffff1c80:	128017e0 	mov	w0, #0xffffff40            	// #-192
ffff1c84:	90000021 	adrp	x1, 0xffff5000
ffff1c88:	b9409821 	ldr	w1, [x1, #0x98]		; ffff5098: 307f0080
ffff1c8c:	b9001680 	str	w0, [x20, #20]
ffff1c90:	b9004e81 	str	w1, [x20, #0x4c]
ffff1c94:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff1c98:	b9004680 	str	w0, [x20, #0x44]
ffff1c9c:	aa1f03e0 	mov	x0, xzr
ffff1ca0:	a94053f3 	ldp	x19, x20, [sp]
ffff1ca4:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff1ca8:	910083ff 	add	sp, sp, #0x20
ffff1cac:	d65f03c0 	ret

ffff1cb0:	90000021 	adrp	x1, 0xffff5000
ffff1cb4:	b9409c21 	ldr	w1, [x1, #0x9c]
ffff1cb8:	39400022 	ldrb	w2, [x1]
ffff1cbc:	7100101f 	cmp	w0, #0x4
ffff1cc0:	540000a1 	b.ne	0xffff1cd4  // b.any
ffff1cc4:	52801ba0 	mov	w0, #0xdd                  	// #221
ffff1cc8:	0a000040 	and	w0, w2, w0
ffff1ccc:	321f0000 	orr	w0, w0, #0x2
ffff1cd0:	14000009 	b	0xffff1cf4
ffff1cd4:	7100201f 	cmp	w0, #0x8
ffff1cd8:	540000a1 	b.ne	0xffff1cec  // b.any
ffff1cdc:	52801ba0 	mov	w0, #0xdd                  	// #221
ffff1ce0:	0a000040 	and	w0, w2, w0
ffff1ce4:	321b0000 	orr	w0, w0, #0x20
ffff1ce8:	14000003 	b	0xffff1cf4
ffff1cec:	52801ba0 	mov	w0, #0xdd                  	// #221
ffff1cf0:	0a000040 	and	w0, w2, w0
ffff1cf4:	39000020 	strb	w0, [x1]
ffff1cf8:	aa1f03e0 	mov	x0, xzr
ffff1cfc:	d65f03c0 	ret
ffff1d00:	d10083ff 	sub	sp, sp, #0x20
ffff1d04:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff1d08:	910043fd 	add	x29, sp, #0x10
ffff1d0c:	a90053f3 	stp	x19, x20, [sp]
ffff1d10:	90000020 	adrp	x0, 0xffff5000
ffff1d14:	b940a013 	ldr	w19, [x0, #0xa0]
ffff1d18:	7900027f 	strh	wzr, [x19]
ffff1d1c:	52800140 	mov	w0, #0xa                   	// #10
ffff1d20:	97fffb44 	bl	0xffff0a30		; xxdelay(10)
ffff1d24:	90000020 	adrp	x0, 0xffff5000
ffff1d28:	b940a400 	ldr	w0, [x0, #0xa4]
ffff1d2c:	90000021 	adrp	x1, 0xffff5000
ffff1d30:	b940a821 	ldr	w1, [x1, #0xa8]
ffff1d34:	b9000020 	str	w0, [x1]
ffff1d38:	52800020 	mov	w0, #0x1                   	// #1
ffff1d3c:	79000260 	strh	w0, [x19]
ffff1d40:	79400261 	ldrh	w1, [x19]
ffff1d44:	37080121 	tbnz	w1, #1, 0xffff1d68
ffff1d48:	1289c414 	mov	w20, #0xffffb1df            	// #-20001
ffff1d4c:	11000694 	add	w20, w20, #0x1
ffff1d50:	52820000 	mov	w0, #0x1000                	// #4096
ffff1d54:	34000114 	cbz	w20, 0xffff1d74
ffff1d58:	52800020 	mov	w0, #0x1                   	// #1
ffff1d5c:	97fffb35 	bl	0xffff0a30		; xxdelay(1)
ffff1d60:	79400261 	ldrh	w1, [x19]
ffff1d64:	360fff41 	tbz	w1, #1, 0xffff1d4c
ffff1d68:	2a1f03e0 	mov	w0, wzr
ffff1d6c:	321e0021 	orr	w1, w1, #0x4
ffff1d70:	79000261 	strh	w1, [x19]
ffff1d74:	a94053f3 	ldp	x19, x20, [sp]
ffff1d78:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff1d7c:	910083ff 	add	sp, sp, #0x20
ffff1d80:	d65f03c0 	ret

ffff1d84:	d10203ff 	sub	sp, sp, #0x80
ffff1d88:	a9077bfd 	stp	x29, x30, [sp, #112]
ffff1d8c:	9101c3fd 	add	x29, sp, #0x70
ffff1d90:	a90673fb 	stp	x27, x28, [sp, #96]
ffff1d94:	a9056bf9 	stp	x25, x26, [sp, #80]
ffff1d98:	a90463f7 	stp	x23, x24, [sp, #64]
ffff1d9c:	a9035bf5 	stp	x21, x22, [sp, #48]
ffff1da0:	a90253f3 	stp	x19, x20, [sp, #32]
ffff1da4:	aa0503f4 	mov	x20, x5
ffff1da8:	aa0403f9 	mov	x25, x4
ffff1dac:	aa0303f5 	mov	x21, x3
ffff1db0:	aa0203f3 	mov	x19, x2
ffff1db4:	aa0103f8 	mov	x24, x1
ffff1db8:	aa0003f6 	mov	x22, x0
ffff1dbc:	33000400 	bfxil	w0, w0, #0, #2
ffff1dc0:	52800461 	mov	w1, #0x23                  	// #35
ffff1dc4:	6a01001f 	tst	w0, w1
ffff1dc8:	52800060 	mov	w0, #0x3                   	// #3
ffff1dcc:	52800021 	mov	w1, #0x1                   	// #1
ffff1dd0:	1a800020 	csel	w0, w1, w0, eq  // eq = none
ffff1dd4:	52801802 	mov	w2, #0xc0                  	// #192
ffff1dd8:	6a0202df 	tst	w22, w2
ffff1ddc:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffff1de0:	940000be 	bl	0xffff20d8
ffff1de4:	aa0003f7 	mov	x23, x0
ffff1de8:	35001557 	cbnz	w23, 0xffff2090
ffff1dec:	f9000bf3 	str	x19, [sp, #16]
ffff1df0:	53107ed3 	lsr	w19, w22, #16
ffff1df4:	121b02db 	and	w27, w22, #0x20
ffff1df8:	3400031b 	cbz	w27, 0xffff1e58
ffff1dfc:	52800097 	mov	w23, #0x4                   	// #4
ffff1e00:	340015b9 	cbz	w25, 0xffff20b4
ffff1e04:	6b35433f 	cmp	w25, w21, uxtw
ffff1e08:	54001563 	b.cc	0xffff20b4  // b.lo, b.ul, b.last
ffff1e0c:	53097f3a 	lsr	w26, w25, #9
ffff1e10:	12002ea0 	and	w0, w21, #0xfff
ffff1e14:	32140800 	orr	w0, w0, #0x7000
ffff1e18:	90000021 	adrp	x1, 0xffff5000
ffff1e1c:	b940ac21 	ldr	w1, [x1, #0xac]
ffff1e20:	79000020 	strh	w0, [x1]
ffff1e24:	90000020 	adrp	x0, 0xffff5000
ffff1e28:	b940b000 	ldr	w0, [x0, #0xb0]
ffff1e2c:	7900001a 	strh	w26, [x0]
ffff1e30:	710fff3f 	cmp	w25, #0x3ff
ffff1e34:	52800040 	mov	w0, #0x2                   	// #2
ffff1e38:	52800441 	mov	w1, #0x22                  	// #34
ffff1e3c:	1a808020 	csel	w0, w1, w0, hi  // hi = pmore
ffff1e40:	36200073 	tbz	w19, #4, 0xffff1e4c
ffff1e44:	321c0000 	orr	w0, w0, #0x10
ffff1e48:	12003c00 	and	w0, w0, #0xffff
ffff1e4c:	90000021 	adrp	x1, 0xffff5000
ffff1e50:	b940b421 	ldr	w1, [x1, #0xb4]
ffff1e54:	79000020 	strh	w0, [x1]
ffff1e58:	90000020 	adrp	x0, 0xffff5000
ffff1e5c:	b940b800 	ldr	w0, [x0, #0xb8]
ffff1e60:	b9000018 	str	w24, [x0]
ffff1e64:	90000020 	adrp	x0, 0xffff5000
ffff1e68:	b940bc00 	ldr	w0, [x0, #0xbc]
ffff1e6c:	90000021 	adrp	x1, 0xffff5000
ffff1e70:	b940c038 	ldr	w24, [x1, #0xc0]
ffff1e74:	79000016 	strh	w22, [x0]
ffff1e78:	b9400300 	ldr	w0, [x24]
ffff1e7c:	90000021 	adrp	x1, 0xffff5000
ffff1e80:	b940c439 	ldr	w25, [x1, #0xc4]
ffff1e84:	0a190001 	and	w1, w0, w25
ffff1e88:	35000141 	cbnz	w1, 0xffff1eb0
ffff1e8c:	1284e21c 	mov	w28, #0xffffd8ef            	// #-10001
ffff1e90:	1100079c 	add	w28, w28, #0x1
ffff1e94:	52800417 	mov	w23, #0x20                  	// #32
ffff1e98:	340010fc 	cbz	w28, 0xffff20b4
ffff1e9c:	52800020 	mov	w0, #0x1                   	// #1
ffff1ea0:	97fffae4 	bl	0xffff0a30		; xxdelay(1)
ffff1ea4:	b9400300 	ldr	w0, [x24]
ffff1ea8:	0a190001 	and	w1, w0, w25
ffff1eac:	34ffff21 	cbz	w1, 0xffff1e90
ffff1eb0:	b9000301 	str	w1, [x24]
ffff1eb4:	12100c00 	and	w0, w0, #0xf0000
ffff1eb8:	52a02017 	mov	w23, #0x1000000             	// #16777216
ffff1ebc:	35000f40 	cbnz	w0, 0xffff20a4
ffff1ec0:	120006d6 	and	w22, w22, #0x3
ffff1ec4:	340001fb 	cbz	w27, 0xffff1f00
ffff1ec8:	b9000ff6 	str	w22, [sp, #12]
ffff1ecc:	121c0279 	and	w25, w19, #0x10
ffff1ed0:	3400085a 	cbz	w26, 0xffff1fd8
ffff1ed4:	52808000 	mov	w0, #0x400                 	// #1024
ffff1ed8:	0b191817 	add	w23, w0, w25, lsl #6
ffff1edc:	53027ebb 	lsr	w27, w21, #2
ffff1ee0:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff1ee4:	0b550800 	add	w0, w0, w21, lsr #2
ffff1ee8:	9000003c 	adrp	x28, 0xffff5000
ffff1eec:	b940cb93 	ldr	w19, [x28, #0xc8]
ffff1ef0:	53007c00 	lsr	w0, w0, #0
ffff1ef4:	91000416 	add	x22, x0, #0x1
ffff1ef8:	4b550bf5 	neg	w21, w21, lsr #2
ffff1efc:	14000008 	b	0xffff1f1c
ffff1f00:	b9400300 	ldr	w0, [x24]
ffff1f04:	b9000300 	str	w0, [x24]
ffff1f08:	f9400bf3 	ldr	x19, [sp, #16]
ffff1f0c:	14000054 	b	0xffff205c
ffff1f10:	51000673 	sub	w19, w19, #0x1
ffff1f14:	52800020 	mov	w0, #0x1                   	// #1
ffff1f18:	97fffac6 	bl	0xffff0a30		; xxdelay(1)
ffff1f1c:	b9400300 	ldr	w0, [x24]
ffff1f20:	120c0800 	and	w0, w0, #0x700000
ffff1f24:	35000520 	cbnz	w0, 0xffff1fc8
ffff1f28:	90000020 	adrp	x0, 0xffff5000
ffff1f2c:	b940cc00 	ldr	w0, [x0, #0xcc]
ffff1f30:	b9400000 	ldr	w0, [x0]
ffff1f34:	0a170000 	and	w0, w0, w23
ffff1f38:	340003c0 	cbz	w0, 0xffff1fb0
ffff1f3c:	350001d9 	cbnz	w25, 0xffff1f74
ffff1f40:	90000020 	adrp	x0, 0xffff5000
ffff1f44:	b940d413 	ldr	w19, [x0, #0xd4]
ffff1f48:	2a1503e0 	mov	w0, w21
ffff1f4c:	aa1403e1 	mov	x1, x20
ffff1f50:	340002bb 	cbz	w27, 0xffff1fa4
ffff1f54:	b9400022 	ldr	w2, [x1]
ffff1f58:	90000023 	adrp	x3, 0xffff5000
ffff1f5c:	b940d063 	ldr	w3, [x3, #0xd0]
ffff1f60:	91001021 	add	x1, x1, #0x4
ffff1f64:	b9000062 	str	w2, [x3]
ffff1f68:	11000400 	add	w0, w0, #0x1
ffff1f6c:	35ffff40 	cbnz	w0, 0xffff1f54
ffff1f70:	1400000c 	b	0xffff1fa0
ffff1f74:	b940cb93 	ldr	w19, [x28, #0xc8]
ffff1f78:	2a1503e0 	mov	w0, w21
ffff1f7c:	aa1403e1 	mov	x1, x20
ffff1f80:	3400013b 	cbz	w27, 0xffff1fa4
ffff1f84:	90000022 	adrp	x2, 0xffff5000
ffff1f88:	b940d042 	ldr	w2, [x2, #0xd0]
ffff1f8c:	b9400042 	ldr	w2, [x2]
ffff1f90:	b9000022 	str	w2, [x1]
ffff1f94:	91001021 	add	x1, x1, #0x4
ffff1f98:	11000400 	add	w0, w0, #0x1
ffff1f9c:	35ffff40 	cbnz	w0, 0xffff1f84
ffff1fa0:	8b366a94 	add	x20, x20, x22, uxtx #2
ffff1fa4:	5100075a 	sub	w26, w26, #0x1
ffff1fa8:	35fffc1a 	cbnz	w26, 0xffff1f28
ffff1fac:	14000004 	b	0xffff1fbc
ffff1fb0:	3400007a 	cbz	w26, 0xffff1fbc
ffff1fb4:	35fffaf3 	cbnz	w19, 0xffff1f10
ffff1fb8:	14000004 	b	0xffff1fc8
ffff1fbc:	b9400300 	ldr	w0, [x24]
ffff1fc0:	120c0800 	and	w0, w0, #0x700000
ffff1fc4:	340000a0 	cbz	w0, 0xffff1fd8
ffff1fc8:	b9400300 	ldr	w0, [x24]
ffff1fcc:	b9000300 	str	w0, [x24]
ffff1fd0:	52a01017 	mov	w23, #0x800000              	// #8388608
ffff1fd4:	14000034 	b	0xffff20a4
ffff1fd8:	b9400300 	ldr	w0, [x24]
ffff1fdc:	90000021 	adrp	x1, 0xffff5000
ffff1fe0:	b940d833 	ldr	w19, [x1, #0xd8]
ffff1fe4:	b9001fe0 	str	w0, [sp, #28]
ffff1fe8:	0a130000 	and	w0, w0, w19
ffff1fec:	35000180 	cbnz	w0, 0xffff201c
ffff1ff0:	90000020 	adrp	x0, 0xffff5000
ffff1ff4:	b940dc14 	ldr	w20, [x0, #0xdc]
ffff1ff8:	11000694 	add	w20, w20, #0x1
ffff1ffc:	52a01000 	mov	w0, #0x800000              	// #8388608
ffff2000:	34000114 	cbz	w20, 0xffff2020
ffff2004:	52800020 	mov	w0, #0x1                   	// #1
ffff2008:	97fffa8a 	bl	0xffff0a30		; xxdelay(1)
ffff200c:	b9400300 	ldr	w0, [x24]
ffff2010:	b9001fe0 	str	w0, [sp, #28]
ffff2014:	0a130000 	and	w0, w0, w19
ffff2018:	34ffff00 	cbz	w0, 0xffff1ff8
ffff201c:	2a1f03e0 	mov	w0, wzr
ffff2020:	b9401fe1 	ldr	w1, [sp, #28]
ffff2024:	52a00e02 	mov	w2, #0x700000              	// #7340032
ffff2028:	6a02003f 	tst	w1, w2
ffff202c:	52a01001 	mov	w1, #0x800000              	// #8388608
ffff2030:	1a810017 	csel	w23, w0, w1, eq  // eq = none
ffff2034:	2a1902e0 	orr	w0, w23, w25
ffff2038:	f9400bf3 	ldr	x19, [sp, #16]
ffff203c:	35000080 	cbnz	w0, 0xffff204c
ffff2040:	52800040 	mov	w0, #0x2                   	// #2
ffff2044:	94000025 	bl	0xffff20d8
ffff2048:	aa0003f7 	mov	x23, x0
ffff204c:	b9400300 	ldr	w0, [x24]
ffff2050:	b9000300 	str	w0, [x24]
ffff2054:	b9400ff6 	ldr	w22, [sp, #12]
ffff2058:	350001d7 	cbnz	w23, 0xffff2090
ffff205c:	71000edf 	cmp	w22, #0x3
ffff2060:	540000a1 	b.ne	0xffff2074  // b.any
ffff2064:	52800040 	mov	w0, #0x2                   	// #2
ffff2068:	9400001c 	bl	0xffff20d8
ffff206c:	aa0003f7 	mov	x23, x0
ffff2070:	14000002 	b	0xffff2078
ffff2074:	2a1f03f7 	mov	w23, wzr
ffff2078:	340000d6 	cbz	w22, 0xffff2090
ffff207c:	b40000b3 	cbz	x19, 0xffff2090
ffff2080:	f0000000 	adrp	x0, 0xffff5000
ffff2084:	b940e000 	ldr	w0, [x0, #0xe0]
ffff2088:	b9400000 	ldr	w0, [x0]
ffff208c:	b9000260 	str	w0, [x19]
ffff2090:	716002ff 	cmp	w23, #0x800, lsl #12
ffff2094:	54000080 	b.eq	0xffff20a4  // b.none
ffff2098:	52a02000 	mov	w0, #0x1000000             	// #16777216
ffff209c:	6b2042ff 	cmp	w23, w0, uxtw
ffff20a0:	540000a1 	b.ne	0xffff20b4  // b.any
ffff20a4:	52800040 	mov	w0, #0x2                   	// #2
ffff20a8:	94000027 	bl	0xffff2144
ffff20ac:	52800080 	mov	w0, #0x4                   	// #4
ffff20b0:	94000025 	bl	0xffff2144
ffff20b4:	aa1703e0 	mov	x0, x23
ffff20b8:	a94253f3 	ldp	x19, x20, [sp, #32]
ffff20bc:	a9435bf5 	ldp	x21, x22, [sp, #48]
ffff20c0:	a94463f7 	ldp	x23, x24, [sp, #64]
ffff20c4:	a9456bf9 	ldp	x25, x26, [sp, #80]
ffff20c8:	a94673fb 	ldp	x27, x28, [sp, #96]
ffff20cc:	a9477bfd 	ldp	x29, x30, [sp, #112]
ffff20d0:	910203ff 	add	sp, sp, #0x80
ffff20d4:	d65f03c0 	ret
ffff20d8:	d100c3ff 	sub	sp, sp, #0x30
ffff20dc:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff20e0:	910083fd 	add	x29, sp, #0x20
ffff20e4:	a90157f4 	stp	x20, x21, [sp, #16]
ffff20e8:	f90007f3 	str	x19, [sp, #8]
ffff20ec:	f0000001 	adrp	x1, 0xffff5000
ffff20f0:	b940e434 	ldr	w20, [x1, #0xe4]
ffff20f4:	b9400281 	ldr	w1, [x20]
ffff20f8:	aa0003f3 	mov	x19, x0
ffff20fc:	0a130020 	and	w0, w1, w19
ffff2100:	34000160 	cbz	w0, 0xffff212c
ffff2104:	f0000000 	adrp	x0, 0xffff5000
ffff2108:	b940e815 	ldr	w21, [x0, #0xe8]
ffff210c:	110006b5 	add	w21, w21, #0x1
ffff2110:	52808000 	mov	w0, #0x400                 	// #1024
ffff2114:	340000f5 	cbz	w21, 0xffff2130
ffff2118:	52800020 	mov	w0, #0x1                   	// #1
ffff211c:	97fffa45 	bl	0xffff0a30		; xxdelay(1)
ffff2120:	b9400280 	ldr	w0, [x20]
ffff2124:	0a130000 	and	w0, w0, w19
ffff2128:	35ffff20 	cbnz	w0, 0xffff210c
ffff212c:	2a1f03e0 	mov	w0, wzr
ffff2130:	f94007f3 	ldr	x19, [sp, #8]
ffff2134:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff2138:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff213c:	9100c3ff 	add	sp, sp, #0x30
ffff2140:	d65f03c0 	ret
ffff2144:	d100c3ff 	sub	sp, sp, #0x30
ffff2148:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff214c:	910083fd 	add	x29, sp, #0x20
ffff2150:	a90157f4 	stp	x20, x21, [sp, #16]
ffff2154:	f90007f3 	str	x19, [sp, #8]
ffff2158:	f0000001 	adrp	x1, 0xffff5000
ffff215c:	b940ec34 	ldr	w20, [x1, #0xec]
ffff2160:	aa0003f3 	mov	x19, x0
ffff2164:	39000293 	strb	w19, [x20]
ffff2168:	39400280 	ldrb	w0, [x20]
ffff216c:	0a130000 	and	w0, w0, w19
ffff2170:	12001c00 	and	w0, w0, #0xff
ffff2174:	34000160 	cbz	w0, 0xffff21a0
ffff2178:	1289c3c0 	mov	w0, #0xffffb1e1            	// #-19999
ffff217c:	2a0003f5 	mov	w21, w0
ffff2180:	52800020 	mov	w0, #0x1                   	// #1
ffff2184:	97fffa2b 	bl	0xffff0a30		; xxdelay(1)
ffff2188:	39400280 	ldrb	w0, [x20]
ffff218c:	0a130000 	and	w0, w0, w19
ffff2190:	12001c00 	and	w0, w0, #0xff
ffff2194:	34000060 	cbz	w0, 0xffff21a0
ffff2198:	110006a0 	add	w0, w21, #0x1
ffff219c:	35ffff15 	cbnz	w21, 0xffff217c
ffff21a0:	f94007f3 	ldr	x19, [sp, #8]
ffff21a4:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff21a8:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff21ac:	9100c3ff 	add	sp, sp, #0x30
ffff21b0:	d65f03c0 	ret
ffff21b4:	aa1f03e3 	mov	x3, xzr
ffff21b8:	aa1f03e4 	mov	x4, xzr
ffff21bc:	aa1f03e5 	mov	x5, xzr
ffff21c0:	17fffef1 	b	0xffff1d84
ffff21c4:	d10083ff 	sub	sp, sp, #0x20
ffff21c8:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff21cc:	910043fd 	add	x29, sp, #0x10
ffff21d0:	a90053f3 	stp	x19, x20, [sp]
ffff21d4:	52800034 	mov	w20, #0x1                   	// #1
ffff21d8:	52800020 	mov	w0, #0x1                   	// #1
ffff21dc:	97ffffda 	bl	0xffff2144
ffff21e0:	f0000000 	adrp	x0, 0xffff5000
ffff21e4:	b940f000 	ldr	w0, [x0, #0xf0]
ffff21e8:	f0000001 	adrp	x1, 0xffff5000
ffff21ec:	b940f421 	ldr	w1, [x1, #0xf4]
ffff21f0:	b9000020 	str	w0, [x1]
ffff21f4:	f0000000 	adrp	x0, 0xffff5000
ffff21f8:	b940f800 	ldr	w0, [x0, #0xf8]
ffff21fc:	f0000001 	adrp	x1, 0xffff5000
ffff2200:	b940fc21 	ldr	w1, [x1, #0xfc]
ffff2204:	b9000020 	str	w0, [x1]
ffff2208:	f0000000 	adrp	x0, 0xffff5000
ffff220c:	b9410000 	ldr	w0, [x0, #0x100]
ffff2210:	320087e1 	mov	w1, #0x30003               	// #196611
ffff2214:	b9000001 	str	w1, [x0]
ffff2218:	f0000000 	adrp	x0, 0xffff5000
ffff221c:	b9410400 	ldr	w0, [x0, #0x104]
ffff2220:	f0000001 	adrp	x1, 0xffff5000
ffff2224:	b9410821 	ldr	w1, [x1, #0x108]
ffff2228:	d2bfe642 	mov	x2, #0xff320000            	// #4281466880
ffff222c:	b9000040 	str	w0, [x2]
ffff2230:	52800160 	mov	w0, #0xb                   	// #11
ffff2234:	39000020 	strb	w0, [x1]
ffff2238:	52807d00 	mov	w0, #0x3e8                 	// #1000
ffff223c:	97fff9fd 	bl	0xffff0a30		; xxdelay(1000)
ffff2240:	f0000000 	adrp	x0, 0xffff5000
ffff2244:	b9410c13 	ldr	w19, [x0, #0x10c]
ffff2248:	7900027f 	strh	wzr, [x19]
ffff224c:	52800140 	mov	w0, #0xa                   	// #10
ffff2250:	97fff9f8 	bl	0xffff0a30		; xxdelay(10)
ffff2254:	79000274 	strh	w20, [x19]
ffff2258:	79400260 	ldrh	w0, [x19]
ffff225c:	37080120 	tbnz	w0, #1, 0xffff2280
ffff2260:	1289c414 	mov	w20, #0xffffb1df            	// #-20001
ffff2264:	11000694 	add	w20, w20, #0x1
ffff2268:	52820000 	mov	w0, #0x1000                	// #4096
ffff226c:	34000274 	cbz	w20, 0xffff22b8
ffff2270:	52800020 	mov	w0, #0x1                   	// #1
ffff2274:	97fff9ef 	bl	0xffff0a30		; xxdelay(1)
ffff2278:	79400260 	ldrh	w0, [x19]
ffff227c:	360fff40 	tbz	w0, #1, 0xffff2264
ffff2280:	321e0000 	orr	w0, w0, #0x4
ffff2284:	79000260 	strh	w0, [x19]
ffff2288:	52803e80 	mov	w0, #0x1f4                 	// #500
ffff228c:	97fff9e9 	bl	0xffff0a30		; xxdelay(500)
ffff2290:	f0000000 	adrp	x0, 0xffff5000
ffff2294:	b9411001 	ldr	w1, [x0, #0x110]
ffff2298:	f0000000 	adrp	x0, 0xffff5000
ffff229c:	b9411402 	ldr	w2, [x0, #0x114]
ffff22a0:	f0000000 	adrp	x0, 0xffff5000
ffff22a4:	b9411803 	ldr	w3, [x0, #0x118]
ffff22a8:	2a1f03e0 	mov	w0, wzr
ffff22ac:	528001c4 	mov	w4, #0xe                   	// #14
ffff22b0:	39000024 	strb	w4, [x1]
ffff22b4:	b9000062 	str	w2, [x3]
ffff22b8:	a94053f3 	ldp	x19, x20, [sp]
ffff22bc:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff22c0:	910083ff 	add	sp, sp, #0x20
ffff22c4:	d65f03c0 	ret

; subroutine, only called in one place

ffff22c8:	d10083ff 	sub	sp, sp, #0x20
ffff22cc:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff22d0:	910043fd 	add	x29, sp, #0x10
ffff22d4:	a90053f3 	stp	x19, x20, [sp]
ffff22d8:	aa0003f3 	mov	x19, x0
ffff22dc:	d0ffc660 	adrp	x0, 0xff8c0000
ffff22e0:	7902f81f 	strh	wzr, [x0, #0x17c]
ffff22e4:	d0ffc660 	adrp	x0, 0xff8c0000
ffff22e8:	7902fc1f 	strh	wzr, [x0, #0x17e]
ffff22ec:	52902001 	mov	w1, #0x8100                	// #33024
ffff22f0:	aa1303e0 	mov	x0, x19
ffff22f4:	aa1f03e2 	mov	x2, xzr
ffff22f8:	aa1f03e3 	mov	x3, xzr
ffff22fc:	97fffe18 	bl	0xffff1b5c
ffff2300:	aa0003f4 	mov	x20, x0
ffff2304:	35000334 	cbnz	w20, 0xffff2368
ffff2308:	52800c80 	mov	w0, #0x64                  	// #100
ffff230c:	97fff9c9 	bl	0xffff0a30		; xxdelay(100)
ffff2310:	52842901 	mov	w1, #0x2148                	// #8520
ffff2314:	52803542 	mov	w2, #0x1aa                 	// #426
ffff2318:	aa1303e0 	mov	x0, x19
ffff231c:	aa1f03e3 	mov	x3, xzr
ffff2320:	97fffe0f 	bl	0xffff1b5c
ffff2324:	52800034 	mov	w20, #0x1                   	// #1
ffff2328:	7100801f 	cmp	w0, #0x20
ffff232c:	54000141 	b.ne	0xffff2354  // b.any
ffff2330:	52842ee1 	mov	w1, #0x2177                	// #8567
ffff2334:	aa1303e0 	mov	x0, x19
ffff2338:	aa1f03e2 	mov	x2, xzr
ffff233c:	aa1f03e3 	mov	x3, xzr
ffff2340:	97fffe07 	bl	0xffff1b5c
ffff2344:	35000120 	cbnz	w0, 0xffff2368
ffff2348:	aa1303e0 	mov	x0, x19
ffff234c:	aa1f03e1 	mov	x1, xzr
ffff2350:	14000004 	b	0xffff2360
ffff2354:	350000a0 	cbnz	w0, 0xffff2368
ffff2358:	52800021 	mov	w1, #0x1                   	// #1
ffff235c:	aa1303e0 	mov	x0, x19
ffff2360:	97fffc87 	bl	0xffff157c
ffff2364:	aa0003f4 	mov	x20, x0
ffff2368:	aa1403e0 	mov	x0, x20
ffff236c:	a94053f3 	ldp	x19, x20, [sp]
ffff2370:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff2374:	910083ff 	add	sp, sp, #0x20
ffff2378:	d65f03c0 	ret

ffff237c:	d100c3ff 	sub	sp, sp, #0x30
ffff2380:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff2384:	910083fd 	add	x29, sp, #0x20
ffff2388:	a90157f4 	stp	x20, x21, [sp, #16]
ffff238c:	f90007f3 	str	x19, [sp, #8]
ffff2390:	aa0203f4 	mov	x20, x2
ffff2394:	aa0103e6 	mov	x6, x1
ffff2398:	d0ffc661 	adrp	x1, 0xff8c0000
ffff239c:	7942fc21 	ldrh	w1, [x1, #0x17e]
ffff23a0:	52800482 	mov	w2, #0x24                  	// #36
ffff23a4:	6a02003f 	tst	w1, w2
ffff23a8:	52800121 	mov	w1, #0x9                   	// #9
ffff23ac:	1a8113e1 	csel	w1, wzr, w1, ne  // ne = any
ffff23b0:	1ac12002 	lsl	w2, w0, w1
ffff23b4:	7108029f 	cmp	w20, #0x200
ffff23b8:	d0ffc675 	adrp	x21, 0xff8c0000
ffff23bc:	b94312a0 	ldr	w0, [x21, #0x310]
ffff23c0:	52846a21 	mov	w1, #0x2351                	// #9041
ffff23c4:	52846a43 	mov	w3, #0x2352                	// #9042
ffff23c8:	1a818061 	csel	w1, w3, w1, hi  // hi = pmore
ffff23cc:	52804004 	mov	w4, #0x200                 	// #512
ffff23d0:	aa1f03e3 	mov	x3, xzr
ffff23d4:	aa1403e5 	mov	x5, x20
ffff23d8:	97fffd45 	bl	0xffff18ec
ffff23dc:	aa0003f3 	mov	x19, x0
ffff23e0:	7108069f 	cmp	w20, #0x201
ffff23e4:	54000123 	b.cc	0xffff2408  // b.lo, b.ul, b.last
ffff23e8:	12087a60 	and	w0, w19, #0xff7fffff
ffff23ec:	350000e0 	cbnz	w0, 0xffff2408
ffff23f0:	b94312a0 	ldr	w0, [x21, #0x310]
ffff23f4:	f0000001 	adrp	x1, 0xffff5000
ffff23f8:	b9411c21 	ldr	w1, [x1, #0x11c]
ffff23fc:	aa1f03e2 	mov	x2, xzr
ffff2400:	aa1f03e3 	mov	x3, xzr
ffff2404:	97fffdd6 	bl	0xffff1b5c
ffff2408:	7100027f 	cmp	w19, #0x0
ffff240c:	1a9f07e0 	cset	w0, ne  // ne = any
ffff2410:	92400000 	and	x0, x0, #0x1
ffff2414:	f94007f3 	ldr	x19, [sp, #8]
ffff2418:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff241c:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff2420:	9100c3ff 	add	sp, sp, #0x30
ffff2424:	d65f03c0 	ret

ffff2428:	d10083ff 	sub	sp, sp, #0x20
ffff242c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff2430:	910043fd 	add	x29, sp, #0x10
ffff2434:	a90053f3 	stp	x19, x20, [sp]
ffff2438:	aa0203f3 	mov	x19, x2
ffff243c:	aa0103e6 	mov	x6, x1
ffff2440:	52800801 	mov	w1, #0x40                  	// #64
ffff2444:	2a002834 	orr	w20, w1, w0, lsl #10
ffff2448:	d0ffc660 	adrp	x0, 0xff8c0000
ffff244c:	7942fc00 	ldrh	w0, [x0, #0x17e]
ffff2450:	52800481 	mov	w1, #0x24                  	// #36
ffff2454:	6a01001f 	tst	w0, w1
ffff2458:	d0ffc660 	adrp	x0, 0xff8c0000
ffff245c:	b9431000 	ldr	w0, [x0, #0x310]
ffff2460:	52800121 	mov	w1, #0x9                   	// #9
ffff2464:	1a8113e1 	csel	w1, wzr, w1, ne  // ne = any
ffff2468:	1ac12282 	lsl	w2, w20, w1
ffff246c:	52846a21 	mov	w1, #0x2351                	// #9041
ffff2470:	52804004 	mov	w4, #0x200                 	// #512
ffff2474:	52804005 	mov	w5, #0x200                 	// #512
ffff2478:	aa1f03e3 	mov	x3, xzr
ffff247c:	97fffd1c 	bl	0xffff18ec
ffff2480:	aa0003e1 	mov	x1, x0
ffff2484:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff2488:	35000061 	cbnz	w1, 0xffff2494
ffff248c:	2a1f03e0 	mov	w0, wzr
ffff2490:	b9000274 	str	w20, [x19]
ffff2494:	a94053f3 	ldp	x19, x20, [sp]
ffff2498:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff249c:	910083ff 	add	sp, sp, #0x20
ffff24a0:	d65f03c0 	ret

;  ===============================================

; subroutine -- "try_abc ( table_entry )"
; called in the midst of the "try four" loop
; passed a pointer to a table entry in x0
;
; A table entry consists of 4 8 byte items, so:
;	table + 0x0
;	table + 0x8
;	table + 0x10 (16)
;	table + 0x18 (24) w1 and w2
;
; The last item is two 4 byte items at offset 24 and 28

ffff24a4:	d10203ff 	sub	sp, sp, #0x80
ffff24a8:	a9077bfd 	stp	x29, x30, [sp, #112]
ffff24ac:	9101c3fd 	add	x29, sp, #0x70
ffff24b0:	a90673fb 	stp	x27, x28, [sp, #96]
ffff24b4:	a9056bf9 	stp	x25, x26, [sp, #80]
ffff24b8:	a90463f7 	stp	x23, x24, [sp, #64]
ffff24bc:	a9035bf5 	stp	x21, x22, [sp, #48]
ffff24c0:	a90253f3 	stp	x19, x20, [sp, #32]

ffff24c4:	aa0003f3 	mov	x19, x0			; table pointer
ffff24c8:	b9401e60 	ldr	w0, [x19, #28]		; word2
ffff24cc:	d0ffc661 	adrp	x1, 0xff8c0000
ffff24d0:	b9001020 	str	w0, [x1, #16]
ffff24d4:	b9401a60 	ldr	w0, [x19, #24]		; word1
ffff24d8:	340013a0 	cbz	w0, 0xffff274c		; return on branch
; -- the above return never happens

ffff24dc:	2a1f03f4 	mov	w20, wzr
ffff24e0:	90ffc69a 	adrp	x26, 0xff8c2000		; SRAM load address
ffff24e4:	d0ffc677 	adrp	x23, 0xff8c0000		; SRAM start

; loop to here
ffff24e8:	f9400a63 	ldr	x3, [x19, #16]
ffff24ec:	91000355 	add	x21, x26, #0x0
ffff24f0:	910073e2 	add	x2, sp, #0x1c
ffff24f4:	aa1403e0 	mov	x0, x20
ffff24f8:	aa1503e1 	mov	x1, x21
ffff24fc:	d63f0060 	blr	x3
ffff2500:	7100001f 	cmp	w0, #0x0
ffff2504:	5400124b 	b.lt	0xffff274c		; return
ffff2508:	350011a0 	cbnz	w0, 0xffff273c
ffff250c:	b9400340 	ldr	w0, [x26]
ffff2510:	f0000001 	adrp	x1, 0xffff5000
ffff2514:	b9412021 	ldr	w1, [x1, #0x120]
ffff2518:	6b21401f 	cmp	w0, w1, uxtw
ffff251c:	54001101 	b.ne	0xffff273c  // b.any
ffff2520:	52804001 	mov	w1, #0x200                 	// #512
ffff2524:	aa1503e0 	mov	x0, x21
ffff2528:	9400062c 	bl	0xffff3dd8		; uncrypt ( x21, 0x200 )
ffff252c:	b9401fe0 	ldr	w0, [sp, #28]
ffff2530:	79c3faa2 	ldrsh	w2, [x21, #0x1fc]
ffff2534:	79401aa1 	ldrh	w1, [x21, #12]
ffff2538:	12003c43 	and	w3, w2, #0xffff
ffff253c:	7943f6a4 	ldrh	w4, [x21, #0x1fa]
ffff2540:	7100147f 	cmp	w3, #0x5
ffff2544:	1a9f27e5 	cset	w5, cc  // cc = lo, ul, last
ffff2548:	7100005f 	cmp	w2, #0x0
ffff254c:	1a9fa7e2 	cset	w2, lt  // lt = tstop
ffff2550:	2a0200a2 	orr	w2, w5, w2
ffff2554:	52800025 	mov	w5, #0x1                   	// #1
ffff2558:	6a05005f 	tst	w2, w5
ffff255c:	52800142 	mov	w2, #0xa                   	// #10
ffff2560:	1a83105b 	csel	w27, w2, w3, ne  // ne = any
ffff2564:	51001082 	sub	w2, w4, #0x4
ffff2568:	12003c42 	and	w2, w2, #0xffff
ffff256c:	710ff45f 	cmp	w2, #0x3fd
ffff2570:	1a9f27e2 	cset	w2, cc  // cc = lo, ul, last
ffff2574:	6b3b409f 	cmp	w4, w27, uxtw
ffff2578:	1a9f87e3 	cset	w3, ls  // ls = plast
ffff257c:	0a020062 	and	w2, w3, w2
ffff2580:	52800063 	mov	w3, #0x3                   	// #3
ffff2584:	6a03009f 	tst	w4, w3
ffff2588:	1a9f17e3 	cset	w3, eq  // eq = none
ffff258c:	0a030042 	and	w2, w2, w3
ffff2590:	6a05005f 	tst	w2, w5
ffff2594:	52800082 	mov	w2, #0x4                   	// #4
ffff2598:	1a821082 	csel	w2, w4, w2, ne  // ne = any
ffff259c:	d0ffc663 	adrp	x3, 0xff8c0000
ffff25a0:	b9001460 	str	w0, [x3, #20]
ffff25a4:	34000b7b 	cbz	w27, 0xffff2710
ffff25a8:	2a1f03fc 	mov	w28, wzr
ffff25ac:	b9400aa3 	ldr	w3, [x21, #8]
ffff25b0:	12000079 	and	w25, w3, #0x1
ffff25b4:	1280ffe3 	mov	w3, #0xfffff800            	// #-2048
ffff25b8:	0b022463 	add	w3, w3, w2, lsl #9
ffff25bc:	f9000be3 	str	x3, [sp, #16]
ffff25c0:	51001043 	sub	w3, w2, #0x4
ffff25c4:	b9001be3 	str	w3, [sp, #24]
ffff25c8:	4b224362 	sub	w2, w27, w2, uxtw
ffff25cc:	53175842 	lsl	w2, w2, #9
ffff25d0:	f90007e2 	str	x2, [sp, #8]
ffff25d4:	0b214016 	add	w22, w0, w1, uxtw
ffff25d8:	aa1503f8 	mov	x24, x21
ffff25dc:	f9400663 	ldr	x3, [x19, #8]
ffff25e0:	0b3c42c0 	add	w0, w22, w28, uxtw
ffff25e4:	52810002 	mov	w2, #0x800                 	// #2048
ffff25e8:	aa1803e1 	mov	x1, x24
ffff25ec:	d63f0060 	blr	x3
ffff25f0:	35000a60 	cbnz	w0, 0xffff273c
ffff25f4:	350001b9 	cbnz	w25, 0xffff2628

; do something to four 512 byte sections
; so x24 must point to 2048 bytes of stuff
ffff25f8:	52804001 	mov	w1, #0x200
ffff25fc:	aa1803e0 	mov	x0, x24
ffff2600:	940005f6 	bl	0xffff3dd8		; uncrypt ( x24, 0x200 )
ffff2604:	91080300 	add	x0, x24, #0x200
ffff2608:	52804001 	mov	w1, #0x200
ffff260c:	940005f3 	bl	0xffff3dd8		; uncrypt ( x24+0x200, 0x200 )
ffff2610:	91100300 	add	x0, x24, #0x400
ffff2614:	52804001 	mov	w1, #0x200
ffff2618:	940005f0 	bl	0xffff3dd8		; uncrypt ( x24+0x400, 0x200 )
ffff261c:	91180300 	add	x0, x24, #0x600
ffff2620:	52804001 	mov	w1, #0x200
ffff2624:	940005ed 	bl	0xffff3dd8		; uncrypt ( x24+0x600, 0x200 )

ffff2628:	b9400ee0 	ldr	w0, [x23, #12]
ffff262c:	3500015c 	cbnz	w28, 0xffff2654
ffff2630:	35000560 	cbnz	w0, 0xffff26dc
ffff2634:	b9400300 	ldr	w0, [x24]
ffff2638:	d0000001 	adrp	x1, 0xffff4000
ffff263c:	912e1021 	add	x1, x1, #0xb84
ffff2640:	b9400021 	ldr	w1, [x1]
ffff2644:	6b21401f 	cmp	w0, w1, uxtw
ffff2648:	540005e0 	b.eq	0xffff2704  // b.none
ffff264c:	2a1f03e0 	mov	w0, wzr
ffff2650:	14000003 	b	0xffff265c
ffff2654:	7100001f 	cmp	w0, #0x0
ffff2658:	1a9f07e0 	cset	w0, ne  // ne = any
ffff265c:	b9401be1 	ldr	w1, [sp, #24]
ffff2660:	6b3c403f 	cmp	w1, w28, uxtw
ffff2664:	54000301 	b.ne	0xffff26c4  // b.any
ffff2668:	36000100 	tbz	w0, #0, 0xffff2688

ffff266c:	52810001 	mov	w1, #0x800
ffff2670:	aa1803e0 	mov	x0, x24
ffff2674:	97fff7ac 	bl	0xffff0524		; crypto2

ffff2678:	d0ffc660 	adrp	x0, 0xff8c0000
ffff267c:	9100d000 	add	x0, x0, #0x34
ffff2680:	97fff7ce 	bl	0xffff05b8		; crypto4

ffff2684:	350005c0 	cbnz	w0, 0xffff273c
ffff2688:	b9400340 	ldr	w0, [x26]
ffff268c:	d0000001 	adrp	x1, 0xffff4000
ffff2690:	9139a021 	add	x1, x1, #0xe68
ffff2694:	b9400021 	ldr	w1, [x1]
ffff2698:	6b21401f 	cmp	w0, w1, uxtw
ffff269c:	54000501 	b.ne	0xffff273c  // b.any
ffff26a0:	910012a0 	add	x0, x21, #0x4
ffff26a4:	d63f0000 	blr	x0
ffff26a8:	350004a0 	cbnz	w0, 0xffff273c
ffff26ac:	b9400ee0 	ldr	w0, [x23, #12]
ffff26b0:	34000060 	cbz	w0, 0xffff26bc
ffff26b4:	f94007e0 	ldr	x0, [sp, #8]
ffff26b8:	97fff787 	bl	0xffff04d4		; crypto_set_hash_len
ffff26bc:	aa1f03f8 	mov	x24, xzr
ffff26c0:	14000011 	b	0xffff2704
ffff26c4:	36000080 	tbz	w0, #0, 0xffff26d4

ffff26c8:	52810001 	mov	w1, #0x800
ffff26cc:	aa1803e0 	mov	x0, x24
ffff26d0:	97fff795 	bl	0xffff0524		; crypto2

ffff26d4:	91200318 	add	x24, x24, #0x800
ffff26d8:	1400000b 	b	0xffff2704
ffff26dc:	aa1803e0 	mov	x0, x24
ffff26e0:	97fff6fb 	bl	0xffff02cc
ffff26e4:	350002c0 	cbnz	w0, 0xffff273c
ffff26e8:	910c8301 	add	x1, x24, #0x320
ffff26ec:	d0ffc660 	adrp	x0, 0xff8c0000
ffff26f0:	9100d000 	add	x0, x0, #0x34
ffff26f4:	d2800882 	mov	x2, #0x44                  	// #68
ffff26f8:	94000756 	bl	0xffff4450	; memcpy
ffff26fc:	f9400be0 	ldr	x0, [sp, #16]
ffff2700:	97fff775 	bl	0xffff04d4		; crypto_set_hash_len
ffff2704:	1100139c 	add	w28, w28, #0x4
ffff2708:	6b3b439f 	cmp	w28, w27, uxtw
ffff270c:	54fff683 	b.cc	0xffff25dc  // b.lo, b.ul, b.last
ffff2710:	d0ffc660 	adrp	x0, 0xff8c0000
ffff2714:	b9400c00 	ldr	w0, [x0, #12]
ffff2718:	340000e0 	cbz	w0, 0xffff2734
ffff271c:	d0ffc660 	adrp	x0, 0xff8c0000
ffff2720:	9100d000 	add	x0, x0, #0x34
ffff2724:	91009000 	add	x0, x0, #0x24
ffff2728:	97fff7a4 	bl	0xffff05b8		; crypto4
ffff272c:	35000080 	cbnz	w0, 0xffff273c
ffff2730:	97fff6b0 	bl	0xffff01f0

; I can't see how this would be good (jumping to address 0)
ffff2734:	aa1f03e0 	mov	x0, xzr
ffff2738:	940007d8 	bl	0xffff4698		; Go to x0 !?

ffff273c:	b9401a60 	ldr	w0, [x19, #24]
ffff2740:	11000694 	add	w20, w20, #0x1
ffff2744:	6b20429f 	cmp	w20, w0, uxtw
ffff2748:	54ffed03 	b.cc	0xffff24e8  // b.lo, b.ul, b.last

ffff274c:	a94253f3 	ldp	x19, x20, [sp, #32]
ffff2750:	a9435bf5 	ldp	x21, x22, [sp, #48]
ffff2754:	a94463f7 	ldp	x23, x24, [sp, #64]
ffff2758:	a9456bf9 	ldp	x25, x26, [sp, #80]
ffff275c:	a94673fb 	ldp	x27, x28, [sp, #96]
ffff2760:	a9477bfd 	ldp	x29, x30, [sp, #112]
ffff2764:	910203ff 	add	sp, sp, #0x80
ffff2768:	d65f03c0 	ret

; END of try_abc ()

; =============================
; subroutine - try_four ()
;  one call during initialization.
;  if this doesn't work, we dive into usb_spin forever.

ffff276c:	d10083ff 	sub	sp, sp, #0x20
ffff2770:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff2774:	910043fd 	add	x29, sp, #0x10
ffff2778:	a90053f3 	stp	x19, x20, [sp]

ffff277c:	d0000000 	adrp	x0, 0xffff4000
ffff2780:	912e2013 	add	x19, x0, #0xb88		; pointer to table below
ffff2784:	52800094 	mov	w20, #0x4		; loop 4 times

; loop
ffff2788:	f9400260 	ldr	x0, [x19]		; get first entry
ffff278c:	d63f0000 	blr	x0			; call that function
ffff2790:	35000060 	cbnz	w0, 0xffff279c
ffff2794:	aa1303e0 	mov	x0, x19
ffff2798:	97ffff43 	bl	0xffff24a4		; try_abc ( table[i] )
ffff279c:	91008273 	add	x19, x19, #0x20
ffff27a0:	51000694 	sub	w20, w20, #0x1
ffff27a4:	35ffff34 	cbnz	w20, 0xffff2788		; loop 4 times

ffff27a8:	a94053f3 	ldp	x19, x20, [sp]
ffff27ac:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff27b0:	910083ff 	add	sp, sp, #0x20
ffff27b4:	d65f03c0 	ret

; Here is a copy of the block of information that drives the above.
;	ffff4b88: 00000000 ffff0d40
;	ffff4b90: 00000000 ffff1184
;	ffff4b98: 00000000 ffff11ec
;	ffff4ba0: 00000003 0000000d
;	
;	ffff4ba8: 00000000 ffff0e3c
;	ffff4bb0: 00000000 ffff1184
;	ffff4bb8: 00000000 ffff11ec
;	ffff4bc0: 00000004 0000000d
;	
;	ffff4bc8: 00000000 ffff13e4
;	ffff4bd0: 00000000 ffff12d0
;	ffff4bd8: 00000000 ffff136c
;	ffff4be0: 00000002 00000005
;	
;	ffff4be8: 00000000 ffff17a4
;	ffff4bf0: 00000000 ffff237c
;	ffff4bf8: 00000000 ffff2428
;	ffff4c00: 00000005 00000005

; =================================================================
; =================================================================
;
;     USB stuff follows
;
; =================================================================
; =================================================================

; Here are some high level notes on the USB subsystem that follows.

; endpoints --
;  This seems to only use EP0-OUT and EP0-IN
;  The spec says that endpoint 0 should only be used
;   for control transfers.  This firmware seems to happily
;   kick that to the curb.  And I am OK with that, since it
;   all seems to work.  I have run into this before frankly.
;  Also endpoints only exist in devices, never in hosts.
;   just for the record, that is of no relevance here
;  What is relevant is that IN and OUT are from the view
;   of the host.  So, this being a device, we use the IN
;   endpoint to send stuff and the OUT endpoint to receive.
;   This is a classic point of confusion.
;
; data structures
;  "usb" is the key data structure
;    (I should have called it U or U-sram)
;  I have chosen my own names for things
;  namely X, Y, A, B, C, J, K, L
;  I usually append A-sram which is helpful on searches
;  so I don't land on every capital letter in this file
;
;  B is the event buffer, and A is used to manage it
;  X manages the EP0-OUT endpoint (which receives for us)
;  Y manages the EP0-IN endpoint (which we use to send)

; How does the game start?
;
; there can be various connects and resets at first
; the first transaction involving data will be when
; the host sends a "Get Descriptor"
; we will need to respond to this.
; The host then is likely to send a "Set Address"

; =================================================================

; subroutine -  "usb_init"
;
; fe80xxxx is USB_OTG0 hardare

ffff27b8:	d10083ff 	sub	sp, sp, #0x20
ffff27bc:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff27c0:	910043fd 	add	x29, sp, #0x10
ffff27c4:	a90053f3 	stp	x19, x20, [sp]

; an undocumented register in PMU_SGRF
ffff27c8:	f0000000 	adrp	x0, 0xffff5000
ffff27cc:	b9412400 	ldr	w0, [x0, #0x124]	; ffff5124: ff33e014
ffff27d0:	52a60001 	mov	w1, #0x30000000
ffff27d4:	b9000001 	str	w1, [x0]

; set up what we call "usb"
; this is an area 128 bytes in size at SRAM + 0x370
; the base is commonly (but not always) held in x19
; throughout this usb software
ffff27d8:	d0ffc660 	adrp	x0, 0xff8c0000
ffff27dc:	910dc013 	add	x19, x0, #0x370		; SRAM + 0x370

ffff27e0:	d2801002 	mov	x2, #0x80
ffff27e4:	aa1303e0 	mov	x0, x19
ffff27e8:	aa1f03e1 	mov	x1, xzr
ffff27ec:	94000724 	bl	0xffff447c		; memset ( "usb", 0x80, 0 )

; This fetches the USB hardware base address
ffff27f0:	f0000000 	adrp	x0, 0xffff5000
ffff27f4:	b9412800 	ldr	w0, [x0, #0x128]	; ffff5128: fe80c100

ffff27f8:	f9002660 	str	x0, [x19, #0x48]	; "usb" + 48 = usb_hw

; We set this to 3 here and
; reference it in one place to set USB high speed
ffff27fc:	52800060 	mov	w0, #0x3
ffff2800:	b9005660 	str	w0, [x19, #0x54]	; usb_54 = 3

; This starts out set to 0
; later gets set to 5, 6, or 7
ffff2804:	b900627f 	str	wzr, [x19, #0x60]	; pete = 0

; now another small block "sram-A"
;
;	A + 0 = B (8 byte addr)
;	A = 8 = 0x100 (size of B)
;	A + 16 = 0
;	A + 20 = 0
;	A + 24 = B (8 byte addr) - a second pointer which is never used
;	A + 32 = "usb"
;
; We don't save any pointers to A anywhere, we just "know"
; it is at SRAM + 0x410
;
; This is entirely about managing the event buffer (which is B)
; It is manipulated mostly in usb_run, but also by usb_one
; The value at 20 can be set to a flag value of 1, but this seems useless
; The second pointer to B at offset 24 is never used as far as I can see
; Why these fields were not simply added to "usb" I cannot say.
; that is what I would have done.

ffff2808:	d0ffc661 	adrp	x1, 0xff8c0000
ffff280c:	91104034 	add	x20, x1, #0x410		; SRAM + 0x410 "sram-A"
ffff2810:	f9000a9f 	str	xzr, [x20, #16]		; clear 8 bytes
ffff2814:	f900069f 	str	xzr, [x20, #8]		; this clears 12 also
ffff2818:	f902083f 	str	xzr, [x1, #0x410]	; will be overwritten by B

; we set this, but never use it anywhere
ffff281c:	52800020 	mov	w0, #0x1
ffff2820:	b9005260 	str	w0, [x19, #0x50]	; "usb" + 0x50 = 1

ffff2824:	f9001293 	str	x19, [x20, #32]		; "usb"

ffff2828:	52802000 	mov	w0, #0x100
ffff282c:	b9000a80 	str	w0, [x20, #8]		; size of B, which follows

; and a big area "sram-B" (this is the USB event buffer)
; 0x100 bytes in size.
; we save 2 pointers to it in "A" above
; we never access it directly, but only via the "A" pointers
;
; it is 256 bytes in size, and each event is 4 bytes, so this
; will hold 64 events.

ffff2830:	d0ffc660 	adrp	x0, 0xff8c0000
ffff2834:	91084000 	add	x0, x0, #0x210		; SRAM + 0x210
ffff2838:	f9000e80 	str	x0, [x20, #24]		; A + 24 (8 bytes)
ffff283c:	f9020820 	str	x0, [x1, #0x410]	; A + 0  (8 bytes)

ffff2840:	d2802002 	mov	x2, #0x100
ffff2844:	aa1f03e1 	mov	x1, xzr
ffff2848:	9400070d 	bl	0xffff447c		; memset ( x0, 0x100, 0 )

; This fetches another USB hardware base address (0xc704)
; This is the USB device control register.
; The bit set is "core soft reset" and is self clearing.
; See trm2 page 147
; it is a bit odd that this address is fetched from a stored value
; rather than being generated via an offset from x19,
; (as is done a few lines further along).
; But it seems to be a one time thing, and who cares really.

ffff284c:	f0000000 	adrp	x0, 0xffff5000
ffff2850:	b9412c00 	ldr	w0, [x0, #0x12c]	; ffff512c: fe80c704
ffff2854:	52a80001 	mov	w1, #0x40000000
ffff2858:	b9000001 	str	w1, [x0]		; write to USB hw

ffff285c:	f9402660 	ldr	x0, [x19, #0x48]	; get USB_48 (base)

; Now a timeout loop waiting for that
; self clearning bit to clear
ffff2860:	928270e2 	mov	x2, #0xffffffffffffec78    	// #-5000
; loop start
ffff2864:	aa0203e1 	mov	x1, x2
ffff2868:	b4000081 	cbz	x1, 0xffff2878

; Here is another way to get the USB device control register at 0xc704
ffff286c:	b9460403 	ldr	w3, [x0, #0x604]	; USB dctrl
ffff2870:	91000422 	add	x2, x1, #0x1
ffff2874:	37f7ff83 	tbnz	w3, #30, 0xffff2864	; loop

; reset is finished
; if we did timeout (reset failed) bypass
; the rest of USB initialization
ffff2878:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff287c:	b100043f 	cmn	x1, #0x1
ffff2880:	54000a20 	b.eq	0xffff29c4  // b.none

; 0xc110 is global core control
;  assert core soft reset
ffff2884:	f9402660 	ldr	x0, [x19, #0x48]	; 0xc100
ffff2888:	b9401001 	ldr	w1, [x0, #16]		; read from c110
ffff288c:	32150021 	orr	w1, w1, #0x800
ffff2890:	b9001001 	str	w1, [x0, #16]

; 0xc2c0 is pipe control register 0
;  assert PHY soft reset
ffff2894:	f9402660 	ldr	x0, [x19, #0x48]
ffff2898:	b941c001 	ldr	w1, [x0, #0x1c0]
ffff289c:	32010021 	orr	w1, w1, #0x80000000
ffff28a0:	b901c001 	str	w1, [x0, #0x1c0]

; 0xc200 is USB2 PHY config register 0
; asset UTMI phy soft reset
ffff28a4:	f9402660 	ldr	x0, [x19, #0x48]
ffff28a8:	b9410001 	ldr	w1, [x0, #0x100]
ffff28ac:	32010021 	orr	w1, w1, #0x80000000
ffff28b0:	b9010001 	str	w1, [x0, #0x100]

ffff28b4:	52800c80 	mov	w0, #0x64
ffff28b8:	97fff874 	bl	0xffff0a88		; mmdelay ( 100 )

; 0xc2c0 is pipe control register 0
; clear the PHY reset bit
ffff28bc:	f9402660 	ldr	x0, [x19, #0x48]
ffff28c0:	b941c001 	ldr	w1, [x0, #0x1c0]
ffff28c4:	12007821 	and	w1, w1, #0x7fffffff
ffff28c8:	b901c001 	str	w1, [x0, #0x1c0]

; 0xc200 is USB2 PHY config register 0
; clear the PHY reset bit
ffff28cc:	f9402660 	ldr	x0, [x19, #0x48]
ffff28d0:	b9410001 	ldr	w1, [x0, #0x100]
ffff28d4:	12007821 	and	w1, w1, #0x7fffffff
ffff28d8:	b9010001 	str	w1, [x0, #0x100]

ffff28dc:	52800c80 	mov	w0, #0x64
ffff28e0:	97fff86a 	bl	0xffff0a88		; mmdelay ( 100 )

; 0xc110 is global core control
; clear the soft reset bit
ffff28e4:	f9402660 	ldr	x0, [x19, #0x48]
ffff28e8:	b9401001 	ldr	w1, [x0, #16]
ffff28ec:	12147821 	and	w1, w1, #0xfffff7ff
ffff28f0:	b9001001 	str	w1, [x0, #16]

; also clear scale-down and scrambling
ffff28f4:	f9402660 	ldr	x0, [x19, #0x48]
ffff28f8:	b9401001 	ldr	w1, [x0, #16]
ffff28fc:	121a7021 	and	w1, w1, #0xffffffc7
ffff2900:	b9001001 	str	w1, [x0, #16]

; This is the only reference.  It is set to 3 at initialization
ffff2904:	b9405660 	ldr	w0, [x19, #0x54]	; fetch 3
ffff2908:	71000c1f 	cmp	w0, #0x3
ffff290c:	540000a1 	b.ne	0xffff2920  // b.any

; 0xc11c is global user control
; This bit forces 2.0 clock for 3.0 clock
ffff2910:	f9402660 	ldr	x0, [x19, #0x48]
ffff2914:	b9401c01 	ldr	w1, [x0, #28]
ffff2918:	32060021 	orr	w1, w1, #0x4000000
ffff291c:	b9001c01 	str	w1, [x0, #28]

; 0xc2c0 is pipe control register 0
; this bit suspends USB 3 PHY
ffff2920:	f9402660 	ldr	x0, [x19, #0x48]
ffff2924:	b941c001 	ldr	w1, [x0, #0x1c0]
ffff2928:	320f0021 	orr	w1, w1, #0x20000
ffff292c:	b901c001 	str	w1, [x0, #0x1c0]

ffff2930:	52800c80 	mov	w0, #0x64
ffff2934:	97fff855 	bl	0xffff0a88		; mmdelay ( 100 )

; 0xc200 is USB2 PHY config register 0
; clear bit 30 (freeclk exists bit)
; bits 13:10 are turnaround time (set to 5) for 15 bit UTMI+
; clear bit 8 (enable utmi sleep)
; set bit 3 (select 16 bit PHY)
ffff2938:	f9402660 	ldr	x0, [x19, #0x48]	; usb_hw
ffff293c:	b9410001 	ldr	w1, [x0, #0x100]
ffff2940:	f0000002 	adrp	x2, 0xffff5000
ffff2944:	b9413042 	ldr	w2, [x2, #0x130]	; ffff5130: bfffc2f7
ffff2948:	0a020021 	and	w1, w1, w2
ffff294c:	52828102 	mov	w2, #0x1408                	// #5128
ffff2950:	2a020021 	orr	w1, w1, w2
ffff2954:	b9010001 	str	w1, [x0, #0x100]

ffff2958:	52800c80 	mov	w0, #0x64
ffff295c:	97fff84b 	bl	0xffff0a88		; mmdelay ( 100 )

ffff2960:	b9000e9f 	str	wzr, [x20, #12]		; A+12 = 0

; Write 4 bytes to C400 ... copied from SRAM
; 0xc400 is event buffer addr, low 32 bits
; 0xc404 is event buffer addr, high 32 bits
; 0xc408 is event buffer size in bytes
; 0xc40c is event buffer count in bytes
;
; We copy the address of block "sram-B" above,
;  we copy the 64 bit address in 2 pieces

; which is apparently the event buffer, of size 0x100

ffff2964:	f9402660 	ldr	x0, [x19, #0x48]	; usb_hw
ffff2968:	f9400e81 	ldr	x1, [x20, #24]		; from sram-A+24 (B)
ffff296c:	b9030001 	str	w1, [x0, #0x300]

ffff2970:	f9402660 	ldr	x0, [x19, #0x48]
ffff2974:	b9401e81 	ldr	w1, [x20, #28]		; sram-A+28
ffff2978:	b9030401 	str	w1, [x0, #0x304]

; set the size from 2 bytes
; note that we write this as 4, but little endian
; lets us read it as 2 just fine.
ffff297c:	f9402660 	ldr	x0, [x19, #0x48]
ffff2980:	79401281 	ldrh	w1, [x20, #8]		; sram-A+8 (initially 0x100)
ffff2984:	b9030801 	str	w1, [x0, #0x308]

ffff2988:	f9402660 	ldr	x0, [x19, #0x48]
ffff298c:	b9030c1f 	str	wzr, [x0, #0x30c]	; count = 0

; 0xc110 is global core control
; set port capability direction
; We set b10 for device rather than host
ffff2990:	f9402660 	ldr	x0, [x19, #0x48]
ffff2994:	b9401001 	ldr	w1, [x0, #16]
ffff2998:	12127421 	and	w1, w1, #0xffffcfff
ffff299c:	32130021 	orr	w1, w1, #0x2000
ffff29a0:	b9001001 	str	w1, [x0, #16]

ffff29a4:	aa1303e0 	mov	x0, x19
ffff29a8:	94000392 	bl	0xffff37f0	; usb_mem_setup ( "usb" )
ffff29ac:	aa1303e0 	mov	x0, x19
ffff29b0:	940002f1 	bl	0xffff3574	; usb_init2 ( "usb" )
ffff29b4:	52800021 	mov	w1, #0x1
ffff29b8:	aa1303e0 	mov	x0, x19
ffff29bc:	940002c8 	bl	0xffff34dc	; usb_start ( "usb", 1 )
ffff29c0:	2a1f03e0 	mov	w0, wzr

; done
ffff29c4:	a94053f3 	ldp	x19, x20, [sp]
ffff29c8:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff29cc:	910083ff 	add	sp, sp, #0x20
ffff29d0:	d65f03c0 	ret

# END of usb_init

; =====================

;  usb_start_transfer_x ( "usb" )

; This is called during initialization.
; It sets up the first ever transfer.
; This is on X (EP0_OUT) which is how we receive from the host.

; called from one place below -- 
; this basically sets up the registers as
; if we were calling usb_start_transfer(), but we fall through into it.

ffff29d4:	f9400c02 	ldr	x2, [x0, #24]	; sram-J
ffff29d8:	52800103 	mov	w3, #0x8
ffff29dc:	52800404 	mov	w4, #0x20
ffff29e0:	aa1f03e1 	mov	x1, xzr
ffff29e4:	aa1f03e5 	mov	x5, xzr

; a second argument of 0 locks this to X (EP0-OUT)
; We receive EP0_OUT transfers in sram-J (64 bytes in size)

; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )
; usb_start_transfer ( "usb", 0, J, 8, 0x20, 0 )

ffff29e8:	14000001 	b	0xffff29ec		; usb_start_transfer ()
; The above branch is sort of silly

; ============================================================================================

; subroutine usb_start_transfer ()
; note that we have the odd "fall through" from above

; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, arg_flag )

; arguments:
;   x0 = "usb"
;   x1 = endpoint index (0 or 1)
;   x2 = buf
;   w3 = A = size
;   x4 = B = ctrl
;   x5 = arg_flag -- 0 or 1

; size can be 0.  It is often 8.

; a typical call is:
; usb_start_transfer ( "usb", 0, usb+24 (sram-J), 8, 0x20, 0 )

ffff29ec:	d100c3ff 	sub	sp, sp, #0x30		; prolog
ffff29f0:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff29f4:	910083fd 	add	x29, sp, #0x20
ffff29f8:	a90153f3 	stp	x19, x20, [sp, #16]

; x1 (endpoint index) will be either 0 or 1
; this does some trickery to get X/Y and put it in x20
; note that the add shifts the byte in w1 by 3 (a multiply by 8)
; then zero extends (uxtb) the result.

ffff29fc:	aa0003f3 	mov	x19, x0			; x19 = "usb"

; calculate X/Y from endpoint index
ffff2a00:	8b210e60 	add	x0, x19, w1, uxtb #3
ffff2a04:	f9401c14 	ldr	x20, [x0, #0x38]	; x20 = X/Y

; Check this bit 0x10 bit 4 and if it is set, skip the whole game.
; Note that this bit is set at the end of this code.
; It must be some kind of "transfer in progress" flag (TIP)
;    if so, where is it cleared?

ffff2a08:	39406280 	ldrb	w0, [x20, #24]		; "sue"
ffff2a0c:	37200860 	tbnz	w0, #4, 0xffff2b18	; return if TIP set

; This business of the counter in [x20] is somewhat surprising.
; it seems that it would count along forever
; and cause us to offset into K further and further along.
;  K is only 32 bytes in size.

; call this counter "trb_slot"
; it does get set back to 0 when usb_one() handles a "xfer complete"
; apparently it is only possible to have at most 2 pending transfers.

ffff2a10:	b9400286 	ldr	w6, [x20]		; counter from X/Y + 0 (trb_slot)
ffff2a14:	f9400660 	ldr	x0, [x19, #8]		; sram-K
ffff2a18:	53007cc1 	lsr	w1, w6, #0		; w1 = w6 (trb_slot)

; test arg_flag (usually 0, sometimes 1)
; if it is 1, increment the counter in X/Y and store for next time
; so the TRB set up by the next call goes in the next slot

ffff2a1c:	34000065 	cbz	w5, 0xffff2a28
ffff2a20:	110004c6 	add	w6, w6, #0x1		; w6++  (trb_slot++)
ffff2a24:	b9000286 	str	w6, [x20]

; we will now use the non-incremented counter
; (this could have been incremented by a previous call)
ffff2a28:	8b217006 	add	x6, x0, x1, uxtx #4	; x6 = sram-K + count<<4
ffff2a2c:	d37cec21 	lsl	x1, x1, #4		; count *= 16

; x0 = base of sram-K
; x1 = either 0 or 16
; x2 = buf passed as argument
; x6 = either sram-K or sram-K+16

; in truth we don't need both x1 and x6, but the code is fickle
; and uses either at different times.

; We are going to move the 64 bit address in x2, byte by byte into sram-K
; x0 points to sram-K at the very start
; x6 is offset into sram-K by count*16
; let's denote that offset location "KK"
; 
; All told we move 16 bytes into K, which is 32 bytes in size.
; if count is anything other than 0 or 1, we are in trouble,
; but I don't see any guard against that here.

; So, after some research and analysis, here is what is going on here.
; These 16 bit objects are "trb" objects (transfer request blocks)
;
; If we had the synology documents we would know more about them.
; They have 4 32 bit objects like this
;   bpl = low 32 bits of buffer address
;   bph = high 32 bits of buffer address
;   size
;   ctrl = tricky undocumented bits

; move w2 (buf) 8 bytes
ffff2a30:	38216802 	strb	w2, [x0, x1]		; KK[0] = w2>>0
ffff2a34:	d358fc40 	lsr	x0, x2, #24		
ffff2a38:	39000cc0 	strb	w0, [x6, #3]		; kk[3] = x2>>24
ffff2a3c:	d350fc40 	lsr	x0, x2, #16
ffff2a40:	390008c0 	strb	w0, [x6, #2]		; kk[2] = x2>>16
ffff2a44:	d348fc40 	lsr	x0, x2, #8
ffff2a48:	390004c0 	strb	w0, [x6, #1]		; kk[1] = x2>>8
ffff2a4c:	d360fc40 	lsr	x0, x2, #32
ffff2a50:	d378fc41 	lsr	x1, x2, #56
ffff2a54:	39001cc1 	strb	w1, [x6, #7]		; kk[7] = x2>>56
ffff2a58:	d370fc41 	lsr	x1, x2, #48
ffff2a5c:	390018c1 	strb	w1, [x6, #6]		; kk[6] = x2>>48
ffff2a60:	d368fc41 	lsr	x1, x2, #40
ffff2a64:	390014c1 	strb	w1, [x6, #5]		; kk[5] = x2>>40
ffff2a68:	390010c0 	strb	w0, [x6, #4]		; kk[4] = x2>>32

; move w3 (size) 4 bytes
ffff2a6c:	53187c60 	lsr	w0, w3, #24
ffff2a70:	39002cc0 	strb	w0, [x6, #11]		; kk[11] = w3>>24
ffff2a74:	53107c60 	lsr	w0, w3, #16
ffff2a78:	390028c0 	strb	w0, [x6, #10]		; kk[10] = w3>>16
ffff2a7c:	53087c60 	lsr	w0, w3, #8
ffff2a80:	390024c0 	strb	w0, [x6, #9]		; kk[9] = w3<<8
ffff2a84:	390020c3 	strb	w3, [x6, #8]		; kk[8] = w3<<0

; Now reference arg_flag again (either 0 or 1)
ffff2a88:	710000bf 	cmp	w5, #0x0
ffff2a8c:	52818060 	mov	w0, #0xc03		; xxx = 0xc03 for flag == 0
ffff2a90:	528080a1 	mov	w1, #0x405		; XXX = 0x405 for flag == 1
ffff2a94:	1a801020 	csel	w0, w1, w0, ne

; The above sets the basic "ctrl" bits in the TRB
;  there is a command in the middle (shifted left 4 bits)
;  that we get from the call arguments and OR into the middle of these
;
;  arg_flag == 0 --  0xc03 = 1100_0000_0011  
;  arg_flag == 1 --  0x405 = 0100_0000_0101  (chain bit set)
;
; bit 0 = HWO -- who knows, always set
; bit 1 = LST
; bit 2 = CHN - "chain"
; bit 3 = CSP - never used here
; bits 4 ... 9 "mode" (see below)
; bit 10 = ISP_IMI -- always set
; bit 11 = IOC -- "interrupt on completion"

; The "mode" command arguments I see are:
;   0x20 (i.e. 2) -- control setup
;   0x50 (i.e. 5) -- control data
;   0x30 + x == control status2
;
; this information is gleaned from the unix driver at drivers/usb/dwc3

; We combine either 0xc03 or 0x405 with arg B and put the result in w0
; Then this result (as a 32 bit item) goes into the K block

ffff2a98:	2a040000 	orr	w0, w0, w4		; w0 = "arg B" | xxx

ffff2a9c:	53187c01 	lsr	w1, w0, #24
ffff2aa0:	39003cc1 	strb	w1, [x6, #15]		; kk[15] = w0>>24
ffff2aa4:	53107c01 	lsr	w1, w0, #16
ffff2aa8:	390038c1 	strb	w1, [x6, #14]		; kk[14] = w0>>16
ffff2aac:	53087c01 	lsr	w1, w0, #8
ffff2ab0:	390034c1 	strb	w1, [x6, #13]		; kk[13] = w0>>8
ffff2ab4:	390030c0 	strb	w0, [x6, #12]		; kk[12] = w0>>0

; Now we have constructed a 16 byte block of stuff in one of the
; two slots in sram-K and we have

; We return here if arg_flag argument is 1
; This surprised and perplexed me at first, but now I understand.
; When we call this routine with arg_flag == 1, we set up a TRB
; with the chain bit set, and leave it waiting for a subsequent call with arg_flag == 0
; The second call will load the second TRB slot, then the call below
; will pass the address of the first TRB to the start_transfer call.
; It all makes sense.
;
; both calls that get chained are in usb_xfer4()

ffff2ab8:	35000305 	cbnz	w5, 0xffff2b18		; return if arg_flag != 0

; Now we construct a 3 word param block on the stack
; It simply holds a pointer to the sram-K block we just built
: Important: this holds the unmolested base of K,
; not the possibly incremented place where we just built
; a second TRB

ffff2abc:	b90003ff 	str	wzr, [sp]		; param[0] = 0
ffff2ac0:	f9401260 	ldr	x0, [x19, #32]		; sram-K address
ffff2ac4:	d360fc01 	lsr	x1, x0, #32
ffff2ac8:	910003e3 	mov	x3, sp			; addr of params
ffff2acc:	b9000861 	str	w1, [x3, #8]		; param[2] = upper 32 bits of sram-K
ffff2ad0:	b9000460 	str	w0, [x3, #4]		; param[1] = lower 32 bits of sram-K

ffff2ad4:	39408281 	ldrb	w1, [x20, #32]		; get endpoint index from X/Y
ffff2ad8:	528000c2 	mov	w2, #0x6		; cmd = 6 (start transfer)
ffff2adc:	aa1303e0 	mov	x0, x19			; "usb"
ffff2ae0:	9400022d 	bl	0xffff3394		; usb_endpoint_command ( "usb", ep_index, 6, params )

ffff2ae4:	7100001f 	cmp	w0, #0x0
ffff2ae8:	5400018b 	b.lt	0xffff2b18		; we failed !

; this location in X/Y has some bits
; this particular bit is checked up at the top of
; this routine, and if it is set, the entire routine
; is skipped.
; I call this bit TIP (transfer in progress)

ffff2aec:	b9401a80 	ldr	w0, [x20, #24]		; "sue"
ffff2af0:	321c0000 	orr	w0, w0, #0x10		; set bit 4 (TIP)
ffff2af4:	b9001a80 	str	w0, [x20, #24]		; "sue"

; Read a usb hw register offset from at c80c
; we calculate x0 = ep-index * 16, then use that
; as an offset to get the "endpoint-n command register
; for that endpoint.
; (there are command registers for each endpoint and we select the right one)

; We extract a 7 bit bitfield starting at 16
; i.e bits 22:16.
; This gives us the "transfer resource index"
; We store it to X/Y offset 0x22 (just a byte)

ffff2af8:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw
ffff2afc:	39408281 	ldrb	w1, [x20, #32]		; get ep index
ffff2b00:	8b217000 	add	x0, x0, x1, uxtx #4

ffff2b04:	b9470c00 	ldr	w0, [x0, #0x70c]	; read
ffff2b08:	53105800 	ubfx	w0, w0, #16, #7
ffff2b0c:	39008a80 	strb	w0, [x20, #0x22]	; usb transfer index

ffff2b10:	52800020 	mov	w0, #0x1
ffff2b14:	b9005a60 	str	w0, [x19, #0x58]	; jane = 1

; done
ffff2b18:	a94153f3 	ldp	x19, x20, [sp, #16]
ffff2b1c:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff2b20:	9100c3ff 	add	sp, sp, #0x30
ffff2b24:	d65f03c0 	ret

# END of usb_start_transfer

;  ==============================================================
;  ==============================================================
;  ==============================================================
;  ==============================================================

; ONE

; subroutine -- usb_one ( "usb", *event )

; this processes one event that usb_run pulled
;    out of the event buffer

;   HUGE !

;  only one call, from usb_run ()

; arguments:
;  --  pointer to "usb" in x0
;  --  pointer to a 32 value (which is an event)
;
; I don't know why the event itself was not passed
; since it is just a 32 bit object
;
; ubfx is "bitfield extract"
;	ubfx	w1, w0, #6, #4
;  the above would extract from w0 to w1
;  6 is the starting bit, 4 is the number of bits
;  i.e. 9:4 in this case
;  this is a nice way to replace the usual mask and shift
;  In C code, this would be:
;	dest = (src >> lsb) & ((1 << width) - 1);

ffff2b28:	d10143ff 	sub	sp, sp, #0x50
ffff2b2c:	a9047bfd 	stp	x29, x30, [sp, #64]
ffff2b30:	910103fd 	add	x29, sp, #0x40
ffff2b34:	a9035ff6 	stp	x22, x23, [sp, #48]
ffff2b38:	a90257f4 	stp	x20, x21, [sp, #32]
ffff2b3c:	f9000ff3 	str	x19, [sp, #24]

; copy the event pointer
ffff2b40:	aa0103f4 	mov	x20, x1

; copy the event itself
; this laborious 4 byte copy is to guard against bad alignment
; and is almost certainly not needed.
ffff2b44:	39400e81 	ldrb	w1, [x20, #3]
ffff2b48:	39400a82 	ldrb	w2, [x20, #2]
ffff2b4c:	39400683 	ldrb	w3, [x20, #1]
ffff2b50:	39400284 	ldrb	w4, [x20]

ffff2b54:	aa0003f3 	mov	x19, x0			; x19 = "usb"

ffff2b58:	2a012040 	orr	w0, w2, w1, lsl #8
ffff2b5c:	2a032081 	orr	w1, w4, w3, lsl #8
ffff2b60:	2a004020 	orr	w0, w1, w0, lsl #16

; This event has already been screened in usb_run ()
; The low bit is == 0
; We have already extracted and examined bits 5:1 (the endpoint index)
;
; Now we extract bits 9:6, which is "endpoint event".
; Here is the list:
;	 0x00    - Reserved
;	 0x01    - XferComplete
;	 0x02    - XferInProgress
;	 0x03    - XferNotReady
;	 0x04    - RxTxFifoEvt (IN->Underrun, OUT->Overrun)
;	 0x05    - Reserved
;	 0x06    - StreamEvt
;	 0x07    - EPCmdCmplt

; It turns out we only handle 3 and 1 here
; for all other cases, we just return

ffff2b64:	53062401 	ubfx	w1, w0, #6, #4

; ----------------------------------- ---------------------------------------
; ----------------------------------- ---------------------------------------

; From here, this routine handles the following cases:
;
;	A -- Xfer not ready with status short
;	B -- Xfer not ready but not with status short
;	C -- Xfer complete, xfer_code 1
;	D -- Xfer complete, xfer_code 2
;	E -- Xfer complete, xfer_code 3

; is it 1 ? (Xfer not Ready)
ffff2b68:	71000c3f 	cmp	w1, #0x3
ffff2b6c:	54000921 	b.ne	0xffff2c90

; -----------------------------------
; Handling a Xfer not Ready
; figure out if it is short or not

; A quick note on the field at 'usb' + 0x65 (lucy)
; this is used extensively in many routines
; We independently use 7 bits within it
; bit 0x80 is never used.

ffff2b70:	39419661 	ldrb	w1, [x19, #0x65]
ffff2b74:	321d0020 	orr	w0, w1, #0x8
ffff2b78:	39019660 	strb	w0, [x19, #0x65]	; lucy |= 0x8

; This seems downright stupid, why didn't we save
; the event from above?    Here we go again.
ffff2b7c:	39400e82 	ldrb	w2, [x20, #3]
ffff2b80:	39400a83 	ldrb	w3, [x20, #2]
ffff2b84:	39400684 	ldrb	w4, [x20, #1]
ffff2b88:	39400285 	ldrb	w5, [x20]
ffff2b8c:	2a022062 	orr	w2, w3, w2, lsl #8
ffff2b90:	2a0420a3 	orr	w3, w5, w4, lsl #8
ffff2b94:	2a024062 	orr	w2, w3, w2, lsl #16

; Now extract bits 15:12 from the event
; this is status
; the bits in status vary according to type.
ffff2b98:	530c3c43 	ubfx	w3, w2, #12, #4

; The "2" bit indicates "short"
ffff2b9c:	7100087f 	cmp	w3, #0x2
ffff2ba0:	54000ee1 	b.ne	0xffff2d7c

; ----------------------------------- ---------------------------------------
; ----------------------------------- ---------------------------------------

;	A -- Xfer not ready with status short

; "jane" is either 1 or 3
; this is the only place we test it
ffff2ba4:	b9405a61 	ldr	w1, [x19, #0x58]	; jane
ffff2ba8:	71000c3f 	cmp	w1, #0x3
ffff2bac:	54002981 	b.ne	0xffff30dc		return if ne 3

ffff2bb0:	52800061 	mov	w1, #0x3
ffff2bb4:	b9005e61 	str	w1, [x19, #0x5c]	; xfer_code = 3

ffff2bb8:	f9400261 	ldr	x1, [x19]		; sram-J

ffff2bbc:	39401422 	ldrb	w2, [x1, #5]		; assemble 16 bits
ffff2bc0:	39401021 	ldrb	w1, [x1, #4]
ffff2bc4:	2a022021 	orr	w1, w1, w2, lsl #8

; why this odd value ?
ffff2bc8:	7111c43f 	cmp	w1, #0x471		; 0x471 magic
ffff2bcc:	540000a0 	b.eq	0xffff2be0

ffff2bd0:	aa1303e0 	mov	x0, x19			; "usb"
ffff2bd4:	aa1403e1 	mov	x1, x20			; ptr to event
ffff2bd8:	94000147 	bl	0xffff30f4		; usb_xfer2 ( "usb" )

ffff2bdc:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff2be0:	36280440 	tbz	w0, #5, 0xffff2c68	; test 0x20

ffff2be4:	7940da60 	ldrh	w0, [x19, #0x6c]	; "joe"
ffff2be8:	12002c00 	and	w0, w0, #0xfff
ffff2bec:	340003e0 	cbz	w0, 0xffff2c68		; we only test "joe"

ffff2bf0:	f9400260 	ldr	x0, [x19]		; sram-J

ffff2bf4:	39401401 	ldrb	w1, [x0, #5]
ffff2bf8:	39401000 	ldrb	w0, [x0, #4]
ffff2bfc:	2a012000 	orr	w0, w0, w1, lsl #8	; assemble 16 bits

ffff2c00:	7111c81f 	cmp	w0, #0x472		; 0x472 magic
ffff2c04:	54000241 	b.ne	0xffff2c4c

; still in usb_one ()

; c40c is the "global event buffer count register 0"
;  the count is returned in bytes
;  if you write to it, it decrements the count by the value written

; the only thing we do here with sram-A is to post the event count
; all the action with sram-A is in usb_run

; reread the event count from hardware
ffff2c08:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw
ffff2c0c:	b9430c00 	ldr	w0, [x0, #0x30c]	; c40c
ffff2c10:	121e3400 	and	w0, w0, #0xfffc

ffff2c14:	d0ffc661 	adrp	x1, 0xff8c0000
ffff2c18:	91104021 	add	x1, x1, #0x410		; SRAM + 0x410 'sram-A'

; update the event count in sram-A + 16
ffff2c1c:	b9001020 	str	w0, [x1, #16]		: a+16 = event count

ffff2c20:	340000e0 	cbz	w0, 0xffff2c3c

ffff2c24:	f9402661 	ldr	x1, [x19, #0x48]	; usb_hw

; The following loop will remove a number of events (given by w0 just read)
; from hardware, so this would seem to flush the event buffer.
ffff2c28:	52800082 	mov	w2, #0x4

; loop
ffff2c2c:	51001000 	sub	w0, w0, #0x4		; decrement our count

; This write of "4" causes hardware to decrement the event count value
ffff2c30:	b9030c22 	str	w2, [x1, #0x30c]

ffff2c34:	7100001f 	cmp	w0, #0x0		; 0 events remaining
ffff2c38:	54ffffac 	b.gt	0xffff2c2c

; now this is interesting, pull a 16 bit value from the start of sram-J
; we have some candidate code here to try to run.

ffff2c3c:	f9400260 	ldr	x0, [x19]		; sram-J
ffff2c40:	39401401 	ldrb	w1, [x0, #5]
ffff2c44:	39401000 	ldrb	w0, [x0, #4]
ffff2c48:	2a012000 	orr	w0, w0, w1, lsl #8

ffff2c4c:	f9403a61 	ldr	x1, [x19, #0x70]	; sam
ffff2c50:	b9406a62 	ldr	w2, [x19, #0x68]	; bob

ffff2c54:	940003de 	bl	0xffff3bcc		; usb_try_run ( sram-J, sam, bob)

ffff2c58:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff2c5c:	52801be1 	mov	w1, #0xdf
ffff2c60:	0a010000 	and	w0, w0, w1
ffff2c64:	39019660 	strb	w0, [x19, #0x65]	; clear 0x20 in lucy

ffff2c68:	f9400260 	ldr	x0, [x19]
ffff2c6c:	39401401 	ldrb	w1, [x0, #5]
ffff2c70:	39401000 	ldrb	w0, [x0, #4]
ffff2c74:	2a012000 	orr	w0, w0, w1, lsl #8	; assemble 16 bits

ffff2c78:	7111c41f 	cmp	w0, #0x471		; 0x471 magic
ffff2c7c:	54002301 	b.ne	0xffff30dc		; return if ne 0x471

ffff2c80:	aa1303e0 	mov	x0, x19			; "usb"
ffff2c84:	aa1403e1 	mov	x1, x20			; ptr to event
ffff2c88:	9400011b 	bl	0xffff30f4		; usb_xfer2 ( "usb", x )
ffff2c8c:	14000114 	b	0xffff30dc		; return

; END of Xfer not ready with status short (we returned above)

; ---------------------------------------
; still going ...  usb_one ()

; Here when the event is not Xfer not ready ...
; The only other event this routine is willing to handle is
; Xfer complete, otherwise we return here

ffff2c90:	7100043f 	cmp	w1, #0x1
ffff2c94:	54002241 	b.ne	0xffff30dc		; return

; ---------------------------------------
; ---------------------------------------
; Handle Xfer complete ***

; get 5:1 (endpoint number)
ffff2c98:	53011400 	ubfx	w0, w0, #1, #5

ffff2c9c:	8b204e60 	add	x0, x19, w0, uxtw #3
ffff2ca0:	f9401c00 	ldr	x0, [x0, #0x38]		; X or Y

; clear transfer in progress bit
ffff2ca4:	b9401801 	ldr	w1, [x0, #24]		; X/Y + 24  "sue"
ffff2ca8:	121b7821 	and	w1, w1, #0xffffffef	; clear bit 0x10 (TIP)
ffff2cac:	b9001801 	str	w1, [x0, #24]		; "sue"

ffff2cb0:	3900881f 	strb	wzr, [x0, #0x22]	; X/Y + 22 = 0

ffff2cb4:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff2cb8:	121c7802 	and	w2, w0, #0xfffffff7
ffff2cbc:	39019662 	strb	w2, [x19, #0x65]	; clear 0x01 in lucy

; this is the only place this field is inspected
; -- I have called it "xfer_code"
; it gets set before calls to usb_xfer* and usb_start_transfer
; values set are 1,2, or 3  --  so we have 3 cases here
;
; in fact this routine sets the value back to 1 below
; I am going to dub this "xfer_code"

ffff2cc0:	b9405e61 	ldr	w1, [x19, #0x5c]	; get xfer_code
ffff2cc4:	71000c3f 	cmp	w1, #0x3
ffff2cc8:	54000820 	b.eq	0xffff2dcc		; Go handle 3

ffff2ccc:	7100083f 	cmp	w1, #0x2
ffff2cd0:	54000841 	b.ne	0xffff2dd8		; Go handle 1

; fall thru to handle 2

; ---------------------------------- ---------------------------------
; ---------------------------------- ---------------------------------

;	D -- Xfer complete, xfer_code 2

; fall through for Xfer complete, xfer_code == 2

; Once again, assemble the event using the event pointer in x20
; the event will be in w2
ffff2cd4:	39400e81 	ldrb	w1, [x20, #3]
ffff2cd8:	39400a82 	ldrb	w2, [x20, #2]
ffff2cdc:	2a012041 	orr	w1, w2, w1, lsl #8
ffff2ce0:	39400682 	ldrb	w2, [x20, #1]
ffff2ce4:	39400283 	ldrb	w3, [x20]
ffff2ce8:	2a022062 	orr	w2, w3, w2, lsl #8
ffff2cec:	2a014042 	orr	w2, w2, w1, lsl #16

; event now in w2

; why X with no questions asked (EP0-OUT) ?
; presumably Xfer code == 2 guarantees that
ffff2cf0:	f9401e75 	ldr	x21, [x19, #0x38]	; X
ffff2cf4:	52800061 	mov	w1, #0x3
ffff2cf8:	b9005a61 	str	w1, [x19, #0x58]	; jane = 3

ffff2cfc:	f9400666 	ldr	x6, [x19, #8]		; sram-K

ffff2d00:	53017c56 	lsr	w22, w2, #1

ffff2d04:	b9406a65 	ldr	w5, [x19, #0x68]	; w5 = bob (a count)
ffff2d08:	394024c1 	ldrb	w1, [x6, #9]		; K+9
ffff2d0c:	394020c3 	ldrb	w3, [x6, #8]		; K+8
ffff2d10:	2a012063 	orr	w3, w3, w1, lsl #8
ffff2d14:	394028c4 	ldrb	w4, [x6, #10]		; K+10

ffff2d18:	7940da61 	ldrh	w1, [x19, #0x6c]	; "joe"

; This extracts the endpoint index again.
; We don't seem to do anything with it,
; and we know it is 0 anyway for X
ffff2d1c:	53011454 	ubfx	w20, w2, #1, #5		; w20 = 5:1 from event

ffff2d20:	2a044063 	orr	w3, w3, w4, lsl #16	; 24 bit value from K
ffff2d24:	53007ca2 	lsr	w2, w5, #0		; w2 = w5 = bob
ffff2d28:	36080780 	tbz	w0, #1, 0xffff2e18

ffff2d2c:	f9400aa0 	ldr	x0, [x21, #16]		; X + 16
ffff2d30:	39401404 	ldrb	w4, [x0, #5]
ffff2d34:	39401007 	ldrb	w7, [x0, #4]

ffff2d38:	f9403a60 	ldr	x0, [x19, #0x70]	; x0 = sam (addr in SRAM)
ffff2d3c:	2a0420e4 	orr	w4, w7, w4, lsl #8	; 16 bit value

ffff2d40:	7101043f 	cmp	w1, #0x41		; test "joe"
ffff2d44:	540006e3 	b.cc	0xffff2e20

ffff2d48:	1ac40827 	udiv	w7, w1, w4		; w7 = w1 / w4
ffff2d4c:	1b047ce8 	mul	w8, w7, w4		; w8 = w7 * w4
ffff2d50:	4b234107 	sub	w7, w8, w3, uxtw	; w7 = w8 - w3
ffff2d54:	0b2540e3 	add	w3, w7, w5, uxtw	; w3 = w7 + w5
ffff2d58:	b9006a63 	str	w3, [x19, #0x68]	; bob = w3

ffff2d5c:	394064c3 	ldrb	w3, [x6, #25]		; K+25
ffff2d60:	394060c5 	ldrb	w5, [x6, #24]		; K+24
ffff2d64:	394068c6 	ldrb	w6, [x6, #26]		; K+26
ffff2d68:	8b274042 	add	x2, x2, w7, uxtw	; x2 += w7
ffff2d6c:	2a0320a3 	orr	w3, w5, w3, lsl #8
ffff2d70:	2a064063 	orr	w3, w3, w6, lsl #16	; 24 bit value

; Whether or not the completed transfer was a single or
; a chain of 2, we set the slot pointer to zero.
ffff2d74:	b90002bf 	str	wzr, [x21]		; "trb_slot" = 0
ffff2d78:	1400002c 	b	0xffff2e28

; ---------------------------------
; ---------------------------------
; ---------------------------------

;	B -- Xfer not ready but not with status short

; Come here with transfer not ready and not "short"
; Here we see if status is "Buserr", if so we handle it.
; all other status types, we just return and ignore
; the event

ffff2d7c:	7100047f 	cmp	w3, #0x1
ffff2d80:	54001ae1 	b.ne	0xffff30dc		; return if ne 1

; Yep, it was buserr
ffff2d84:	53020820 	ubfx	w0, w1, #2, #1
ffff2d88:	53011441 	ubfx	w1, w2, #1, #5
ffff2d8c:	6b21401f 	cmp	w0, w1, uxtw
ffff2d90:	54001a60 	b.eq	0xffff30dc		; return if ...
ffff2d94:	8b200e60 	add	x0, x19, w0, uxtb #3
ffff2d98:	f9401c14 	ldr	x20, [x0, #0x38]	; X/Y ???
ffff2d9c:	39408a80 	ldrb	w0, [x20, #0x22]
ffff2da0:	340017c0 	cbz	w0, 0xffff3098		; STALL_RETURN

ffff2da4:	910023e3 	add	x3, sp, #0x8
ffff2da8:	b900087f 	str	wzr, [x3, #8]
ffff2dac:	f90007ff 	str	xzr, [sp, #8]
ffff2db0:	39408281 	ldrb	w1, [x20, #32]		; get endpoint index

; still going ...  usb_one ()

; We set up the endpoint command here.
; cmd = 8 is "end transfer" with no parameters
; the bit 0x100 is bit 8 (CMDIOC) "interrupt on completion"
; we also shift register w0 into the top 16 bits which is
; "commandparam", which for end transfer is the
; transfer resource index, which should have been returned
; by the "start transfer" we desire to end.

ffff2db4:	52802102 	mov	w2, #0x108
ffff2db8:	2a004042 	orr	w2, w2, w0, lsl #16	; cmd =
ffff2dbc:	aa1303e0 	mov	x0, x19			; "usb"
ffff2dc0:	94000175 	bl	0xffff3394		; usb_endpoint_command ( "usb", epindex, cmd, params )
ffff2dc4:	39008a9f 	strb	wzr, [x20, #0x22]
ffff2dc8:	140000b4 	b	0xffff3098		; STALL_RETURN

; --------------------------- ----------------------------------
; --------------------------- ----------------------------------
; --------------------------- ----------------------------------

;	E -- Xfer complete, xfer_code 3

ffff2dcc:	52800020 	mov	w0, #0x1
ffff2dd0:	b9005e60 	str	w0, [x19, #0x5c]	; xfer_code = 1
ffff2dd4:	140000bb 	b	0xffff30c0		; TRANS_RETURN

; goes to start transfer and finish

; --------------------------- ----------------------------------
; --------------------------- ----------------------------------
; --------------------------- ----------------------------------

;	C -- Xfer complete, xfer_code 1

; the check here is a belt and suspenders assertion check
;  (should never happen) that xfer_code is 1

ffff2dd8:	7100043f 	cmp	w1, #0x1
ffff2ddc:	54001801 	b.ne	0xffff30dc		; return

; *** apparently we have received a packet in sram-J

ffff2de0:	f9400261 	ldr	x1, [x19]		; sram-J
ffff2de4:	39401c23 	ldrb	w3, [x1, #7]
ffff2de8:	39401824 	ldrb	w4, [x1, #6]
ffff2dec:	2a032083 	orr	w3, w4, w3, lsl #8
ffff2df0:	340007a3 	cbz	w3, 0xffff2ee4		; below

; w2 still holds lucy from way above
ffff2df4:	321a0040 	orr	w0, w2, #0x40
ffff2df8:	39019660 	strb	w0, [x19, #0x65]	; lucy = w2 | 0x40

; Here is the only place in this code you find the "bfi" instruction
;  it is "bit field insert"
;	Here is our instruction:  bfi	w0, w2, #2, #1
;  the #2 is the target lsb in the destination register (w0)
;  the #1 is the width of the bit field to move
;  the field always starts at bit 0 (rightmost) in the source.
;  So this case copies one bit, but slides it over 2 to the left
;  So we are screwing with bit 0x4 in w0
;  (and w0 is the last value we fiddled with in lucy
; 
ffff2dfc:	39400022 	ldrb	w2, [x1]
ffff2e00:	53077c42 	lsr	w2, w2, #7
ffff2e04:	331e0040 	bfi	w0, w2, #2, #1

ffff2e08:	121c7800 	and	w0, w0, #0xfffffff7
ffff2e0c:	39019660 	strb	w0, [x19, #0x65]	; lucy = w0 & ~0x8

ffff2e10:	52800042 	mov	w2, #0x2
ffff2e14:	14000038 	b	0xffff2ef4

; END of Xfer complete, xfer_code 1 (but there is more below)

; --------------------------- ----------------------------------
; --------------------------- ----------------------------------
; below here is a continuation of "D" (quite a lot of code)
; as a reminder .... 
;	D -- Xfer complete, xfer_code 2
; --------------------------- ----------------------------------
; --------------------------- ----------------------------------

; "D" comes here
ffff2e18:	4b234037 	sub	w23, w1, w3, uxtw
ffff2e1c:	14000011 	b	0xffff2e60

; "D" comes here
; branch here from above (ffff2d44) when w1 == 0x41
ffff2e20:	2a1f03e7 	mov	w7, wzr
ffff2e24:	2a1f03e8 	mov	w8, wzr

; "D" comes here
ffff2e28:	8b020000 	add	x0, x0, x2		; x0 += x2
ffff2e2c:	4b284022 	sub	w2, w1, w8, uxtw	; w2 = w1 - w8
ffff2e30:	0b224082 	add	w2, w4, w2, uxtw	; w2 += w4
ffff2e34:	51000442 	sub	w2, w2, #0x1		; w2--
ffff2e38:	1ac40842 	udiv	w2, w2, w4		; w2 = w2 / w4
ffff2e3c:	1b047c42 	mul	w2, w2, w4		; w2 = w2 * w4
ffff2e40:	4b274024 	sub	w4, w1, w7, uxtw	; w4 = w1 - w7
ffff2e44:	4b234042 	sub	w2, w2, w3, uxtw	; w2 -= w3 

ffff2e48:	f9400a61 	ldr	x1, [x19, #16]		; L

ffff2e4c:	6b22409f 	cmp	w4, w2, uxtw
ffff2e50:	1a823097 	csel	w23, w4, w2, cc

ffff2e54:	53007ee2 	lsr	w2, w23, #0		; w2 = w23
ffff2e58:	9400057e 	bl	0xffff4450		; memcpy

ffff2e5c:	b9406a65 	ldr	w5, [x19, #0x68]	; bob
ffff2e60:	0b2542e0 	add	w0, w23, w5, uxtw	; bob += w23
ffff2e64:	b9006a60 	str	w0, [x19, #0x68]	; bob

ffff2e68:	36000096 	tbz	w22, #0, 0xffff2e78

ffff2e6c:	7940da61 	ldrh	w1, [x19, #0x6c]	; "joe"
ffff2e70:	6b21401f 	cmp	w0, w1, uxtw
ffff2e74:	54001123 	b.cc	0xffff3098		; STALL_RETURN

ffff2e78:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff2e7c:	360800c0 	tbz	w0, #1, 0xffff2e94	; test 0x2

ffff2e80:	394082a1 	ldrb	w1, [x21, #32]
ffff2e84:	35000081 	cbnz	w1, 0xffff2e94

ffff2e88:	52801fa1 	mov	w1, #0xfd
ffff2e8c:	0a010000 	and	w0, w0, w1
ffff2e90:	39019660 	strb	w0, [x19, #0x65]	; lucy &= ~0x2

ffff2e94:	f9400aa0 	ldr	x0, [x21, #16]
ffff2e98:	39401401 	ldrb	w1, [x0, #5]
ffff2e9c:	39401002 	ldrb	w2, [x0, #4]

ffff2ea0:	7940da60 	ldrh	w0, [x19, #0x6c]	; "joe"
ffff2ea4:	2a012041 	orr	w1, w2, w1, lsl #8
ffff2ea8:	529fffe2 	mov	w2, #0xffff                	// #65535
ffff2eac:	0b224021 	add	w1, w1, w2, uxtw
ffff2eb0:	0a000021 	and	w1, w1, w0

; near as I can tell, if we get to here, we return.
ffff2eb4:	35001141 	cbnz	w1, 0xffff30dc		; return
ffff2eb8:	34001120 	cbz	w0, 0xffff30dc		; return

; we read this byte here, but I don't see us ever setting it
; presumably it is zero from initialization
; so we just return
ffff2ebc:	3941e260 	ldrb	w0, [x19, #0x78]	; elmer
ffff2ec0:	340010e0 	cbz	w0, 0xffff30dc		; return

; --------------

ffff2ec4:	52800020 	mov	w0, #0x1
ffff2ec8:	b9005a60 	str	w0, [x19, #0x58]	; jane = 1
ffff2ecc:	f9400e62 	ldr	x2, [x19, #24]		; sram-J

; parameters for the call to usb_start_transfer ()
; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )

ffff2ed0:	52800a04 	mov	w4, #0x50	; ctrl
ffff2ed4:	aa1303e0 	mov	x0, x19		; "usb"
ffff2ed8:	aa1403e1 	mov	x1, x20		; ep-index
ffff2edc:	aa1f03e3 	mov	x3, xzr		; size (0 eh?)
ffff2ee0:	1400007d 	b	0xffff30d4	; short cut into TRANS_RETURN

; ------------------------------------------------------------------

; here is a continuation of C, which is:
;	C -- Xfer complete, xfer_code 1

; We have a received packet in sram-J
; and x1 points to sram-J

; clear bits 0x40, 0x8, and 0x4 in lucy
ffff2ee4:	52801662 	mov	w2, #0xb3		; w2 = 0xb3
ffff2ee8:	0a020000 	and	w0, w0, w2
ffff2eec:	39019660 	strb	w0, [x19, #0x65]	; lucy &= 0xb3

ffff2ef0:	52800062 	mov	w2, #0x3
ffff2ef4:	b9005a62 	str	w2, [x19, #0x58]	; jane = 3

; the first byte in a SETUP packet is "type"

ffff2ef8:	39400022 	ldrb	w2, [x1]		; J+0
ffff2efc:	121b0442 	and	w2, w2, #0x60
ffff2f00:	35000782 	cbnz	w2, 0xffff2ff0

; byte 2 is "request"

ffff2f04:	39400422 	ldrb	w2, [x1, #1]		; J+1

; request == 9 is "set configuration"
ffff2f08:	7100245f 	cmp	w2, #0x9
ffff2f0c:	540002c0 	b.eq	0xffff2f64

; request == 6 is "get descriptor"
ffff2f10:	7100185f 	cmp	w2, #0x6
ffff2f14:	54000481 	b.ne	0xffff2fa4

; get the H byte of the 2 byte "value" field
; this will give the type of the "get descriptor"

ffff2f18:	39400c22 	ldrb	w2, [x1, #3]		; J+3

ffff2f1c:	53020803 	ubfx	w3, w0, #2, #1
ffff2f20:	8b234e63 	add	x3, x19, w3, uxtw #3
ffff2f24:	f9401c74 	ldr	x20, [x3, #0x38]

; if this is "get descriptor" of type "configuration"
; that is what we expect and we branch to handle it.
;  handling it is where we respond with the vendor/product code.

ffff2f28:	7100085f 	cmp	w2, #0x2
ffff2f2c:	54000681 	b.ne	0xffff2ffc

; so, we have a get descriptor, but NOT type "configuration"

ffff2f30:	36300d60 	tbz	w0, #6, 0xffff30dc	; return

ffff2f34:	39401c20 	ldrb	w0, [x1, #7]
ffff2f38:	39401821 	ldrb	w1, [x1, #6]
ffff2f3c:	2a002020 	orr	w0, w1, w0, lsl #8	; 16 bit length field

; if ( len < 10 ) w21 = len else w21 = 0x20
; so we will send at least 10 bytes

ffff2f40:	7100281f 	cmp	w0, #0xa
ffff2f44:	52800401 	mov	w1, #0x20
ffff2f48:	1a813015 	csel	w21, w0, w1, cc

ffff2f4c:	53007ea2 	lsr	w2, w21, #0		; w2 = w21

ffff2f50:	d0ffc660 	adrp	x0, 0xff8c0000
ffff2f54:	91070000 	add	x0, x0, #0x1c0		; sram-J

ffff2f58:	d0000001 	adrp	x1, 0xffff4000
ffff2f5c:	91307021 	add	x1, x1, #0xc1c		; x1 = ffff4c1c
ffff2f60:	14000035 	b	0xffff3034

; Here is raw stuff from "odx"
00004c10 0722 0c33 0001 0000 0001 0000 0902 2000
00004c20 0101 0080 c809 0400 0002 ff06 0500 0705
00004c30 8102 0002 0007 0502 0200 0200 0000 0000
00004c40 703a ffff 0000 0000 703a ffff 0000 0000
00004c50 b03a ffff 0000 0000 703a ffff 0000 0000
00004c60 6039 ffff 0000 0000 7a7d 9862 0000 0000
00004c70 963a 3dbe 0000 0000 85c1 4612 0000 0000
00004c80 acc6 eb89 0000 0000 97bd 0f78 0000 0000
00004c90 8bda b5e2 0000 0000 2734 61dc 0000 0000
00004ca0 edf5 e60e 0000 0000 d6ee ec72 0000 0000
00004cb0 311a 044f 0000 0000 db70 4e25 0000 0000
00004cc0 ce7e c36f 0000 0000 3c79 5990 0000 0000
00004cd0 7453 33c9 0000 0000 8458 1142 0000 0000
00004ce0 0a5d 5b75 0000 0000 67b0 c840 0000 0000

So we are going to send the following 32 bytes when we branch:
; --- ffff4c1c 0902 2000
; --- ffff4c20 0101 0080
; --- ffff4c24 c809 0400
; --- ffff4c28 0002 ff06

; --- ffff4c2c 0500 0705
; --- 00004c30 8102 0002
; --- ffff4c34 0007 0502
; --- ffff4c38 0200 0200

; What are they?
; They are actually a lump of 4 descriptors, as follows:

;  -- the first 9 bytes:
; The first byte is a length (9 bytes)
; The next byte is the descriptor type = 2 (configuration)
; the next word is total length in bytes = 0x0020
; The next byte is the number of interfaces = 1
; The next byte is config value = 1
; The next byte is a string index (0, not used)
; The next byte is an attribute bitmap = 0x80 (nothing here)
; The next byte is max power = 0xc8 = 200 mA

;  -- the next 9 bytes:
; The first byte is a length (9 bytes)
; The next byte is the descriptor type = 4 (interface)
; The next byte is the interface number = 0
; The next byte is the "alternate setting" = 0
; The next byte is "number of endpoints" = 2
; The next byte is "interface class" = 0xff = vendor defined
; The next byte is "subclass" = 6
; The next byte is "protocol" = 5
; The next byte is string index for interface = 0

;  -- the next 7 bytes:
; The first byte is a length (7 bytes)
; The next byte is the descriptor type = 5 (endpoint descr)
; The next byte is endpoint address = 0x81 (IN 1)
; The next byte is attributes = 2 (bulk)
; The next word is max packet size = 0x200 = 512
; The next byte is polling interval = 0

;  -- the next 7 bytes:
; The first byte is a length (7 bytes)
; The next byte is the descriptor type = 5 (endpoint descr)
; The next byte is endpoint address = 0x02 (OUT 2)
; The next byte is attributes = 2 (bulk)
; The next word is max packet size = 0x200 = 512
; The next byte is polling interval = 0

; --------------------------
; We got a SETUP packet with "set configuration"

ffff2f64:	b9406262 	ldr	w2, [x19, #0x60]	; w2 = pete

ffff2f68:	52801de3 	mov	w3, #0xef
ffff2f6c:	0a030000 	and	w0, w0, w3
ffff2f70:	39019660 	strb	w0, [x19, #0x65]	; lucy &= ~0x10

ffff2f74:	39400c20 	ldrb	w0, [x1, #3]
ffff2f78:	39400823 	ldrb	w3, [x1, #2]
ffff2f7c:	2a002074 	orr	w20, w3, w0, lsl #8

;  call usb_xfer3 if ( pete == 7 )
ffff2f80:	71001c5f 	cmp	w2, #0x7
ffff2f84:	540006e1 	b.ne	0xffff3060

ffff2f88:	aa1303e0 	mov	x0, x19
ffff2f8c:	9400006e 	bl	0xffff3144		; usb_xfer3

ffff2f90:	12003e80 	and	w0, w20, #0xffff
ffff2f94:	35000a40 	cbnz	w0, 0xffff30dc		; return
ffff2f98:	528000c0 	mov	w0, #0x6
ffff2f9c:	b9006260 	str	w0, [x19, #0x60]	; pete = 6
ffff2fa0:	1400004f 	b	0xffff30dc		; return

; We got a setup packet of a type we aren't sure about.

ffff2fa4:	7100145f 	cmp	w2, #0x5
ffff2fa8:	54000241 	b.ne	0xffff2ff0		; we don't like it

; ---------------------------------------------------

; we got a setup packet with SET ADDRESS

; 5 is request type "set address"

ffff2fac:	b9406260 	ldr	w0, [x19, #0x60]	; pete
ffff2fb0:	71001c1f 	cmp	w0, #0x7		; is pete == 7 ?
ffff2fb4:	54000720 	b.eq	0xffff3098		; STALL_RETURN

ffff2fb8:	39400c20 	ldrb	w0, [x1, #3]
ffff2fbc:	39400821 	ldrb	w1, [x1, #2]
ffff2fc0:	f9402662 	ldr	x2, [x19, #0x48]	; usb hw
ffff2fc4:	2a002020 	orr	w0, w1, w0, lsl #8	; 16 bits

; USB register c700 = device config
; first clear bits 0011_1111_1000, i.e. 9:3 (device address)
; then shift address left 3 bits to insert it there.

ffff2fc8:	b9460041 	ldr	w1, [x2, #0x600]
ffff2fcc:	12166021 	and	w1, w1, #0xfffffc07
ffff2fd0:	2a000c21 	orr	w1, w1, w0, lsl #3
ffff2fd4:	b9060041 	str	w1, [x2, #0x600]

ffff2fd8:	7100001f 	cmp	w0, #0x0
ffff2fdc:	528000c0 	mov	w0, #0x6		; for addr != 0
ffff2fe0:	528000a1 	mov	w1, #0x5		; for addr == 0
ffff2fe4:	1a800020 	csel	w0, w1, w0, eq
ffff2fe8:	b9006260 	str	w0, [x19, #0x60]	; pete = 5 or 6

ffff2fec:	1400003c 	b	0xffff30dc		; return

; still going ...  usb_one ()

; ---------------------------------------------------
; We got a setup packet, but we don't much like it

ffff2ff0:	aa1303e0 	mov	x0, x19
ffff2ff4:	94000054 	bl	0xffff3144		; usb_xfer3
ffff2ff8:	14000039 	b	0xffff30dc		; return

; --------------------------------------------------------------------------
; --------------------------------------------------------------------------

; here when we want to set up a response
; with the vendor/product code
ffff2ffc:	7100045f 	cmp	w2, #0x1
ffff3000:	540006e1 	b.ne	0xffff30dc		; return
ffff3004:	363006c0 	tbz	w0, #6, 0xffff30dc	; return

ffff3008:	39401c20 	ldrb	w0, [x1, #7]		; J+7
ffff300c:	39401821 	ldrb	w1, [x1, #6]		; J+6
ffff3010:	2a002020 	orr	w0, w1, w0, lsl #8	; 16 bit length field

; The following is more or less "if (x > 0x12) x = 0x12"
; we got N from the receive packet bytes 6 and 7
; but we make sure it is no bigger than 18
; We want to send 18 bytes, but perhaps our host will not
; accept that much (which seems unlikely)

ffff3014:	7100481f 	cmp	w0, #0x12
ffff3018:	52800241 	mov	w1, #0x12		; 18
ffff301c:	1a808035 	csel	w21, w1, w0, hi

ffff3020:	53007ea2 	lsr	w2, w21, #0		; w2 = w21

; The following lump of stuff includes
;  the vendor/ product code.
; So we must be responding to a setup packet
; of some kind.

; -- ffff4c08: 40000000 02000112
; -- ffff4c10: 00000100 330c2207	; vendor/product = 2207, 330c
; -- ffff4c18: 00200209 00000100

; The above puts each 8 byte group into big endian order.
; Here is a dump in proper byte order:

; --- ffff4c08 1201 0002 0000 0040
; --- ffff4c10 0722 0c33 0001 0000
; --- ffff4c18 0001 0000 0902 2000
; --- ffff4c20 0101 0080 c809 0400

; The first byte is the length = 0x12 = 18 (sounds right)
; The next byte is the descriptor type = 0x01 for device descriptor
; The next word is the USB spec we are following in BCD = 0x0002 = 2.0
; The next byte is "device class" = 0
; The next byte is "device subclass" = 0
; The next byte is "device protocol" = 0
; The next byte is "max packet size" = 0x40 = 64
; The next word is "vendor" = 0722 --> 2207 = Rockchip
; The next word is "product" = 0c33 --> 330c = RK3399
; The next word is "device release number" in BCD = 1.0
; The next byte is an index for manufacturer string (0=no string)
; The next byte is an index for product string (0=no string)

; The next byte is a serial number = 0
; The next byte is the number of configs = 1

ffff3024:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3028:	91070000 	add	x0, x0, #0x1c0		; sram-J

ffff302c:	b0000001 	adrp	x1, 0xffff4000
ffff3030:	91302021 	add	x1, x1, #0xc08		; ffff4c08

; We branch here from above with x1 = ffff4c1c and N = 10
; or we fall through with x1 = ffff4c08 and N = 12

ffff3034:	94000507 	bl	0xffff4450		; memcpy ( sram-J, stuff, N )

ffff3038:	52800040 	mov	w0, #0x2
ffff303c:	b9005e60 	str	w0, [x19, #0x5c]	; xfer_code = 2

ffff3040:	aa1303e0 	mov	x0, x19
ffff3044:	aa1403e1 	mov	x1, x20
ffff3048:	aa1503e2 	mov	x2, x21		; X/Y ??

ffff304c:	94000084 	bl	0xffff325c	; usb_xfer4 ( "usb", x20, x21 )

; is x20 X/Y at this point ??
; if so, this extracts "sue"
ffff3050:	b9401a80 	ldr	w0, [x20, #24]
ffff3054:	12007800 	and	w0, w0, #0x7fffffff	; clear top bit
ffff3058:	b9001a80 	str	w0, [x20, #24]
ffff305c:	14000020 	b	0xffff30dc		; return

ffff3060:	7100185f 	cmp	w2, #0x6		; is pete == 6 ?
ffff3064:	540001a1 	b.ne	0xffff3098		; STALL_RETURN

; pete == 6
ffff3068:	aa1303e0 	mov	x0, x19
ffff306c:	94000036 	bl	0xffff3144		; usb_xfer3
ffff3070:	12003e80 	and	w0, w20, #0xffff
ffff3074:	34000340 	cbz	w0, 0xffff30dc		; return
ffff3078:	528000e0 	mov	w0, #0x7
ffff307c:	b9006260 	str	w0, [x19, #0x60]	; pete = 7

ffff3080:	f9402660 	ldr	x0, [x19, #0x48]
ffff3084:	b9460401 	ldr	w1, [x0, #0x604]	; USB dctrl
ffff3088:	52814002 	mov	w2, #0xa00                 	// #2560
ffff308c:	2a020021 	orr	w1, w1, w2
ffff3090:	b9060401 	str	w1, [x0, #0x604]	; USB dctrl
ffff3094:	14000012 	b	0xffff30dc		; return

; still going ...  usb_one ()

; --------------------------------------------------------------------
; --------------------------------------------------------------------
;  end game below here
; --------------------------------------------------------------------
; --------------------------------------------------------------------

; STALL_RETURN
ffff3098:	f9402260 	ldr	x0, [x19, #0x40]	; Y
ffff309c:	52800035 	mov	w21, #0x1
ffff30a0:	b9001815 	str	w21, [x0, #24]		; Y+24 = 1

ffff30a4:	f9401e74 	ldr	x20, [x19, #0x38]	; X
ffff30a8:	52800021 	mov	w1, #0x1
ffff30ac:	aa1403e0 	mov	x0, x20			; X
ffff30b0:	aa1f03e2 	mov	x2, xzr
ffff30b4:	940000e5 	bl	0xffff3448		; usb_stall ( X, 1, 0 )
ffff30b8:	b9001a95 	str	w21, [x20, #24]
ffff30bc:	b9005e75 	str	w21, [x19, #0x5c]	; xfer_code = 1

; TRANS_RETURN
; a second argument of 0 locks this to X (EP0-OUT)
; usb_start_transfer ( "usb", 0, J, 8, 0x20, 0 )
; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )

ffff30c0:	f9400e62 	ldr	x2, [x19, #24]	; sram-J
ffff30c4:	52800103 	mov	w3, #0x8	; size = 8
ffff30c8:	52800404 	mov	w4, #0x20	; ctrl
ffff30cc:	aa1303e0 	mov	x0, x19		; "usb"
ffff30d0:	aa1f03e1 	mov	x1, xzr		; ep-index = 0

ffff30d4:	aa1f03e5 	mov	x5, xzr
ffff30d8:	97fffe45 	bl	0xffff29ec		; usb_start_transfer ()

; RETURN
; Here is where we return
ffff30dc:	f9400ff3 	ldr	x19, [sp, #24]
ffff30e0:	a94257f4 	ldp	x20, x21, [sp, #32]
ffff30e4:	a9435ff6 	ldp	x22, x23, [sp, #48]
ffff30e8:	a9447bfd 	ldp	x29, x30, [sp, #64]
ffff30ec:	910143ff 	add	sp, sp, #0x50
ffff30f0:	d65f03c0 	ret

; END of usb_one ()

; ===========================================

; subroutine -- usb_xfer2 ( "usb", &event )

; This is a "wrapper" to set up a call to usb_start_transfer()

;  2 calls from above in usb_one
; -- no prolog
; x0 = "usb"
; x1 = pointer to a 32 bit event

; First, we assembly a 4 byte object
; using the pointer passed to us.
; this gives us the 32 bit event

ffff30f4:	39400c22 	ldrb	w2, [x1, #3]		; no prolog
ffff30f8:	39400823 	ldrb	w3, [x1, #2]
ffff30fc:	39400424 	ldrb	w4, [x1, #1]
ffff3100:	39400021 	ldrb	w1, [x1]
ffff3104:	2a022062 	orr	w2, w3, w2, lsl #8
ffff3108:	2a042021 	orr	w1, w1, w4, lsl #8
ffff310c:	2a024021 	orr	w1, w1, w2, lsl #16

; pull a bitfield 5:1  (endpoint index)
ffff3110:	53011421 	ubfx	w1, w1, #1, #5
ffff3114:	8b214c00 	add	x0, x0, w1, uxtw #3
ffff3118:	f9401c01 	ldr	x1, [x0, #0x38]		; X/Y

; odd to pull "usb" from X/Y when we already have it in x0
ffff311c:	f9400420 	ldr	x0, [x1, #8]		; "usb"

ffff3120:	39419403 	ldrb	w3, [x0, #0x65]		; w3 = lucy
ffff3124:	f9400c02 	ldr	x2, [x0, #24]		; "usb"+24 = sram-J

; note that we curiously augment the 0x30 count with some flag bits

ffff3128:	39408021 	ldrb	w1, [x1, #32]		; ep-index

; w4 = 0x30 + (lucy&0x40) >> 2
ffff312c:	121a0063 	and	w3, w3, #0x40
ffff3130:	52800604 	mov	w4, #0x30
ffff3134:	0b430884 	add	w4, w4, w3, lsr #2	; ctrl

ffff3138:	aa1f03e3 	mov	x3, xzr		; size = 0 (hmmm ...)
ffff313c:	aa1f03e5 	mov	x5, xzr		; flag

; note that the endpoint for the following is taken from the event

; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )
; usb_start_transfer ( "usb", ep-index, sram-J, 0, 0x30 + flags, 0 )

ffff3140:	17fffe2b 	b	0xffff29ec		; usb_start_transfer ()

; no return here, we just branch above
; end of usb_xfer2

; ===============================================================

; subroutine -- usb_xfer3 ( "usb", Q )
; 3 calls from usb_one

ffff3144:	d100c3ff 	sub	sp, sp, #0x30		; prolog
ffff3148:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff314c:	910083fd 	add	x29, sp, #0x20
ffff3150:	a90157f4 	stp	x20, x21, [sp, #16]
ffff3154:	f90007f3 	str	x19, [sp, #8]

ffff3158:	39400022 	ldrb	w2, [x1]		; fetch from Q

ffff315c:	aa0003f3 	mov	x19, x0			; "usb"

ffff3160:	121b0440 	and	w0, w2, #0x60		; Q & 0x60
ffff3164:	7101001f 	cmp	w0, #0x40

ffff3168:	54000701 	b.ne	0xffff3248

ffff316c:	39400420 	ldrb	w0, [x1, #1]		; Q + 1
ffff3170:	12000c00 	and	w0, w0, #0xf
ffff3174:	7100301f 	cmp	w0, #0xc
ffff3178:	54000221 	b.ne	0xffff31bc

; Here we are using bit 0x4 in lucy
;  to select X or Y
ffff317c:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff3180:	53020802 	ubfx	w2, w0, #2, #1		; get bit 0x4
ffff3184:	8b224e62 	add	x2, x19, w2, uxtw #3
ffff3188:	f9401c43 	ldr	x3, [x2, #0x38]		; X/Y

; tst does a bitwise AND, discarding the result
; so we are testing bit 0x20 in lucy
; cset yields a 1 or 0 result.
; but why not just use tbnz on bit 5 ??
ffff318c:	52800402 	mov	w2, #0x20
ffff3190:	6a02001f 	tst	w0, w2
ffff3194:	1a9f07e2 	cset	w2, ne
ffff3198:	37000442 	tbnz	w2, #0, 0xffff3220

ffff319c:	b9006a7f 	str	wzr, [x19, #0x68]	; bob = 0

ffff31a0:	39401422 	ldrb	w2, [x1, #5]
ffff31a4:	39401024 	ldrb	w4, [x1, #4]
ffff31a8:	2a022082 	orr	w2, w4, w2, lsl #8	; assemble 16 bit value

ffff31ac:	7111c85f 	cmp	w2, #0x472		; 0x472 magic value
ffff31b0:	540002a1 	b.ne	0xffff3204

;  Here with 0x472
ffff31b4:	f9003a7f 	str	xzr, [x19, #0x70]	; sam = 0
ffff31b8:	14000018 	b	0xffff3218
ffff31bc:	f9402260 	ldr	x0, [x19, #0x40]

ffff31c0:	52800035 	mov	w21, #0x1		; value "1"  for xfer_code
ffff31c4:	b9001815 	str	w21, [x0, #24]
ffff31c8:	f9401e74 	ldr	x20, [x19, #0x38]
ffff31cc:	52800021 	mov	w1, #0x1
ffff31d0:	aa1403e0 	mov	x0, x20
ffff31d4:	aa1f03e2 	mov	x2, xzr
ffff31d8:	9400009c 	bl	0xffff3448		; usb_stall ( X/Y, 1, 0 )
ffff31dc:	b9001a95 	str	w21, [x20, #24]		; again (maybe it changed?)
ffff31e0:	b9005e75 	str	w21, [x19, #0x5c]	; xfer_code = 1

; a second argument of 0 locks this to X (EP0-OUT)
; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )
; usb_start_transfer ( "usb", 0, sram-J, 8, 0x20, 0 )

ffff31e4:	f9400e62 	ldr	x2, [x19, #24]	; sram-J
ffff31e8:	52800103 	mov	w3, #0x8	; size = 8
ffff31ec:	52800404 	mov	w4, #0x20	; ctrl = 0x20
ffff31f0:	aa1303e0 	mov	x0, x19		; "usb"
ffff31f4:	aa1f03e1 	mov	x1, xzr		; ep-index = 0
ffff31f8:	aa1f03e5 	mov	x5, xzr		; flag = 0
ffff31fc:	97fffdfc 	bl	0xffff29ec		; usb_start_transfer ()
ffff3200:	14000012 	b	0xffff3248		; return

ffff3204:	7111c45f 	cmp	w2, #0x471		; 0x471 magic value
ffff3208:	540000c1 	b.ne	0xffff3220

;  Here with 0x471
ffff320c:	f0ffc662 	adrp	x2, 0xff8c2000		; SRAM
ffff3210:	91000042 	add	x2, x2, #0x0		; silly
ffff3214:	f9003a62 	str	x2, [x19, #0x70]	; sam = SRAM

ffff3218:	321b0000 	orr	w0, w0, #0x20
ffff321c:	39019660 	strb	w0, [x19, #0x65]	; lucy = w0 | 0x20

ffff3220:	36280140 	tbz	w0, #5, 0xffff3248

; Here is where "joe" is generated (a 16 bit value)
ffff3224:	39401c20 	ldrb	w0, [x1, #7]
ffff3228:	39401821 	ldrb	w1, [x1, #6]
ffff322c:	2a002022 	orr	w2, w1, w0, lsl #8
ffff3230:	7900da62 	strh	w2, [x19, #0x6c]	; "joe"

ffff3234:	52800040 	mov	w0, #0x2
ffff3238:	b9005e60 	str	w0, [x19, #0x5c]	; xfer_code = 2
ffff323c:	aa1303e0 	mov	x0, x19

ffff3240:	aa0303e1 	mov	x1, x3
ffff3244:	94000006 	bl	0xffff325c		; usb_xfer4 ()

; done
ffff3248:	f94007f3 	ldr	x19, [sp, #8]
ffff324c:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff3250:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff3254:	9100c3ff 	add	sp, sp, #0x30
ffff3258:	d65f03c0 	ret

# end of usb_xfer3

; ===============================================

; subroutine -- usb_xfer4 ( "usb", x, n )
; 2 calls
;  one in usb_one (), the other just above in usb_xfer3

ffff325c:	d10103ff 	sub	sp, sp, #0x40		; prolog
ffff3260:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff3264:	9100c3fd 	add	x29, sp, #0x30
ffff3268:	a9025ff6 	stp	x22, x23, [sp, #32]
ffff326c:	a90157f4 	stp	x20, x21, [sp, #16]
ffff3270:	f90007f3 	str	x19, [sp, #8]

ffff3274:	aa0103f5 	mov	x21, x1			; x
ffff3278:	aa0003f3 	mov	x19, x0			; "usb"
ffff327c:	12003c54 	and	w20, w2, #0xffff	; w20 = n & 0xfff
ffff3280:	340001d4 	cbz	w20, 0xffff32b8

ffff3284:	f9400aa0 	ldr	x0, [x21, #16]		; x + 16
ffff3288:	39401401 	ldrb	w1, [x0, #5]
ffff328c:	39401000 	ldrb	w0, [x0, #4]
ffff3290:	2a012017 	orr	w23, w0, w1, lsl #8	; 16 bit value

ffff3294:	394082a1 	ldrb	w1, [x21, #32]		; x + 32
ffff3298:	529fffe0 	mov	w0, #0xffff
ffff329c:	0b2042e0 	add	w0, w23, w0, uxtw
ffff32a0:	0a140000 	and	w0, w0, w20
ffff32a4:	34000160 	cbz	w0, 0xffff32d0

ffff32a8:	12001c20 	and	w0, w1, #0xff
ffff32ac:	340001e0 	cbz	w0, 0xffff32e8
ffff32b0:	394082a1 	ldrb	w1, [x21, #32]
ffff32b4:	14000009 	b	0xffff32d8

; aligned on 4096 boundary (or 0)
ffff32b8:	f9400e62 	ldr	x2, [x19, #24]		; "buf" = "usb" + 24
ffff32bc:	394082a1 	ldrb	w1, [x21, #32]		; x + 32
ffff32c0:	52800a04 	mov	w4, #0x50		; 80
ffff32c4:	aa1303e0 	mov	x0, x19
ffff32c8:	aa1f03e3 	mov	x3, xzr
ffff32cc:	1400002a 	b	0xffff3374		; short cut to finish

; from above
ffff32d0:	12001c20 	and	w0, w1, #0xff
ffff32d4:	34000260 	cbz	w0, 0xffff3320

; from above
ffff32d8:	f9400e62 	ldr	x2, [x19, #24]
ffff32dc:	52800a04 	mov	w4, #0x50
ffff32e0:	aa1303e0 	mov	x0, x19
ffff32e4:	14000015 	b	0xffff3338

; from above
ffff32e8:	7101069f 	cmp	w20, #0x41
ffff32ec:	540002a3 	b.cc	0xffff3340

; bob is a count, sam is an address (0 or SRAM+0)
ffff32f0:	f9403a60 	ldr	x0, [x19, #0x70]	; x0 = sam

ffff32f4:	b9406a61 	ldr	w1, [x19, #0x68]	; w1 = bob

ffff32f8:	1ad70a82 	udiv	w2, w20, w23
ffff32fc:	1b177c56 	mul	w22, w2, w23

; A note on the following call.
; This is the ONLY call to usb_start_transfer with the final argument of 1
; So the TRB for this transfer is built with the "chain bit" set
; and it will wait for the NEXT call somewhere to usb_start_transfer
; to be tacked on after it and the pair will be sent.
; that next call follows below.
; there is all kinds of logic in this routine, so pay attention.

; a second argument of 0 locks this to X (EP0-OUT)

; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )
; usb_start_transfer ( "usb", 0, buf, x22, 0x50, 1 )

ffff3300:	8b000022 	add	x2, x1, x0	; buf = sam + bob
ffff3304:	52800a04 	mov	w4, #0x50	; ctrl
ffff3308:	52800025 	mov	w5, #0x1	; flag
ffff330c:	aa1303e0 	mov	x0, x19		; "usb"
ffff3310:	aa1f03e1 	mov	x1, xzr		; ep-index = 0
ffff3314:	aa1603e3 	mov	x3, x22		; size

ffff3318:	97fffdb5 	bl	0xffff29ec		; usb_start_transfer ()

ffff331c:	1400000a 	b	0xffff3344

; -------------------
ffff3320:	f9403a60 	ldr	x0, [x19, #0x70]	; sam
ffff3324:	b9406a61 	ldr	w1, [x19, #0x68]	; bob
ffff3328:	8b000022 	add	x2, x1, x0		; "buf" = sam + bob

ffff332c:	52800a04 	mov	w4, #0x50	; ctrl
ffff3330:	aa1303e0 	mov	x0, x19		; "usb"
ffff3334:	aa1f03e1 	mov	x1, xzr		; ep-index = 0
ffff3338:	aa1403e3 	mov	x3, x20		; size
ffff333c:	1400000e 	b	0xffff3374	; short cut to finish

ffff3340:	2a1f03f6 	mov	w22, wzr

ffff3344:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff3348:	4b364281 	sub	w1, w20, w22, uxtw
ffff334c:	0b2142e3 	add	w3, w23, w1, uxtw
ffff3350:	321f0000 	orr	w0, w0, #0x2
ffff3354:	39019660 	strb	w0, [x19, #0x65]	; lucy |= 0x2

; We get here with w21 = X/Y
; the argument I denote by "size" gets calculated,
;  no telling yet what the game is with that.

; usb_start_transfer ( "usb", ep-index, buf, size, ctrl, flag )
; usb_start_transfer ( "usb", endpoint-index, "buf", size, 0x50, 0 )

ffff3358:	f9401662 	ldr	x2, [x19, #0x28]	; "buf" = sram-L
ffff335c:	394082a1 	ldrb	w1, [x21, #32]		; ep-index
ffff3360:	51000460 	sub	w0, w3, #0x1
ffff3364:	1ad70800 	udiv	w0, w0, w23
ffff3368:	1b177c03 	mul	w3, w0, w23		; size
ffff336c:	52800a04 	mov	w4, #0x50		; ctrl
ffff3370:	aa1303e0 	mov	x0, x19			; "usb"

; 3 ways to get here
ffff3374:	aa1f03e5 	mov	x5, xzr			; flag = 0
ffff3378:	97fffd9d 	bl	0xffff29ec		; usb_start_transfer ()

; done
ffff337c:	f94007f3 	ldr	x19, [sp, #8]
ffff3380:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff3384:	a9425ff6 	ldp	x22, x23, [sp, #32]
ffff3388:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff338c:	910103ff 	add	sp, sp, #0x40
ffff3390:	d65f03c0 	ret

# END of usb_xfer4

; =========================================

; subroutine -- usb_endpoint_command
; arguments:
;  x0 - usb structure
;  x1 - endpoint index
;  x2 - command
;  x3 - array of 3 params for endpoint
;
; this returns 0 on success, -1 on a timeout
; - it gets the command started, but does not
; wait for completion
;
; note the add with shift used here
; the shift is applied to the last register before the add

ffff3394:	d100c3ff 	sub	sp, sp, #0x30		; prolog
ffff3398:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff339c:	910083fd 	add	x29, sp, #0x20
ffff33a0:	a90157f4 	stp	x20, x21, [sp, #16]
ffff33a4:	f90007f3 	str	x19, [sp, #8]

ffff33a8:	aa0003f3 	mov	x19, x0			; "usb"

; Writes are to 0xc800 ...
; This is an oddly interleaved array of
;     physical endpoint registers
; We have room here for 13 endpoints (0 - 12)
; calculate base = 0xc800 + 4*n, then:
; base + 0 is command param 2
; base + 4 is command param 1
; base + 8 is command param 0
; base + c is command
;
; This is curious because we could have 16 IN and 16 OUT,
; but this limits us to using only 6 IN and 6 OUT and one more.
;
; What I now call the "endpoint index" is what we are using here
; where the index is 0,2,4,... for OUT endpoints
;    and 1,3,5,... for IN endpoints
; this is how things work with the endpoint enable register
; and I presume that is how it is here also

; the add does w5 += w1 * 16
;
; I believe the TRM has an error.  It says things like
;  0xc800 + 4*n to get the register address.
;  however 4*n would yield the offset for an array of 32 bit objects
;  to get the byte offset though, you shift by 4 (as you do here)
;  or multiply by 14

; copy the 3 params

ffff33ac:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw
ffff33b0:	b9400864 	ldr	w4, [x3, #8]		; arg3 + 8 (param 0)
ffff33b4:	5280e105 	mov	w5, #0x708
ffff33b8:	0b2150a5 	add	w5, w5, w1, uxtw #4
ffff33bc:	b8254804 	str	w4, [x0, w5, uxtw]

ffff33c0:	f9402660 	ldr	x0, [x19, #0x48]
ffff33c4:	b9400464 	ldr	w4, [x3, #4]		; arg3 + 4 (param 1)
ffff33c8:	5280e085 	mov	w5, #0x704
ffff33cc:	0b2150a5 	add	w5, w5, w1, uxtw #4
ffff33d0:	b8254804 	str	w4, [x0, w5, uxtw]

ffff33d4:	f9402660 	ldr	x0, [x19, #0x48]
ffff33d8:	b9400063 	ldr	w3, [x3]		; arg3 + 0 (param 2)
ffff33dc:	5280e004 	mov	w4, #0x700
ffff33e0:	0b215084 	add	w4, w4, w1, uxtw #4
ffff33e4:	b8244803 	str	w3, [x0, w4, uxtw]

; Write the endpoint command register. (c80c)
; x2 gives the command (passed as an argument)
; we set bit 10 (command active) so the controller will act on it
; page 158 in trm2

ffff33e8:	f9402660 	ldr	x0, [x19, #0x48]
ffff33ec:	32160042 	orr	w2, w2, #0x400		; cmd | 0x400
ffff33f0:	5280e183 	mov	w3, #0x70c
ffff33f4:	0b215061 	add	w1, w3, w1, uxtw #4
ffff33f8:	b8214802 	str	w2, [x0, w1, uxtw]	; endpoint command

; w1 is now the offset to the relevant command register
;  so we can poll it to check the command active status.
;
; Now read the command register and check bit 10
; which is the "command active" bit.
; software sets it to 1 to enable a command to be executed
; hardware clears it when it is finished and it is ready for another command
; it also sets the command status when it finishes.
; command status is in bits 15:12 of the same register
; this routine does nothing with the command status

ffff33fc:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw
ffff3400:	b8614800 	ldr	w0, [x0, w1, uxtw]
ffff3404:	53007c34 	lsr	w20, w1, #0

; quick test -- maybe it is active already!
ffff3408:	36500140 	tbz	w0, #10, 0xffff3430	; bit 10 is 0x400

; set timeout
ffff340c:	12803e75 	mov	w21, #0xfffffe0c        ; -500
; loop
ffff3410:	110006b5 	add	w21, w21, #0x1
ffff3414:	12800000 	mov	w0, #0xffffffff		; -1
ffff3418:	340000f5 	cbz	w21, 0xffff3434
; the above branch will return -1 if we timeout

ffff341c:	52800020 	mov	w0, #0x1
ffff3420:	97fff584 	bl	0xfff10a30		; xxdelay(1)

ffff3424:	f9402660 	ldr	x0, [x19, #0x48]
ffff3428:	b8746800 	ldr	w0, [x0, x20]
ffff342c:	3757ff20 	tbnz	w0, #10, 0xffff3410	; loop until command goes active

; Here when command has gone active
ffff3430:	2a1f03e0 	mov	w0, wzr
ffff3434:	f94007f3 	ldr	x19, [sp, #8]
ffff3438:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff343c:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff3440:	9100c3ff 	add	sp, sp, #0x30
ffff3444:	d65f03c0 	ret

; ========================================================

; subroutine -- usb_stall ( X/Y, 1, 0 )
; 2 calls above
;  - one in usb_run, the other in usb_one
; the second two arguments are always 1,0 as shown
; the second argument selects clear or stall.
;   0 says "clear", but we don't do that
;   1 says "stall"

ffff3448:	d100c3ff 	sub	sp, sp, #0x30
ffff344c:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff3450:	910083fd 	add	x29, sp, #0x20
ffff3454:	f9000ff3 	str	x19, [sp, #24]

ffff3458:	aa0003f3 	mov	x19, x0			; X/Y
ffff345c:	f9400660 	ldr	x0, [x19, #8]		; "usb"
ffff3460:	910023e3 	add	x3, sp, #0x8
ffff3464:	b900087f 	str	wzr, [x3, #8]
ffff3468:	f90007ff 	str	xzr, [sp, #8]
ffff346c:	340001e1 	cbz	w1, 0xffff34a8		; test arg2 (it is 1)
ffff3470:	350000c2 	cbnz	w2, 0xffff3488		; test arg3 (it is 0)

ffff3474:	39408e61 	ldrb	w1, [x19, #0x23]
ffff3478:	36000081 	tbz	w1, #0, 0xffff3488
ffff347c:	39406262 	ldrb	w2, [x19, #24]
ffff3480:	12800001 	mov	w1, #0xffffffff
ffff3484:	37200222 	tbnz	w2, #4, 0xffff34c8

ffff3488:	39408261 	ldrb	w1, [x19, #32]		; endpoint index
ffff348c:	910023e3 	add	x3, sp, #0x8
ffff3490:	52800082 	mov	w2, #0x4		; cmd = 4 (set stall)
ffff3494:	97ffffc0 	bl	0xffff3394		; usb_endpoint_command ( "usb", epindex, 4, params )
ffff3498:	b9401a62 	ldr	w2, [x19, #24]
ffff349c:	aa0003e1 	mov	x1, x0
ffff34a0:	321f0040 	orr	w0, w2, #0x2
ffff34a4:	14000008 	b	0xffff34c4

ffff34a8:	39408261 	ldrb	w1, [x19, #32]
ffff34ac:	910023e3 	add	x3, sp, #0x8
ffff34b0:	528000a2 	mov	w2, #0x5		; cmd = 5 (clear stall)
ffff34b4:	97ffffb8 	bl	0xffff3394		; usb_endpoint_command ( "usb", epindex, 5, params )
ffff34b8:	b9401a62 	ldr	w2, [x19, #24]
ffff34bc:	aa0003e1 	mov	x1, x0
ffff34c0:	121d7440 	and	w0, w2, #0xfffffff9

ffff34c4:	b9001a60 	str	w0, [x19, #24]

ffff34c8:	aa0103e0 	mov	x0, x1
ffff34cc:	f9400ff3 	ldr	x19, [sp, #24]
ffff34d0:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff34d4:	9100c3ff 	add	sp, sp, #0x30
ffff34d8:	d65f03c0 	ret

;  ===================================================

; usb_start ( usb, 1 )

; subroutine, called once during usb initialization
; passed x0 as pointer to usb control structure in SRAM
; passed x1 = 1
;
; This is only called in one place, always with argument 1
;
; The argument is 1 to start, 0 to stop.
; The bootrom code never asks it to stop.
;
; Code that calls this ignores the return value

ffff34dc:	d100c3ff 	sub	sp, sp, #0x30
ffff34e0:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff34e4:	910083fd 	add	x29, sp, #0x20
ffff34e8:	a90157f4 	stp	x20, x21, [sp, #16]
ffff34ec:	f90007f3 	str	x19, [sp, #8]

; c704 is the USB device control register
; here we either set or clear bit 31,
; which is the run/stop bit.
;   cbz is "compare and branch if zero"
; We always call this routine with "1", so we only
;   make the device run.
ffff34f0:	aa0003f3 	mov	x19, x0
ffff34f4:	f9402660 	ldr	x0, [x19, #0x48]
ffff34f8:	b9460400 	ldr	w0, [x0, #0x604]	; USB dctrl
ffff34fc:	aa0103f4 	mov	x20, x1

ffff3500:	340000b4 	cbz	w20, 0xffff3514		; zero means stop
ffff3504:	12b00101 	mov	w1, #0x7ff7ffff
ffff3508:	0a010000 	and	w0, w0, w1
ffff350c:	32010000 	orr	w0, w0, #0x80000000	; run
ffff3510:	14000002 	b	0xffff3518
ffff3514:	12007800 	and	w0, w0, #0x7fffffff	; stop
ffff3518:	f9402661 	ldr	x1, [x19, #0x48]
ffff351c:	b9060420 	str	w0, [x1, #0x604]	; USB dctrl

; timeout loop
ffff3520:	12803e75 	mov	w21, #0xfffffe0c            	// #-500
ffff3524:	14000003 	b	0xffff3530

; c70c is USB device status
; here we look at bit 22 which indicates "device halted"
; so if we are waiting for "run" we want to see this go to 0

ffff3528:	52800020 	mov	w0, #0x1
ffff352c:	97fff541 	bl	0xffff0a30		; xxdelay(1)
ffff3530:	f9402660 	ldr	x0, [x19, #0x48]
ffff3534:	b9460c00 	ldr	w0, [x0, #0x60c]	; USB 0xc70c
ffff3538:	120a0000 	and	w0, w0, #0x400000
ffff353c:	34000074 	cbz	w20, 0xffff3548		; zero means stop
ffff3540:	35000060 	cbnz	w0, 0xffff354c
ffff3544:	14000006 	b	0xffff355c		; we started !
ffff3548:	350000a0 	cbnz	w0, 0xffff355c		; we stopped !
ffff354c:	110006b5 	add	w21, w21, #0x1		; tick timeout
ffff3550:	12800000 	mov	w0, #0xffffffff		; -1
ffff3554:	35fffeb5 	cbnz	w21, 0xffff3528		; loop
ffff3558:	14000002 	b	0xffff3560

ffff355c:	2a1f03e0 	mov	w0, wzr			; success

ffff3560:	f94007f3 	ldr	x19, [sp, #8]
ffff3564:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff3568:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff356c:	9100c3ff 	add	sp, sp, #0x30
ffff3570:	d65f03c0 	ret

# END of usb_start

; ======================================================================

; usb_init2 ( usb )
; subroutine, called once during usb initialization
; passed x0 as pointer to usb control structure in SRAM

ffff3574:	d10083ff 	sub	sp, sp, #0x20
ffff3578:	a9017bfd 	stp	x29, x30, [sp, #16]
ffff357c:	910043fd 	add	x29, sp, #0x10
ffff3580:	f90007f3 	str	x19, [sp, #8]

ffff3584:	aa0003f3 	mov	x19, x0			; usb struct pointer

; Here is some kind of block at SRAM + 0x200, 6 bytes in size
; call this block "sram-C"
;
;  byte 0 = 7
;  byte 1 = 5
;  byte 2 = 0
;  byte 3 = 0
;  word = 0x40	(speed)

; The only place this is used is in usb_endpoint_setup () and usb_one()
; The only field that is ever changed is the last 2 bytes
; In usb_run () it is updated when speed is detected:

ffff3588:	b0ffc660 	adrp	x0, 0xff8c0000
ffff358c:	528000e1 	mov	w1, #0x7
ffff3590:	39080001 	strb	w1, [x0, #0x200]	; write to SRAM + 0x200
ffff3594:	91080000 	add	x0, x0, #0x200
ffff3598:	528000a1 	mov	w1, #0x5
ffff359c:	39000401 	strb	w1, [x0, #1]		; to SRAM + 0x201
ffff35a0:	3900081f 	strb	wzr, [x0, #2]		; to SRAM + 0x202
ffff35a4:	39000c1f 	strb	wzr, [x0, #3]		; to SRAM + 0x203
ffff35a8:	52800801 	mov	w1, #0x40
ffff35ac:	79000801 	strh	w1, [x0, #4]		; to SRAM + 0x204, 205

; we set all this up, but don't store a pointer to this cute bundle of 6 bytes
; nor do we reference it in this routine anyway.

; now work on device speed
ffff35b0:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw
ffff35b4:	b9460000 	ldr	w0, [x0, #0x600]	; c700 = device config register

; On initialization this will always be 3
; and we only call this routine on initialization, so ..... ?
; anyway, if we see the 3, we clear the bottom 3 bits
; these indicate device speed, and 0 is "high speed"

; This is set to 3 at initialization, never changed.
; This indicates "high speed" initially
ffff35b8:	b9405661 	ldr	w1, [x19, #0x54]	; fetch 3
ffff35bc:	121d7000 	and	w0, w0, #0xfffffff8
ffff35c0:	71000c3f 	cmp	w1, #0x3		; did we get 3 ?
ffff35c4:	54000140 	b.eq	0xffff35ec		; yes !

; None of this should execute in our case, but lets examine it anyway

ffff35c8:	7100083f 	cmp	w1, #0x2		; how about 2
ffff35cc:	54000061 	b.ne	0xffff35d8		; nope

; if we saw 2, set speed bits to 3, which is undefined  !?
ffff35d0:	32000400 	orr	w0, w0, #0x3	
ffff35d4:	14000006 	b	0xffff35ec

; not a 2
ffff35d8:	7100043f 	cmp	w1, #0x1		; how about 1
ffff35dc:	54000061 	b.ne	0xffff35e8		; nope

; if we saw 1, then set speed bits to 2, which is also undefine  !?
ffff35e0:	321f0000 	orr	w0, w0, #0x2
ffff35e4:	14000002 	b	0xffff35ec

; not 1, 2, or 3 -- we give up and set 4, which is super speed
ffff35e8:	321e0000 	orr	w0, w0, #0x4

ffff35ec:	f9402661 	ldr	x1, [x19, #0x48]	; usb hw
ffff35f0:	b9060020 	str	w0, [x1, #0x600]	; write to device config reg

; -----------------

; clear bit 0x10 in usb.flags
ffff35f4:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff35f8:	52801de1 	mov	w1, #0xef
ffff35fc:	0a010000 	and	w0, w0, w1
ffff3600:	39019660 	strb	w0, [x19, #0x65]	; lucy &= ~0x10

; X
ffff3604:	f9401e60 	ldr	x0, [x19, #0x38]	; X
ffff3608:	aa1f03e1 	mov	x1, xzr
ffff360c:	94000012 	bl	0xffff3654		; usb_endpoint_setup(X,0)
ffff3610:	350001a0 	cbnz	w0, 0xffff3644

; Y
ffff3614:	f9402260 	ldr	x0, [x19, #0x40]	; Y
ffff3618:	aa1f03e1 	mov	x1, xzr
ffff361c:	9400000e 	bl	0xffff3654		; usb_endpoint_setup(Y,0)
ffff3620:	35000120 	cbnz	w0, 0xffff3644

ffff3624:	52800020 	mov	w0, #0x1
ffff3628:	b9005e60 	str	w0, [x19, #0x5c]	; xfer_code = 1

; usb_start_transfer_x is a wrapper
; that sets up a call to usb_start_transfer for ep-index 0 (X or EP0-OUT)
; that involves sram-J

ffff362c:	aa1303e0 	mov	x0, x19
ffff3630:	97fffce9 	bl	0xffff29d4		; usb_start_transfer_x ( "usb" )

; Here we write 0x1e1f to the usb device event enable register
; this is (more or less) a 12 bit mask of events that can be enabled
; from bottom to top, we enable (or disable):
; 0 - disconnect detected
; 1 - reset
; 2 - connect done
; 3 - link change
; 4 - wakeup
; 5 - hibernation (disabled)
; 6 - L1 L2 suspend (disabled)
; 7 - SOF (start of frame) (disabled)
; 8 - xx
; 9 - erratic error
; 10, 11 - xx
; 12 - vendor device test

ffff3634:	f9402661 	ldr	x1, [x19, #0x48]	; usb hw
ffff3638:	2a1f03e0 	mov	w0, wzr			; return code (ignored)
ffff363c:	5283c3e2 	mov	w2, #0x1e1f
ffff3640:	b9060822 	str	w2, [x1, #0x608]	; c708 - device event enable

ffff3644:	f94007f3 	ldr	x19, [sp, #8]
ffff3648:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffff364c:	910083ff 	add	sp, sp, #0x20
ffff3650:	d65f03c0 	ret

; END of usb_init2

; ========================================

; subroutine -- "usb_endpoint_setup"

: This does the following
;  Cmd: start endpoint configuration (only for EP0-OUT)
;  Cmd: set endpoint configuration
;  Cmd: set endpoint transfer rate
;  set proper bit in "active endpoint enable register"
;   --- and this is it !

; This gets called early with flag = 0
; It gets called later with flag = 1

; x0 = X or Y
; x1 = 0 or 1 flag

; The calls with x1 = 0 come first from usb_init2 ()
; The calls with x1 = 1 come later from usb_run ()
;
; note that x0 is a pointer to X/Y, and NOT a pointer to the
;  "usb" block as is so often the case.
;
; X and Y are blocks of 40 bytes (0x28) size
; they are set up in usb_mem_setup
; they are zero with the following exceptions:
;                 X       Y
; +  8           usb"   "usb"
; + 24 (0x18)     0       0   4 bytes
; + 32 (0x20)     0       1   (byte)		-- endpoint index
; + 35 (0x23)     0       1   (byte)

; Note here on "endpoint index"
; This is 0 for the EP0-OUT endpoint (which is thus X)
;     and 1 for the EP0-IN endpoint (which is then Y)

;  X manages the EP0-OUT endpoint (which receives for us)
;  Y manages the EP0-IN endpoint (which we use to send)

ffff3654:	d10183ff 	sub	sp, sp, #0x60		; prolog
ffff3658:	a9057bfd 	stp	x29, x30, [sp, #80]
ffff365c:	910143fd 	add	x29, sp, #0x50
ffff3660:	a90463f7 	stp	x23, x24, [sp, #64]
ffff3664:	a9035bf5 	stp	x21, x22, [sp, #48]
ffff3668:	a90253f3 	stp	x19, x20, [sp, #32]

; so x19 points to X or Y
;    x20 points to "usb"
;    x21 is our "flag" for 0/1 (call it "arg_flag"

; a note on the flag.
; we call first during early initialization with the flag = 0
; we call later when handling "connect done" with the flag = 1

ffff366c:	aa0003f3 	mov	x19, x0			; X or Y
ffff3670:	f9400674 	ldr	x20, [x19, #8]		; "usb"
ffff3674:	39406260 	ldrb	w0, [x19, #24]

ffff3678:	aa0103f5 	mov	x21, x1			; save "arg_flag"

; This bit will be zero at initialization
ffff367c:	36000060 	tbz	w0, #0, 0xffff3688	; test bit in X/Y +24

ffff3680:	91008276 	add	x22, x19, #0x20		; X/Y + 0x20
ffff3684:	14000019 	b	0xffff36e8

ffff3688:	910003e0 	mov	x0, sp			; 3 words of params
ffff368c:	b900081f 	str	wzr, [x0, #8]		; 12 bytes of 0
ffff3690:	f90003ff 	str	xzr, [sp]

ffff3694:	39408260 	ldrb	w0, [x19, #0x20]	; fetch endpoint index
ffff3698:	91008276 	add	x22, x19, #0x20		; X/Y + 0x20 (pointer to above)

; We skip the first command for endpoint 1 (EP0-IN)
ffff369c:	7100041f 	cmp	w0, #0x1		; endpoint 1 ?
ffff36a0:	54000240 	b.eq	0xffff36e8		; yes

; no -- not endpoint 1
ffff36a4:	52800122 	mov	w2, #0x9		; cmd = 9
ffff36a8:	7100081f 	cmp	w0, #0x2
ffff36ac:	54000143 	b.cc	0xffff36d4		; < 2 so endpoint 0

; endpoint 2 or higher
;  -- never happens for us

ffff36b0:	39419680 	ldrb	w0, [x20, #0x65]	; lucy
ffff36b4:	52800201 	mov	w1, #0x10
ffff36b8:	6a01001f 	tst	w0, w1			; test 0x10 in lucy
ffff36bc:	1a9f07e1 	cset	w1, ne
ffff36c0:	37000141 	tbnz	w1, #0, 0xffff36e8

; -- we won't run this code either (for endpoints > 1)
; get cmd for endpoint
; we get cmd = 9  with bit 17 set
; 9 is "start new configuration" and should require no params

ffff36c4:	d0000001 	adrp	x1, 0xffff5000
ffff36c8:	b9413422 	ldr	w2, [x1, #0x134]	; ffff5134: 00020009
ffff36cc:	321c0000 	orr	w0, w0, #0x10
ffff36d0:	39019680 	strb	w0, [x20, #0x65]	; lucy = w0 | 0x10

; endpoint 0 (EP0-OUT) comes right here
; in our case cmd = w2 = 9
;  -- this is "start new configuration", with no params
; We pass sp, so the routine has a valid address to load from,
; but no params will be used.

ffff36d4:	910003e3 	mov	x3, sp			; params (3 words of 0)
ffff36d8:	aa1403e0 	mov	x0, x20			; "usb"
ffff36dc:	aa1f03e1 	mov	x1, xzr			; index 0 (EP0-OUT)
ffff36e0:	97ffff2d 	bl	0xffff3394		; usb_endpoint_command ( "usb", 0, cmd, params )
ffff36e4:	350007a0 	cbnz	w0, 0xffff37d8

; endpoint 1 (EP0-IN) comes right here
; apparently we don't need to "start new configuration" for it.
; but endpoint 0 falls through into this code

ffff36e8:	b90013ff 	str	wzr, [sp, #0x10]	; param[0] = 0

ffff36ec:	b0ffc660 	adrp	x0, 0xff8c0000
ffff36f0:	91080017 	add	x23, x0, #0x200		; SRAM + 0x200 "sram-C"

; This routine (usb_endpoint_setup()) and usb_one() are the only places
;  the "sram-C" block is referenced.
; Why these 6 bytes were not included in "usb" is a mystery
;
; near as I can tell, just the speed entry is fiddled with
;  and tested, but perhaps I am missing something

;  byte 0 = 7
;  byte 1 = 5
;  byte 2 = 0
;  byte 3 = 0
;  word = 0x40 (full/high speed) or 0x200 (super speed)

ffff36f4:	39400ee1 	ldrb	w1, [x23, #3] 		; = 0 from byte 3
ffff36f8:	528000c0 	mov	w0, #0x6
ffff36fc:	79400ae2 	ldrh	w2, [x23, #4]		; = speed value (see above)
ffff3700:	0a010400 	and	w0, w0, w1, lsl #1
ffff3704:	2a020c00 	orr	w0, w0, w2, lsl #3	; shift the speed value
ffff3708:	32010002 	orr	w2, w0, #0x80000000

; test the "arg_flag"
; if flag is 0, select w0 = 0x6 | (speed << 3)
; if flag is 1, select w2 = 0x6 | 0x80000000
ffff370c:	710002bf 	cmp	w21, #0x0		; "arg_flag"
ffff3710:	1a820000 	csel	w0, w0, w2, eq

; build a param block using x2
ffff3714:	910043e2 	add	x2, sp, #0x10
ffff3718:	b9000840 	str	w0, [x2, #8]		; param[2] = w0

; w1 is the 0 we fetched from byte 3 in "C" above
ffff371c:	52800063 	mov	w3, #0x3
ffff3720:	6a03003f 	tst	w1, w3

; The following fetches our endpoint index from X/Y + 0x20
ffff3724:	394002c1 	ldrb	w1, [x22]		; endpoint index

; another selection
; if "C" byte 3 was 3, we get w4 = 0x500
; if "C" byte 3 not, we get w4 = 0x700
; and we do get the second, namely 0x700
ffff3728:	5280e003 	mov	w3, #0x700
ffff372c:	5280a004 	mov	w4, #0x500
ffff3730:	1a830083 	csel	w3, w4, w3, eq

; w3 |= (ep_index << 25)
ffff3734:	2a016463 	orr	w3, w3, w1, lsl #25
ffff3738:	b9000443 	str	w3, [x2, #4]		; param[1] = w3

; x19 is X or Y
ffff373c:	39408e63 	ldrb	w3, [x19, #0x23]	; ep-index ?? I doubt it
ffff3740:	360000a3 	tbz	w3, #0, 0xffff3754	; test lowest bit

ffff3744:	52a01fc3 	mov	w3, #0xfe0000
ffff3748:	0a014063 	and	w3, w3, w1, lsl #16	; w3 &= ep_index << 16
ffff374c:	2a030000 	orr	w0, w0, w3		; w0 |= w3
ffff3750:	b9000840 	str	w0, [x2, #8]		; param[2] = w0

ffff3754:	910043f5 	add	x21, sp, #0x10		; param pointer

ffff3758:	52800022 	mov	w2, #0x1		; cmd = 1 (set endpoint config)
ffff375c:	aa1403e0 	mov	x0, x20			; "usb"
ffff3760:	aa1503e3 	mov	x3, x21			; params
ffff3764:	97ffff0c 	bl	0xffff3394		; usb_endpoint_command ( "usb", ep_index, 1, params )
ffff3768:	35000380 	cbnz	w0, 0xffff37d8

ffff376c:	39406260 	ldrb	w0, [x19, #24]		; X/Y + 24 (always 0?)
ffff3770:	36000060 	tbz	w0, #0, 0xffff377c
ffff3774:	2a1f03e0 	mov	w0, wzr
ffff3778:	14000018 	b	0xffff37d8		; return ( 0 )

; rebuild param block.
; apparently we keep param[1] from above
ffff377c:	f9000bff 	str	xzr, [sp, #0x10]	; param[0] = 0
ffff3780:	52800038 	mov	w24, #0x1
ffff3784:	b9000ab8 	str	w24, [x21, #8]		; param[2] = 1

ffff3788:	394002c1 	ldrb	w1, [x22]		; endpoint index
ffff378c:	52800042 	mov	w2, #0x2		; cmd = 2 (set endpoint transfer rate)
ffff3790:	aa1403e0 	mov	x0, x20			; "usb"
ffff3794:	aa1503e3 	mov	x3, x21			; params
ffff3798:	97fffeff 	bl	0xffff3394		; usb_endpoint_command ( "usb", ep_index, 2, params )
ffff379c:	350001e0 	cbnz	w0, 0xffff37d8

ffff37a0:	f9000a77 	str	x23, [x19, #16]
ffff37a4:	39400ee0 	ldrb	w0, [x23, #3]
ffff37a8:	12000400 	and	w0, w0, #0x3
ffff37ac:	39008660 	strb	w0, [x19, #0x21]
ffff37b0:	b9401a60 	ldr	w0, [x19, #24]
ffff37b4:	32000000 	orr	w0, w0, #0x1
ffff37b8:	b9001a60 	str	w0, [x19, #24]

; 0xc720 active endpoint enable register
; We have 32 bits
; We have 16 IN and 16 OUT endpoints
; bit 0 is EP0-OUT
; bit 1 is EP0-IN
; and so on, up the scale.
; endpoint indexes 0 and 1 must always be enabled (EP0-IN and EP0-OUT)

ffff37bc:	f9402681 	ldr	x1, [x20, #0x48]	; usb hw
ffff37c0:	b9462022 	ldr	w2, [x1, #0x620]

; w24 is still 0x1 from above
ffff37c4:	394002c3 	ldrb	w3, [x22]		; get endpoint index
ffff37c8:	2a1f03e0 	mov	w0, wzr			; so we return 0
ffff37cc:	1ac32303 	lsl	w3, w24, w3		; sel = 1 << ep-index
ffff37d0:	2a020062 	orr	w2, w3, w2
ffff37d4:	b9062022 	str	w2, [x1, #0x620]

; done
ffff37d8:	a94253f3 	ldp	x19, x20, [sp, #32]
ffff37dc:	a9435bf5 	ldp	x21, x22, [sp, #48]
ffff37e0:	a94463f7 	ldp	x23, x24, [sp, #64]
ffff37e4:	a9457bfd 	ldp	x29, x30, [sp, #80]
ffff37e8:	910183ff 	add	sp, sp, #0x60
ffff37ec:	d65f03c0 	ret

; END of usb_endpoint_setup

; =================================================================

; usb_mem_setup ( usb )

; subroutine, called once during usb initialization
; passed x0 as pointer to usb control structure in SRAM
; this seems to mostly set up memory.

ffff37f0:	d100c3ff 	sub	sp, sp, #0x30
ffff37f4:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff37f8:	910083fd 	add	x29, sp, #0x20
ffff37fc:	a90157f4 	stp	x20, x21, [sp, #16]
ffff3800:	f90007f3 	str	x19, [sp, #8]

ffff3804:	aa0003f3 	mov	x19, x0			; "usb" block base

; block "sram-J" 64 bytes at SRAM + 0x1c0  sram-J
ffff3808:	b0ffc660 	adrp	x0, 0xff8c0000
ffff380c:	91070000 	add	x0, x0, #0x1c0		; SRAM + 0x1c0
ffff3810:	f9000260 	str	x0, [x19]
ffff3814:	f9000e60 	str	x0, [x19, #24]
ffff3818:	d2800802 	mov	x2, #0x40
ffff381c:	aa1f03e1 	mov	x1, xzr
ffff3820:	94000317 	bl	0xffff447c		; memset ( addr, 0, 0x40 )

; block "sram-K" 32 bytes at SRAM + 0x3f0  sram-K
ffff3824:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3828:	910fc001 	add	x1, x0, #0x3f0		; SRAM + 0x3f0
ffff382c:	f9000661 	str	x1, [x19, #8]
ffff3830:	f9001261 	str	x1, [x19, #32]
ffff3834:	f9000c3f 	str	xzr, [x1, #24]
ffff3838:	f900083f 	str	xzr, [x1, #16]
ffff383c:	f900043f 	str	xzr, [x1, #8]
ffff3840:	f901f81f 	str	xzr, [x0, #0x3f0]

; block "sram-L" 64 bytes at SRAM + 0x180  sram-L
ffff3844:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3848:	91060000 	add	x0, x0, #0x180		; SRAM + 0x180
ffff384c:	f9000a60 	str	x0, [x19, #16]
ffff3850:	f9001660 	str	x0, [x19, #0x28]
ffff3854:	d2800802 	mov	x2, #0x40
ffff3858:	aa1f03e1 	mov	x1, xzr
ffff385c:	94000308 	bl	0xffff447c		; memset ( addr, 0, 0x40 );

; Here we set up blocks X and Y
; it appears that these have to do with endpoints
; each block is 40 bytes in size (0x28)
; block X is for EP0-OUT   at SRAM + 0x318
; block Y is for EP0-IN    at SRAM + 0x340

; X/Y + 0 -- "trb_slot"
; X/Y + 4
; X/Y + 8 -- "usb" (8 bytes	
; X/Y + 12 -  ...
; X/Y + 16 -- ?
; X/Y + 20 -- some flags
; X/Y + 24 -- 0 "sue"
; X/Y + 28 -- "usb" (8 bytes	
; X/Y + 32 -- 4 bytes

; note that "sue" is sometimes referenced as 32 bits and other times as just a byte
; it holds the TIP (transfer in progress) bit
; and also some other bits, not yet understood

; setup block X (pointer at usb + 0x38)
;  40 bytes in size i.e. 0x28
; 
ffff3860:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3864:	910c6014 	add	x20, x0, #0x318		; SRAM + 0x318

ffff3868:	d2800502 	mov	x2, #0x28		; 40
ffff386c:	aa1403e0 	mov	x0, x20
ffff3870:	aa1f03e1 	mov	x1, xzr
ffff3874:	94000302 	bl	0xffff447c		; memset ( x20, 0, 0x28 )

ffff3878:	f9000693 	str	x19, [x20, #8]		; "usb"
ffff387c:	3900829f 	strb	wzr, [x20, #32]		; 0 (endpoint index, EP0-OUT)
ffff3880:	39008e9f 	strb	wzr, [x20, #0x23]	; 0
ffff3884:	b9001a9f 	str	wzr, [x20, #24]		; "sue"
ffff3888:	f9001e74 	str	x20, [x19, #0x38]	; pointer to X

; setup block Y (pointer at usb + 0x40)
;
; Note that this immediately follows X,
; we just add 0x28 (40) to the X base value
;  also 40 bytes in size i.e. 0x28
; Oddly, just as above, this initializes stuff in the block,
;  but via offsets from the pointer to the X block
ffff388c:	9100a295 	add	x21, x20, #0x28		; SRAM + 0x340

ffff3890:	d2800502 	mov	x2, #0x28		; 40
ffff3894:	aa1503e0 	mov	x0, x21
ffff3898:	aa1f03e1 	mov	x1, xzr
ffff389c:	940002f8 	bl	0xffff447c		; memset ( x21, 0, 0x28 )

ffff38a0:	f9001a93 	str	x19, [x20, #0x30]	; at 8  = "usb"
ffff38a4:	52800020 	mov	w0, #0x1
ffff38a8:	39012280 	strb	w0, [x20, #0x48]	; at 32 = 1 (endpoint index, EP0-IN)
ffff38ac:	39012e80 	strb	w0, [x20, #0x4b]	; at 35 = 1
ffff38b0:	b900429f 	str	wzr, [x20, #0x40]	; at 24, i.e. 0x18
ffff38b4:	f9002275 	str	x21, [x19, #0x40]	; pointer to Y

; A note here on the endpoint index.  Why write it twice, and as a byte nonetheless?
; note that each write is done as a byte.  Stay on your toes.

; done
ffff38b8:	f94007f3 	ldr	x19, [sp, #8]
ffff38bc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff38c0:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff38c4:	9100c3ff 	add	sp, sp, #0x30
ffff38c8:	d65f03c0 	ret

; END of usb_mem_setup

;  =======================================================
;  =======================================================
;  =======================================================

; USB_RUN
; subroutine -- "usb_run"

; one call, surrounded by a spin loop, i.e. once we decide that
; we are doing the usb bootloader thing, we run this forever
;  -- no arguments
;
; This must be hand coded.
; No compiler would have generated this mess.

ffff38cc:	d10203ff 	sub	sp, sp, #0x80		; prolog
ffff38d0:	a9077bfd 	stp	x29, x30, [sp, #112]
ffff38d4:	9101c3fd 	add	x29, sp, #0x70
ffff38d8:	a90673fb 	stp	x27, x28, [sp, #96]
ffff38dc:	a9056bf9 	stp	x25, x26, [sp, #80]
ffff38e0:	a90463f7 	stp	x23, x24, [sp, #64]
ffff38e4:	a9035bf5 	stp	x21, x22, [sp, #48]
ffff38e8:	a90253f3 	stp	x19, x20, [sp, #32]

; This fetches a pointer to the "usb" block
; this is the only routine that does so directly.
ffff38ec:	b0ffc660 	adrp	x0, 0xff8c0000		; SRAM
ffff38f0:	910dc013 	add	x19, x0, #0x370		; "usb"

; We fetch the USB device base address from offset 0x48
; This value is 0xfe80c100
; We add offsets, like 0x30c to get "c40c"

ffff38f4:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw

; This reads the global event buffer count
; a 16 bit value with the count in bytes
; if it is zero, we have nothing to do.

ffff38f8:	b9430c00 	ldr	w0, [x0, #0x30c]
ffff38fc:	121e3400 	and	w0, w0, #0xfffc
ffff3900:	34001200 	cbz	w0, 0xffff3b40		; return if zero

; non-zero, something to do

ffff3904:	b0ffc675 	adrp	x21, 0xff8c0000
ffff3908:	911042b4 	add	x20, x21, #0x410	; SRAM + 0x410 "sram-A"

; Note that x20 holds a pointer to sram-A through the entire routine (usb_run)

; A note on the bit in A+20.
;  - first is that only that bit is used, the location is either 1 or 0
;  - it starts out zero
;  - this is the only place we set it
;  - we only clear it when we exit this routine
;  - we only check it (near as I can tell) in one place a few lines below
; So as near as I can tell, it is pointless, but maybe I am missing something.

ffff390c:	b9001280 	str	w0, [x20, #16]		; A+16 = event buffer count
ffff3910:	b9401680 	ldr	w0, [x20, #20]		; read A+20
ffff3914:	f9402661 	ldr	x1, [x19, #0x48]	; usb hw
ffff3918:	32000000 	orr	w0, w0, #0x1
ffff391c:	b9001680 	str	w0, [x20, #20]		; (A+20) |= 1

; 0xc408 - global event buffer size
; top bit is event interrupt mask
; setting 1 prevents an interrupt
; but events are still queued
ffff3920:	b9430820 	ldr	w0, [x1, #0x308]
ffff3924:	32010000 	orr	w0, w0, #0x80000000
ffff3928:	b9030820 	str	w0, [x1, #0x308]

; now we inspect the flag we set above in A+20
; heaven knows why the code adds first 16, then uses a 4 offset to get it
; if the bit is zero, we exit this routine
;  (which I don't think will ever happen
ffff392c:	91004280 	add	x0, x20, #0x10
ffff3930:	b9400400 	ldr	w0, [x0, #4]		; w0 = A+20
ffff3934:	36001060 	tbz	w0, #0, 0xffff3b40	; return if zero

; fetch event buffer count again
; we never checked it, but now we will and ensure it is >= 1

ffff3938:	b9401296 	ldr	w22, [x20, #16]		; w22 = A + 16
ffff393c:	710006df 	cmp	w22, #0x1
ffff3940:	54000f2b 	b.lt	0xffff3b24		; exit if < 1

; load a bunch of values to be used in the loop below
ffff3944:	52800097 	mov	w23, #0x4
ffff3948:	12a3e098 	mov	w24, #0xe0fbffff
ffff394c:	528019bc 	mov	w28, #0xcd                  	// #205
ffff3950:	528000ba 	mov	w26, #0x5
ffff3954:	1282801b 	mov	w27, #0xffffebff
ffff3958:	52801cf9 	mov	w25, #0xe7                  	// #231

; This just branches around the following ridiculously out of place
; block of code and starts into the big loop below

ffff395c:	14000009 	b	0xffff3980		; enter BIG loop below

; === Here is an odd out of place block of code for when super speed is detected

; branch (from table below) when super speed is detected
ffff3960:	f9402660 	ldr	x0, [x19, #0x48]
ffff3964:	b0ffc661 	adrp	x1, 0xff8c0000
ffff3968:	91080021 	add	x1, x1, #0x200		; sram-C
ffff396c:	52804002 	mov	w2, #0x200
ffff3970:	79000822 	strh	w2, [x1, #4]

; 0xc704 - device control
; mask with e0ff_ffff which clears 28:24 (HIRD Threshold)
ffff3974:	b9460401 	ldr	w1, [x0, #0x604]	; USB dctrl
ffff3978:	12036821 	and	w1, w1, #0xe0ffffff
ffff397c:	14000058 	b	0xffff3adc

; ----------------------------------------------------
; ================== BIG loop from below (ffff3b1c)
; ----------------------------------------------------

; This will process all the events currently in the event buffer

; Here x21 holds the pointer to the start of SRAM
; we read the first word in block A
; (why we don't use x20 without an offset?)
; B is the event buffer

ffff3980:	f9420aa0 	ldr	x0, [x21, #0x410]	; "A" + 0 (points to B)
ffff3984:	b9400e81 	ldr	w1, [x20, #12]		; "A" + 12 (offset)

; pull a 32 bit event off the event buffer
ffff3988:	b8616800 	ldr	w0, [x0, x1]		; event = B:offset
ffff398c:	b9000be0 	str	w0, [sp, #8]		; save event on stack

; if low bit in event is set, hand it off to usb_one ()
;   ( usb_one() handles "endpoint events" )
; if the bit is set, we will handle the event right here in usb_run
; it is something specific to the device itself
;   i.e. a "device event"

ffff3990:	37000180 	tbnz	w0, #0, 0xffff39c0

; it is an endpoint event ...

; fall through to here when bit 0 in the event was 0
; extract bitfield 4:1 (endpoint index 0 or 1)

ffff3994:	53011400 	ubfx	w0, w0, #1, #5

; x1 = "usb" + field<<3
; Some real monkey business here, but it works
; the following will yield either a pointer to X or Y
ffff3998:	8b204e61 	add	x1, x19, w0, uxtw #3
ffff399c:	f9401c21 	ldr	x1, [x1, #0x38]		; X or Y

; Test bit 0 (0x01) in sue
ffff39a0:	b9401821 	ldr	w1, [x1, #24]		; X/Y + 24 "sue"
ffff39a4:	36000ac1 	tbz	w1, #0, 0xffff3afc	; next event ..

; test endpoint index
ffff39a8:	7100041f 	cmp	w0, #0x1
ffff39ac:	54000a88 	b.hi	0xffff3afc		; next event ..

;  ********************************************
;  ********************************************  call usb_one ()
;  ********************************************

; The 32 bit event is on the stack and we pass a pointer to it.
; The code in usb_one then carefully moves it byte by byte into
; a register, which seems sort of silly if we can just put it onto
; the stack with a single "str" instruction above.
; perhaps usb_one() was originally coded for more general use.

; usb_one ( "usb", &event )

ffff39b0:	910023e1 	add	x1, sp, #0x8
ffff39b4:	aa1303e0 	mov	x0, x19
ffff39b8:	97fffc5c 	bl	0xffff2b28		; usb_one()

ffff39bc:	14000050 	b	0xffff3afc		; next event ..

; --------------------------------------

; We branch here when bit 0 in the event was set (we have a "device event")

; The (only) device events we handle are:
;  -- Reset
;  -- Connect done
;  -- Disconnect

; check bits 7:1
; Checking that those bits are zero verifies that this is a "device event:

ffff39c0:	121f1801 	and	w1, w0, #0xfe
ffff39c4:	350009c1 	cbnz	w1, 0xffff3afc		; next event ..

; extract bits 11:8
; this 4 bit field is the "event type"
ffff39c8:	53082c00 	ubfx	w0, w0, #8, #4
ffff39cc:	7100081f 	cmp	w0, #0x2
ffff39d0:	540003a0 	b.eq	0xffff3a44	; Connect Done
ffff39d4:	7100041f 	cmp	w0, #0x1
ffff39d8:	54000541 	b.ne	0xffff3a80	; not type 1

; if the type is 1, it is a USB reset

; 0xc704 - device control
; clear bits 4:1 (test control), disable test mode
ffff39dc:	f9402660 	ldr	x0, [x19, #0x48]
ffff39e0:	b9460401 	ldr	w1, [x0, #0x604]	; USB dctrl
ffff39e4:	121b6c21 	and	w1, w1, #0xffffffe1
ffff39e8:	b9060401 	str	w1, [x0, #0x604]	; USB dctrl

ffff39ec:	f9402260 	ldr	x0, [x19, #0x40]	; Y
ffff39f0:	b4000180 	cbz	x0, 0xffff3a20

ffff39f4:	b9401801 	ldr	w1, [x0, #24]		; "sue"
ffff39f8:	36080141 	tbz	w1, #1, 0xffff3a20
ffff39fc:	121e7821 	and	w1, w1, #0xfffffffd
ffff3a00:	b9001801 	str	w1, [x0, #24]		; "sue"

ffff3a04:	910043e3 	add	x3, sp, #0x10
ffff3a08:	b900087f 	str	wzr, [x3, #8]
ffff3a0c:	f9000bff 	str	xzr, [sp, #16]
ffff3a10:	39408001 	ldrb	w1, [x0, #32]		; get endpoint index
ffff3a14:	528000a2 	mov	w2, #0x5		; cmd = 5 (clear stall)
ffff3a18:	aa1303e0 	mov	x0, x19			; "usb"
ffff3a1c:	97fffe5e 	bl	0xffff3394		; usb_endpoint_command ( "usb", ep_index, 5, params )

; w28 is 0xcd = 1100_1101
; so we clear 0x20, 0x10,and 2
ffff3a20:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff3a24:	0a1c0000 	and	w0, w0, w28
ffff3a28:	39019660 	strb	w0, [x19, #0x65]	; lucy &= w28

ffff3a2c:	b900627a 	str	w26, [x19, #0x60]

; 0xc700 - device configuration
; clear bits 9:3 (device address)
ffff3a30:	f9402660 	ldr	x0, [x19, #0x48]
ffff3a34:	b9460001 	ldr	w1, [x0, #0x600]
ffff3a38:	12166021 	and	w1, w1, #0xfffffc07
ffff3a3c:	b9060001 	str	w1, [x0, #0x600]
ffff3a40:	1400002f 	b	0xffff3afc		; next event ..

; ------------------ now read device status and check speed

; Here on a "connect done" (event type 2)

; 0xc70c - device status
; read last 3 bits and stash them (connected speed)
;  4 is super, 0 is high, 1 is full

ffff3a44:	f9402660 	ldr	x0, [x19, #0x48]
ffff3a48:	b9460c00 	ldr	w0, [x0, #0x60c]
ffff3a4c:	12000801 	and	w1, w0, #0x7

; all well and good, but we never touch kate anywhere else
ffff3a50:	39019261 	strb	w1, [x19, #0x64]	; kate

; Here is a cute use of a branch table.
; The branch is all about what speed we got from the
; device status read above.

; We reject values greater than 4 to protect our 5 way branch
;
; Then we use a 5 way branch table into various chunks of code
; mostly immediately following, but one chunk up above

; This is testing the connected speed from the status read above

; Why this shift by 0?
;  an odd way to copy a register, but OK I guess

ffff3a54:	53007c20 	lsr	w0, w1, #0		; w0 = w1
ffff3a58:	7100103f 	cmp	w1, #0x4
ffff3a5c:	54000328 	b.hi	0xffff3ac0		; allow 0 .. 4
ffff3a60:	b0000001 	adrp	x1, 0xffff4000
ffff3a64:	91310021 	add	x1, x1, #0xc40		; see table below
ffff3a68:	f8607820 	ldr	x0, [x1, x0, lsl #3]
ffff3a6c:	d61f0000 	br	x0			; go to address in x0

;  ffff4c40: 00000000 ffff3a70 -- for high speed
;  ffff4c48: 00000000 ffff3a70 -- for full speed
;  ffff4c50: 00000000 ffff3ab0 -- for 2
;  ffff4c58: 00000000 ffff3a70 -- for 3
;  ffff4c60: 00000000 ffff3960 -- for super speed (orphan block above)

; Here for full or high speed
ffff3a70:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3a74:	91080000 	add	x0, x0, #0x200		; SRAM + 0x200 sram-C
ffff3a78:	52800801 	mov	w1, #0x40		; 64
ffff3a7c:	14000010 	b	0xffff3abc

; Not a USB reset or connect done
; w0 is the event type
; we ignore every other device event besides 0 (a disconnect)

ffff3a80:	350003e0 	cbnz	w0, 0xffff3afc		; next event ..

; We got a USB disconnect !

; c704 is the device control register
;  we clear bit 10 - INITu1ENA

ffff3a84:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw base
ffff3a88:	b9460401 	ldr	w1, [x0, #0x604]	; USB dctrl
ffff3a8c:	12157822 	and	w2, w1, #0xfffffbff
ffff3a90:	b9060402 	str	w2, [x0, #0x604]	; USB dctrl

; w27 is fffebff = 1110_1011_1111_1111
; so it will clear bits 10 and 12
; we already did bit 10 above, so why do it again?
; bit 12 is INITu2ENA

ffff3a94:	f9402660 	ldr	x0, [x19, #0x48]	; usb hw base
ffff3a98:	0a1b0021 	and	w1, w1, w27
ffff3a9c:	b9060401 	str	w1, [x0, #0x604]	; USB dctrl

ffff3aa0:	39419660 	ldrb	w0, [x19, #0x65]	; lucy
ffff3aa4:	0a190000 	and	w0, w0, w25		; w25 is 0xe7
ffff3aa8:	39019660 	strb	w0, [x19, #0x65]	; clear 0x01

ffff3aac:	14000014 	b	0xffff3afc		; next event ..

; Here for speed "2", whatever that is.
ffff3ab0:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3ab4:	91080000 	add	x0, x0, #0x200		; SRAM + 0x200	sram-C
ffff3ab8:	52800101 	mov	w1, #0x8		; 8

; full and high speed join here to finish the "connect done" event
ffff3abc:	79000801 	strh	w1, [x0, #4]

; c700 - device configuration
; set bit 22 (enable LPM capability)
ffff3ac0:	f9402660 	ldr	x0, [x19, #0x48]
ffff3ac4:	b9460001 	ldr	w1, [x0, #0x600]
ffff3ac8:	320a0021 	orr	w1, w1, #0x400000
ffff3acc:	b9060001 	str	w1, [x0, #0x600]
ffff3ad0:	f9402660 	ldr	x0, [x19, #0x48]

ffff3ad4:	b9460401 	ldr	w1, [x0, #0x604]	; USB dctrl
ffff3ad8:	0a180021 	and	w1, w1, w24

; super speed code above joins here to finish the "connect done" event
ffff3adc:	b9060401 	str	w1, [x0, #0x604]	; USB dctrl

;we are handling "connect done"
; Now we call usb_endpoint_setup() for the two endpoints
; it just sets parameters and transfer rate for the endpoints
; no data or buffers are specified

ffff3ae0:	f9401e60 	ldr	x0, [x19, #0x38]	; X (EP0-OUT)
ffff3ae4:	52800021 	mov	w1, #0x1
ffff3ae8:	97fffedb 	bl	0xffff3654		; usb_endpoint_setup(X,1)

ffff3aec:	35000080 	cbnz	w0, 0xffff3afc		; next event ..

ffff3af0:	f9402260 	ldr	x0, [x19, #0x40]	; Y (EP0-IN)
ffff3af4:	52800021 	mov	w1, #0x1
ffff3af8:	97fffed7 	bl	0xffff3654		; usb_endpoint_setup(Y,1)

; fall through

; Many places above branch to here
; they branch here when they are done processing an event and
; desire to move on to the next one

; increment A+12 by 4.
; The mask to 8 bits causes it to wrap around the event
; buffer which is 0x100 (256) bytes in size.

ffff3afc:	b9400e80 	ldr	w0, [x20, #12]		; A + 12
ffff3b00:	11001000 	add	w0, w0, #0x4
ffff3b04:	12001c00 	and	w0, w0, #0xff
ffff3b08:	f9402661 	ldr	x1, [x19, #0x48]
ffff3b0c:	b9000e80 	str	w0, [x20, #12]		; A + 12

; w22 is the event buffer count (in bytes)
ffff3b10:	510012d6 	sub	w22, w22, #0x4		; w22 -= 4

; w23 is 4 from way above
; write that to c40c (event count register)
; when a value is written to that register, the hardware
; event count is decremented by that value
ffff3b14:	b9030c37 	str	w23, [x1, #0x30c]

; Do we have more events ?
ffff3b18:	710002df 	cmp	w22, #0x0

# This runs the BIG loop
ffff3b1c:	54fff32c 	b.gt	0xffff3980		; loop back if w22 > 0

; we are done, wrap up
; clear our bit at A + 20
ffff3b20:	b9401680 	ldr	w0, [x20, #20]		; A + 20

ffff3b24:	f9402661 	ldr	x1, [x19, #0x48]	; usb hw
ffff3b28:	b900129f 	str	wzr, [x20, #16]		; A + 16
ffff3b2c:	121f7800 	and	w0, w0, #0xfffffffe
ffff3b30:	b9001680 	str	w0, [x20, #20]		; A + 20

; 0xc408 - global event buffer size
; top bit is event interrupt mask
; clear the bit that prevents interrupts
;  why do this?  We don't take interrupts.  Or do we?

ffff3b34:	b9430820 	ldr	w0, [x1, #0x308]
ffff3b38:	12007800 	and	w0, w0, #0x7fffffff
ffff3b3c:	b9030820 	str	w0, [x1, #0x308]

; done, return
ffff3b40:	a94253f3 	ldp	x19, x20, [sp, #32]
ffff3b44:	a9435bf5 	ldp	x21, x22, [sp, #48]
ffff3b48:	a94463f7 	ldp	x23, x24, [sp, #64]
ffff3b4c:	a9456bf9 	ldp	x25, x26, [sp, #80]
ffff3b50:	a94673fb 	ldp	x27, x28, [sp, #96]
ffff3b54:	a9477bfd 	ldp	x29, x30, [sp, #112]
ffff3b58:	910203ff 	add	sp, sp, #0x80
ffff3b5c:	d65f03c0 	ret

# END of usb_run

; ========================================================
; subroutine - called from only one place below
; verify ( buf, n )

ffff3b60:	d100c3ff 	sub	sp, sp, #0x30
ffff3b64:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff3b68:	910083fd 	add	x29, sp, #0x20
ffff3b6c:	a90157f4 	stp	x20, x21, [sp, #16]
ffff3b70:	f90007f3 	str	x19, [sp, #8]

; get 2 byte object from the end of the buffer
; take care that it may not be nicely aligned
; put the object into w21
ffff3b74:	aa0003f3 	mov	x19, x0			; a
ffff3b78:	51000834 	sub	w20, w1, #0x2		; b - 2
ffff3b7c:	38744a60 	ldrb	w0, [x19, w20, uxtw]
ffff3b80:	51000421 	sub	w1, w1, #0x1		; b--
ffff3b84:	38614a61 	ldrb	w1, [x19, w1, uxtw]
ffff3b88:	2a002035 	orr	w21, w1, w0, lsl #8

ffff3b8c:	aa1303e0 	mov	x0, x19		; buf
ffff3b90:	aa1403e1 	mov	x1, x20		; count
ffff3b94:	9400007c 	bl	0xffff3d84	; cksum ( buf, count )
ffff3b98:	aa0003e1 	mov	x1, x0
ffff3b9c:	52800020 	mov	w0, #0x1
ffff3ba0:	6b2122bf 	cmp	w21, w1, uxth
ffff3ba4:	540000a1 	b.ne	0xffff3bb8		; return 1

; the above verifies that the checksum matches what is
; in the last 2 bytes of the buffer, so now we do
; something with it.

ffff3ba8:	aa1303e0 	mov	x0, x19
ffff3bac:	aa1403e1 	mov	x1, x20
ffff3bb0:	9400008a 	bl	0xffff3dd8	; uncrypt ( buf, count )
ffff3bb4:	2a1f03e0 	mov	w0, wzr		; return 0

; done
ffff3bb8:	f94007f3 	ldr	x19, [sp, #8]
ffff3bbc:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff3bc0:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff3bc4:	9100c3ff 	add	sp, sp, #0x30
ffff3bc8:	d65f03c0 	ret

; END of verify ()

; ============================================

; subroutine - usb_try_run ( J, sam, bob )

;  - 1 call from usb_one()

; this will (if possible) run loaded code eventually

ffff3bcc:	d100c3ff 	sub	sp, sp, #0x30
ffff3bd0:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff3bd4:	910083fd 	add	x29, sp, #0x20
ffff3bd8:	a90157f4 	stp	x20, x21, [sp, #16]
ffff3bdc:	f90007f3 	str	x19, [sp, #8]

ffff3be0:	aa0103f3 	mov	x19, x1			; buf = sam
ffff3be4:	aa0003f5 	mov	x21, x0			; J
ffff3be8:	12002c40 	and	w0, w2, #0xfff		; w0 = bob & 0xfff
ffff3bec:	7100041f 	cmp	w0, #0x1
ffff3bf0:	1a9f17e0 	cset	w0, eq
ffff3bf4:	12000000 	and	w0, w0, #0x1
ffff3bf8:	4b204054 	sub	w20, w2, w0, uxtw

; Note that verify also calls uncrypt()
ffff3bfc:	aa1303e0 	mov	x0, x19			; buf
ffff3c00:	aa1403e1 	mov	x1, x20			; count
ffff3c04:	97ffffd7 	bl	0xffff3b60		; verify ( buf, count )
ffff3c08:	35000940 	cbnz	w0, 0xffff3d30		; return if it failed

ffff3c0c:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3c10:	52800141 	mov	w1, #0xa
ffff3c14:	b9001001 	str	w1, [x0, #16]		; SRAM + 16 = 0xa

ffff3c18:	51000a94 	sub	w20, w20, #0x2
ffff3c1c:	12003ea0 	and	w0, w21, #0xffff

ffff3c20:	7111c41f 	cmp	w0, #0x471		; 0x471 magic value
ffff3c24:	540002c1 	b.ne	0xffff3c7c
ffff3c28:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3c2c:	b9400c02 	ldr	w2, [x0, #12]
ffff3c30:	b9400260 	ldr	w0, [x19]
ffff3c34:	b0000001 	adrp	x1, 0xffff4000
ffff3c38:	912e1021 	add	x1, x1, #0xb84
ffff3c3c:	b9400021 	ldr	w1, [x1]
ffff3c40:	34000462 	cbz	w2, 0xffff3ccc

ffff3c44:	6b21401f 	cmp	w0, w1, uxtw
ffff3c48:	54000481 	b.ne	0xffff3cd8  // b.any
ffff3c4c:	aa1303e0 	mov	x0, x19
ffff3c50:	97fff19f 	bl	0xffff02cc
ffff3c54:	350006e0 	cbnz	w0, 0xffff3d30		; return if nz

ffff3c58:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3c5c:	52800021 	mov	w1, #0x1
ffff3c60:	b9003001 	str	w1, [x0, #0x30]		; SRAM + 0x30 = 1

ffff3c64:	910c8261 	add	x1, x19, #0x320
ffff3c68:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3c6c:	9100d000 	add	x0, x0, #0x34		; SRAM + 0x34
ffff3c70:	d2800882 	mov	x2, #0x44
ffff3c74:	940001f7 	bl	0xffff4450		; memcpy ( SRAM + 0x34, x19 + 0x320, 0x44 )
ffff3c78:	1400002e 	b	0xffff3d30		; return

ffff3c7c:	7111c81f 	cmp	w0, #0x472		; 0x472 magic value
ffff3c80:	54000581 	b.ne	0xffff3d30		; return unless 0
ffff3c84:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3c88:	b9400c00 	ldr	w0, [x0, #12]		; SRAM + 12
ffff3c8c:	340001c0 	cbz	w0, 0xffff3cc4

ffff3c90:	b0ffc675 	adrp	x21, 0xff8c0000
ffff3c94:	b94032a0 	ldr	w0, [x21, #0x30]	; SRAM + 0x30
ffff3c98:	340004c0 	cbz	w0, 0xffff3d30		; return if 0

ffff3c9c:	aa1403e0 	mov	x0, x20
ffff3ca0:	97fff20d 	bl	0xffff04d4		; crypto_set_hash_len ( x20 )

ffff3ca4:	aa1303e0 	mov	x0, x19
ffff3ca8:	aa1403e1 	mov	x1, x20
ffff3cac:	97fff21e 	bl	0xffff0524		; crypto2 ( x19, x20 )

ffff3cb0:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3cb4:	9100d000 	add	x0, x0, #0x34		; SRAM + 0x34
ffff3cb8:	91009000 	add	x0, x0, #0x24
ffff3cbc:	97fff23f 	bl	0xffff05b8		; crypto4 ( SRAM + 0x34 + 0x24 )
ffff3cc0:	35000240 	cbnz	w0, 0xffff3d08

ffff3cc4:	d63f0260 	blr	x19
ffff3cc8:	1400001a 	b	0xffff3d30		; return

ffff3ccc:	6b21401f 	cmp	w0, w1, uxtw
ffff3cd0:	54000300 	b.eq	0xffff3d30		; return if equal

; This goes to run what we have
ffff3cd4:	14000010 	b	0xffff3d14

ffff3cd8:	b0ffc675 	adrp	x21, 0xff8c0000
ffff3cdc:	b94032a0 	ldr	w0, [x21, #0x30]	; SRAM + 0x30
ffff3ce0:	34000280 	cbz	w0, 0xffff3d30		; return if 0

ffff3ce4:	aa1403e0 	mov	x0, x20
ffff3ce8:	97fff1fb 	bl	0xffff04d4		; crypto_set_hash_len ( x20 )

ffff3cec:	aa1303e0 	mov	x0, x19
ffff3cf0:	aa1403e1 	mov	x1, x20
ffff3cf4:	97fff20c 	bl	0xffff0524		; crypto2 ( x19, x20 )

ffff3cf8:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3cfc:	9100d000 	add	x0, x0, #0x34
ffff3d00:	97fff22e 	bl	0xffff05b8		; crypto4 ( SRAM + 0x34 )
ffff3d04:	34000060 	cbz	w0, 0xffff3d10

ffff3d08:	b90032bf 	str	wzr, [x21, #0x30]	; SRAM + 0x30 = 0
ffff3d0c:	14000009 	b	0xffff3d30		; return

; The following fetches from this:
;       ffff4e68:	524b 3333 5253 414b           "RK33RSAK"
; We are only interested in the first 4 bytes -- "RK33"

ffff3d10:	b9400260 	ldr	w0, [x19]
ffff3d14:	b0000001 	adrp	x1, 0xffff4000
ffff3d18:	9139a021 	add	x1, x1, #0xe68
ffff3d1c:	b9400021 	ldr	w1, [x1]	; RK33

; We set x2 to point just after what we hope is the "RK33"
; magic word.  Then we check it.
; If it matches, x2 goes into x0 and we go there
; If it does not match, we don't mind its absence
; and just go directly to the start of the image.

ffff3d20:	91001262 	add	x2, x19, #0x4
ffff3d24:	6b21401f 	cmp	w0, w1, uxtw
ffff3d28:	9a930040 	csel	x0, x2, x19, eq  // eq = none

ffff3d2c:	d63f0000 	blr	x0		; GO !!

; done (but we won't fall through to here)
ffff3d30:	f94007f3 	ldr	x19, [sp, #8]
ffff3d34:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff3d38:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff3d3c:	9100c3ff 	add	sp, sp, #0x30
ffff3d40:	d65f03c0 	ret

; ========= END of usb_try_run()

; =================================

; subroutine "usb_spin"

; The bootrom comes here once and forever if other methods
; of booting fail.

ffff3d44:	d10043ff 	sub	sp, sp, #0x10
ffff3d48:	a9007bfd 	stp	x29, x30, [sp]
ffff3d4c:	910003fd 	mov	x29, sp

ffff3d50:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3d54:	b900301f 	str	wzr, [x0, #0x30]	; SRAM + 0x30 = 0

ffff3d58:	97fff389 	bl	0xffff0b7c		; CRU, cpu clocks

ffff3d5c:	97fffa97 	bl	0xffff27b8		; usb_init ()

ffff3d60:	97fffedb 	bl	0xffff38cc		; usb_run ()

ffff3d64:	17ffffff 	b	0xffff3d60	; spin calling the above

; =============================================
; subroutine
; Called from an interesting spot above that
;  seems to have no path to it.
;  If that is true, this will never get called.
;  looks like orphaned dead wood code from olden days

ffff3d68:	d10043ff 	sub	sp, sp, #0x10
ffff3d6c:	a9007bfd 	stp	x29, x30, [sp]
ffff3d70:	910003fd 	mov	x29, sp

ffff3d74:	b0ffc660 	adrp	x0, 0xff8c0000
ffff3d78:	b9000c1f 	str	wzr, [x0, #12]
ffff3d7c:	97fff1a3 	bl	0xffff0408
ffff3d80:	97fffff1 	bl	0xffff3d44		; usb_spin

;  ========================================================================
; One call to this,  enters right here
; cksum ( buf, n )
;
; looks to me like it generates some kind of checksum

ffff3d84:	aa0003e2 	mov	x2, x0		; buf
ffff3d88:	529fffe0 	mov	w0, #0xffff
ffff3d8c:	34000241 	cbz	w1, 0xffff3dd4	; return if n == 0

ffff3d90:	52820423 	mov	w3, #0x1021                	// #4129
ffff3d94:	52900004 	mov	w4, #0x8000                	// #32768

ffff3d98:	39400045 	ldrb	w5, [x2]	; w5 = *buf
ffff3d9c:	52801006 	mov	w6, #0x80                  	// #128
ffff3da0:	321f3fe7 	mov	w7, #0x1fffe               	// #131070
ffff3da4:	0a0004e7 	and	w7, w7, w0, lsl #1
ffff3da8:	4a0300e8 	eor	w8, w7, w3
ffff3dac:	6a04001f 	tst	w0, w4
ffff3db0:	1a8800e0 	csel	w0, w7, w8, eq  // eq = none
ffff3db4:	4a030007 	eor	w7, w0, w3
ffff3db8:	6a0600bf 	tst	w5, w6
ffff3dbc:	1a870000 	csel	w0, w0, w7, eq  // eq = none
ffff3dc0:	13017cc6 	asr	w6, w6, #1
ffff3dc4:	35fffee6 	cbnz	w6, 0xffff3da0		; loop

ffff3dc8:	51000421 	sub	w1, w1, #0x1		; n--
ffff3dcc:	91000442 	add	x2, x2, #0x1		; buf++
ffff3dd0:	35fffe41 	cbnz	w1, 0xffff3d98		; loop

ffff3dd4:	d65f03c0 	ret

; =====================================================

; subroutine uncrypt ( buf, n )
; Called from several places
; -- no prolog
; w1 is a count (typically 0x200)
; x0 is some address

ffff3dd8:	aa1f03e3 	mov	x3, xzr			; x3 = 0
ffff3ddc:	b0000002 	adrp	x2, 0xffff4000
ffff3de0:	9131a044 	add	x4, x2, #0xc68		; copy from here

; This copies 256 bytes of stuff from this rom (at 0xffff4c68
; to SRAM at offset 0x72
; I call SRAM + 0x72 "code" in the below
;
; The copy is odd because we read 8 bytes, but only write 4 of those.
; So the image in ROM is twice as big as it ought to be.
; It really doesn't matter since we have plenty of extra
;  space in the ROM.  But it is odd.

loop:
ffff3de4:	f9400085 	ldr	x5, [x4]		; read 8 bytes
ffff3de8:	b0ffc662 	adrp	x2, 0xff8c0000
ffff3dec:	9101f042 	add	x2, x2, #0x7c		; SRAM + 0x7c
ffff3df0:	b8236845 	str	w5, [x2, x3]		; write 4 bytes
ffff3df4:	91002084 	add	x4, x4, #0x8		; x4 += 8
ffff3df8:	91001063 	add	x3, x3, #0x4		; x3 += 4
ffff3dfc:	f104007f 	cmp	x3, #0x100
ffff3e00:	54ffff21 	b.ne	0xffff3de4

ffff3e04:	340002a1 	cbz	w1, 0xffff3e58		; return if 0

ffff3e08:	2a1f03e3 	mov	w3, wzr		; w3 = 0
ffff3e0c:	2a1f03e4 	mov	w4, wzr		; w4 = 0

loop:
ffff3e10:	11000463 	add	w3, w3, #0x1		; w3++
ffff3e14:	12001c63 	and	w3, w3, #0xff		; w3 &= 0xff
ffff3e18:	38634845 	ldrb	w5, [x2, w3, uxtw]	; x = code[w3]
ffff3e1c:	0b2440a4 	add	w4, w5, w4, uxtw	; w4 += x
ffff3e20:	12001c84 	and	w4, w4, #0xff		; w4 &= 0xff
ffff3e24:	38644846 	ldrb	w6, [x2, w4, uxtw]	; code[..]
ffff3e28:	38234846 	strb	w6, [x2, w3, uxtw]	; code[..]
ffff3e2c:	38244845 	strb	w5, [x2, w4, uxtw]	; code[..]
ffff3e30:	38634846 	ldrb	w6, [x2, w3, uxtw]	; code[..]
ffff3e34:	0b2540c5 	add	w5, w6, w5, uxtw	; w5 += w6
ffff3e38:	12001ca5 	and	w5, w5, #0xff		; w5 &= 0xff

ffff3e3c:	39400006 	ldrb	w6, [x0]		; w6 = *buf
ffff3e40:	38654845 	ldrb	w5, [x2, w5, uxtw]	; w5 = code[w5]
ffff3e44:	4a0600a5 	eor	w5, w5, w6		; w5 = w5 ^ w6
ffff3e48:	39000005 	strb	w5, [x0]		; *buf = w5

ffff3e4c:	91000400 	add	x0, x0, #0x1		; x0++
ffff3e50:	51000421 	sub	w1, w1, #0x1		; w1--
ffff3e54:	35fffde1 	cbnz	w1, 0xffff3e10

ffff3e58:	d65f03c0 	ret

; Here is the block used to "uncrypt" in the above
;
;	ffff4c68: 00000000 62987d7a
;	ffff4c70: 00000000 be3d3a96
;	ffff4c78: 00000000 1246c185
;	ffff4c80: 00000000 89ebc6ac
;	ffff4c88: 00000000 780fbd97
;	ffff4c90: 00000000 e2b5da8b
;	ffff4c98: 00000000 dc613427
;	ffff4ca0: 00000000 0ee6f5ed
;	ffff4ca8: 00000000 72eceed6
;	ffff4cb0: 00000000 4f041a31
;	ffff4cb8: 00000000 254e70db
;	ffff4cc0: 00000000 6fc37ece
;	ffff4cc8: 00000000 9059793c
;	ffff4cd0: 00000000 c9335374
;	ffff4cd8: 00000000 42115884
;	ffff4ce0: 00000000 755b5d0a
;	ffff4ce8: 00000000 40c8b067
;	ffff4cf0: 00000000 cd602d2f
;	ffff4cf8: 00000000 249c555e
;	ffff4d00: 00000000 e0aa717c
;	ffff4d08: 00000000 cc6b8613
;	ffff4d10: 00000000 b4fea3a8
;	ffff4d18: 00000000 17191076
;	ffff4d20: 00000000 1429bff3
;	ffff4d28: 00000000 5f2c2a0b
;	ffff4d30: 00000000 41fff748
;	ffff4d38: 00000000 d3056ad8
;	ffff4d40: 00000000 d477355c
;	ffff4d48: 00000000 e4267ff1
;	ffff4d50: 00000000 00f0471c
;	ffff4d58: 00000000 9a8eb822
;	ffff4d60: 00000000 a74d2bbc
;	ffff4d68: 00000000 3b203609
;	ffff4d70: 00000000 8f9dc266
;	ffff4d78: 00000000 e1f87bf9
;	ffff4d80: 00000000 e8e76980
;	ffff4d88: 00000000 3ebba592
;	ffff4d90: 00000000 9b308ad2
;	ffff4d98: 00000000 4916afd0
;	ffff4da0: 00000000 ca4aa2cb
;	ffff4da8: 00000000 9f64d51e
;	ffff4db0: 00000000 c7d1f4e9
;	ffff4db8: 00000000 c5b7886e
;	ffff4dc0: 00000000 56abb344
;	ffff4dc8: 00000000 4c6883fd
;	ffff4dd0: 00000000 9ea1b9ae
;	ffff4dd8: 00000000 43ea1f08
;	ffff4de0: 00000000 816dfa15
;	ffff4de8: 00000000 028c2ed9
;	ffff4df0: 00000000 52b632ef
;	ffff4df8: 00000000 215a0cdf
;	ffff4e00: 00000000 fb5028cf
;	ffff4e08: 00000000 45013f39
;	ffff4e10: 00000000 51b263d7
;	ffff4e18: 00000000 a49123de
;	ffff4e20: 00000000 65dde354
;	ffff4e28: 00000000 99731d07
;	ffff4e30: 00000000 ad1ba093
;	ffff4e38: 00000000 c4a9066c
;	ffff4e40: 00000000 e5948737
;	ffff4e48: 00000000 1895c003
;	ffff4e50: 00000000 f282b14b
;	ffff4e58: 00000000 5738ba8d
;	ffff4e60: 00000000 fca60df6

; ======================================================
; Subroutine - called in 2 places
;
; this fiddles with the Efuse1, so here are some notes
; Efuse1 is the secure mode fuse array.
; The fuse array is 32 items of 32 bits each
; These are OTP cells.
; reg 0 is CTL
;
; My study of this routine has me scratching my head.
; Athough we read 2 locations from the efuse,
; the second one overwrites the first.
; And beyond that, they are written to temp locations
; on the stack and I can see no way they get passed to
; the outside world, so it would seem that calling this
; routine is just a waste of time beyond "warming up"
; the efuse.
; Perhaps I am missing something, but I don't think so.

ffff3e5c:	d10143ff 	sub	sp, sp, #0x50
ffff3e60:	a9047bfd 	stp	x29, x30, [sp, #64]
ffff3e64:	910103fd 	add	x29, sp, #0x40
ffff3e68:	a90363f7 	stp	x23, x24, [sp, #48]
ffff3e6c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffff3e70:	a90153f3 	stp	x19, x20, [sp, #16]

ffff3e74:	d2bfff53 	mov	x19, #0xfffa0000	; Efuse1
ffff3e78:	52802134 	mov	w20, #0x109
ffff3e7c:	b9000274 	str	w20, [x19]		; ctl = 0x109
ffff3e80:	52800020 	mov	w0, #0x1
ffff3e84:	97fff2eb 	bl	0xffff0a30		; xxdelay(1)
ffff3e88:	52802115 	mov	w21, #0x108
ffff3e8c:	b9000275 	str	w21, [x19]		; ctl = 0x108
ffff3e90:	52800020 	mov	w0, #0x1
ffff3e94:	97fff2e7 	bl	0xffff0a30		; xxdelay(1)
ffff3e98:	52802196 	mov	w22, #0x10c
ffff3e9c:	b9000276 	str	w22, [x19]		; ctl = 0x10c
ffff3ea0:	52800020 	mov	w0, #0x1
ffff3ea4:	97fff2e3 	bl	0xffff0a30		; xxdelay(1)
ffff3ea8:	b9000276 	str	w22, [x19]		; ctl = 0x10c
ffff3eac:	52800020 	mov	w0, #0x1
ffff3eb0:	97fff2e0 	bl	0xffff0a30		; xxdelay(1)
ffff3eb4:	528021c0 	mov	w0, #0x10e
ffff3eb8:	b9000260 	str	w0, [x19]		; ctl = 0x10e
ffff3ebc:	52800020 	mov	w0, #0x1
ffff3ec0:	97fff2dc 	bl	0xffff0a30		; xxdelay(1)

ffff3ec4:	d0000000 	adrp	x0, 0xffff5000
ffff3ec8:	b9413817 	ldr	w23, [x0, #0x138]	; ffff5138: fffa0004

ffff3ecc:	b94002e0 	ldr	w0, [x23]	; read efuse data

ffff3ed0:	d0000001 	adrp	x1, 0xffff5000
ffff3ed4:	b9413c38 	ldr	w24, [x1, #0x13c]	; ffff513c: fffa0008

ffff3ed8:	b9000be0 	str	w0, [sp, #8]	; save efuse data
ffff3edc:	b9400300 	ldr	w0, [x24]	; read efuse RF
ffff3ee0:	b9000fe0 	str	w0, [sp, #12]	; save it also

ffff3ee4:	b9000276 	str	w22, [x19]		; ctl = 0x10c
ffff3ee8:	52800020 	mov	w0, #0x1
ffff3eec:	97fff2d1 	bl	0xffff0a30		; xxdelay(1)
ffff3ef0:	b9000275 	str	w21, [x19]		; ctl = 0x108
ffff3ef4:	52800020 	mov	w0, #0x1
ffff3ef8:	97fff2ce 	bl	0xffff0a30		; xxdelay(1)
ffff3efc:	b9000276 	str	w22, [x19]		; ctl = 0x10c
ffff3f00:	52800020 	mov	w0, #0x1
ffff3f04:	97fff2cb 	bl	0xffff0a30		; xxdelay(1)

ffff3f08:	d0000000 	adrp	x0, 0xffff5000
ffff3f0c:	b9414015 	ldr	w21, [x0, #0x140]	; ffff5140: 0010010c
ffff3f10:	b9000275 	str	w21, [x19]		; ctl = 0x0010010c
ffff3f14:	52800020 	mov	w0, #0x1
ffff3f18:	97fff2c6 	bl	0xffff0a30		; xxdelay(1)
ffff3f1c:	d0000000 	adrp	x0, 0xffff5000
ffff3f20:	b9414400 	ldr	w0, [x0, #0x144]	; ffff5144: 0010010e
ffff3f24:	b9000260 	str	w0, [x19]		; ctl = 0x0010010e
ffff3f28:	52800020 	mov	w0, #0x1
ffff3f2c:	97fff2c1 	bl	0xffff0a30		; xxdelay(1)

ffff3f30:	b94002e0 	ldr	w0, [x23]	; read efuse data

; This would seem to overwrite the first efuse read.

ffff3f34:	b9000be0 	str	w0, [sp, #8]	; save efuse data
ffff3f38:	b9400300 	ldr	w0, [x24]	; read efuse RF
ffff3f3c:	b9000fe0 	str	w0, [sp, #12]	; save it also

ffff3f40:	b9000275 	str	w21, [x19]		; ctl = 0x0010010c
ffff3f44:	52800020 	mov	w0, #0x1
ffff3f48:	97fff2ba 	bl	0xffff0a30		; xxdelay(1)
ffff3f4c:	b9000274 	str	w20, [x19]		; ctl = 0x0010010c

ffff3f50:	aa1f03e0 	mov	x0, xzr
ffff3f54:	a94153f3 	ldp	x19, x20, [sp, #16]
ffff3f58:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffff3f5c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffff3f60:	a9447bfd 	ldp	x29, x30, [sp, #64]
ffff3f64:	910143ff 	add	sp, sp, #0x50
ffff3f68:	d65f03c0 	ret

; subroutine, called from 5 places
; "read_efuse ( buf, addr, count )
; read a block (but usually just one) from Efuse1
;  r0 = addr
;  r1 = efuse addr ?
;  r2 = count to read

ffff3f6c:	d10103ff 	sub	sp, sp, #0x40
ffff3f70:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff3f74:	9100c3fd 	add	x29, sp, #0x30
ffff3f78:	a90263f7 	stp	x23, x24, [sp, #32]
ffff3f7c:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff3f80:	a90053f3 	stp	x19, x20, [sp]

ffff3f84:	aa0203f3 	mov	x19, x2		; count
ffff3f88:	aa0103f5 	mov	x21, x1		; efuse address ?
ffff3f8c:	aa0003f4 	mov	x20, x0		; put data here

ffff3f90:	d2bfff56 	mov	x22, #0xfffa0000	; Efuse1
ffff3f94:	52800137 	mov	w23, #0x9
ffff3f98:	b90002d7 	str	w23, [x22]		; ctl = 0x9
ffff3f9c:	52800020 	mov	w0, #0x1
ffff3fa0:	97fff2a4 	bl	0xffff0a30		; xxdelay(1)
ffff3fa4:	52800100 	mov	w0, #0x8
ffff3fa8:	b90002c0 	str	w0, [x22]		; ctl = 0x8
ffff3fac:	52800020 	mov	w0, #0x1
ffff3fb0:	97fff2a0 	bl	0xffff0a30		; xxdelay(1)
ffff3fb4:	52800180 	mov	w0, #0xc
ffff3fb8:	b90002c0 	str	w0, [x22]		; ctl = 0xc
ffff3fbc:	52800020 	mov	w0, #0x1
ffff3fc0:	97fff29c 	bl	0xffff0a30		; xxdelay(1)

ffff3fc4:	340002b3 	cbz	w19, 0xffff4018		; nothing to do

ffff3fc8:	528001c0 	mov	w0, #0xe
ffff3fcc:	2a154015 	orr	w21, w0, w21, lsl #16

; loop
ffff3fd0:	51000ab8 	sub	w24, w21, #0x2
ffff3fd4:	b90002d8 	str	w24, [x22]
ffff3fd8:	52800020 	mov	w0, #0x1
ffff3fdc:	97fff295 	bl	0xffff0a30		; xxdelay(1)
ffff3fe0:	b90002d5 	str	w21, [x22]
ffff3fe4:	52800020 	mov	w0, #0x1
ffff3fe8:	97fff292 	bl	0xffff0a30		; xxdelay(1)
ffff3fec:	d0000000 	adrp	x0, 0xffff5000
ffff3ff0:	b9414800 	ldr	w0, [x0, #0x148]	; ffff5148: fffa0004
ffff3ff4:	b9400000 	ldr	w0, [x0]		; efuse data
ffff3ff8:	b9000280 	str	w0, [x20]		; deposit data
ffff3ffc:	b90002d8 	str	w24, [x22]
ffff4000:	52800020 	mov	w0, #0x1
ffff4004:	97fff28b 	bl	0xffff0a30		; xxdelay(1)
ffff4008:	91001294 	add	x20, x20, #0x4
ffff400c:	51000673 	sub	w19, w19, #0x1
ffff4010:	114042b5 	add	w21, w21, #0x10, lsl #12
ffff4014:	35fffdf3 	cbnz	w19, 0xffff3fd0

ffff4018:	b90002d7 	str	w23, [x22]		; ctl = 0x9

ffff401c:	aa1f03e0 	mov	x0, xzr
ffff4020:	a94053f3 	ldp	x19, x20, [sp]
ffff4024:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff4028:	a94263f7 	ldp	x23, x24, [sp, #32]
ffff402c:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff4030:	910103ff 	add	sp, sp, #0x40
ffff4034:	d65f03c0 	ret

; subroutine - called from one place
; more Efuse-1 manipulation
ffff4038:	d10103ff 	sub	sp, sp, #0x40
ffff403c:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff4040:	9100c3fd 	add	x29, sp, #0x30
ffff4044:	a90263f7 	stp	x23, x24, [sp, #32]
ffff4048:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff404c:	a90053f3 	stp	x19, x20, [sp]
ffff4050:	aa0203f3 	mov	x19, x2
ffff4054:	aa0103f5 	mov	x21, x1
ffff4058:	aa0003f4 	mov	x20, x0
ffff405c:	d2bfff56 	mov	x22, #0xfffa0000	; Efuse1
ffff4060:	52800937 	mov	w23, #0x49                  	// #73
ffff4064:	b90002d7 	str	w23, [x22]
ffff4068:	52800020 	mov	w0, #0x1                   	// #1
ffff406c:	97fff271 	bl	0xffff0a30		; xxdelay(1)
ffff4070:	52800900 	mov	w0, #0x48                  	// #72
ffff4074:	b90002c0 	str	w0, [x22]
ffff4078:	52800020 	mov	w0, #0x1                   	// #1
ffff407c:	97fff26d 	bl	0xffff0a30		; xxdelay(1)
ffff4080:	52800980 	mov	w0, #0x4c                  	// #76
ffff4084:	b90002c0 	str	w0, [x22]
ffff4088:	52800020 	mov	w0, #0x1                   	// #1
ffff408c:	97fff269 	bl	0xffff0a30		; xxdelay(1)
ffff4090:	340002b3 	cbz	w19, 0xffff40e4
ffff4094:	528009c0 	mov	w0, #0x4e                  	// #78
ffff4098:	2a154015 	orr	w21, w0, w21, lsl #16
ffff409c:	51000ab8 	sub	w24, w21, #0x2
ffff40a0:	b90002d8 	str	w24, [x22]
ffff40a4:	52800020 	mov	w0, #0x1                   	// #1
ffff40a8:	97fff262 	bl	0xffff0a30		; xxdelay(1)
ffff40ac:	b90002d5 	str	w21, [x22]
ffff40b0:	52800020 	mov	w0, #0x1                   	// #1
ffff40b4:	97fff25f 	bl	0xffff0a30		; xxdelay(1)
ffff40b8:	b0000000 	adrp	x0, 0xffff5000
ffff40bc:	b9414c00 	ldr	w0, [x0, #0x14c]	; ffff514c: fffa0004
ffff40c0:	b9400000 	ldr	w0, [x0]
ffff40c4:	b9000280 	str	w0, [x20]
ffff40c8:	b90002d8 	str	w24, [x22]
ffff40cc:	52800020 	mov	w0, #0x1                   	// #1
ffff40d0:	97fff258 	bl	0xffff0a30		; xxdelay(1)
ffff40d4:	91001294 	add	x20, x20, #0x4
ffff40d8:	51000673 	sub	w19, w19, #0x1
ffff40dc:	114042b5 	add	w21, w21, #0x10, lsl #12
ffff40e0:	35fffdf3 	cbnz	w19, 0xffff409c
ffff40e4:	b90002d7 	str	w23, [x22]
ffff40e8:	aa1f03e0 	mov	x0, xzr
ffff40ec:	a94053f3 	ldp	x19, x20, [sp]
ffff40f0:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff40f4:	a94263f7 	ldp	x23, x24, [sp, #32]
ffff40f8:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff40fc:	910103ff 	add	sp, sp, #0x40
ffff4100:	d65f03c0 	ret
ffff4104:	d10103ff 	sub	sp, sp, #0x40
ffff4108:	a9037bfd 	stp	x29, x30, [sp, #48]
ffff410c:	9100c3fd 	add	x29, sp, #0x30
ffff4110:	a90263f7 	stp	x23, x24, [sp, #32]
ffff4114:	a9015bf5 	stp	x21, x22, [sp, #16]
ffff4118:	a90053f3 	stp	x19, x20, [sp]
ffff411c:	aa0103f3 	mov	x19, x1
ffff4120:	aa0003f4 	mov	x20, x0
ffff4124:	12800000 	mov	w0, #0xffffffff            	// #-1
ffff4128:	71007e9f 	cmp	w20, #0x1f
ffff412c:	54000968 	b.hi	0xffff4258  // b.pmore
ffff4130:	34000933 	cbz	w19, 0xffff4254
ffff4134:	d2bfef20 	mov	x0, #0xff790000		; GPIO4
ffff4138:	b9400001 	ldr	w1, [x0]
ffff413c:	32050021 	orr	w1, w1, #0x8000000
ffff4140:	b9000001 	str	w1, [x0]
ffff4144:	52807d00 	mov	w0, #0x3e8                 	// #1000
ffff4148:	97fff23a 	bl	0xffff0a30		; xxdelay(1000)
ffff414c:	d2bfff55 	mov	x21, #0xfffa0000	; Efuse1
ffff4150:	528011a0 	mov	w0, #0x8d                  	// #141
ffff4154:	b90002a0 	str	w0, [x21]
ffff4158:	52800036 	mov	w22, #0x1                   	// #1
ffff415c:	52800020 	mov	w0, #0x1                   	// #1
ffff4160:	97fff234 	bl	0xffff0a30		; xxdelay(1)
ffff4164:	528013a0 	mov	w0, #0x9d                  	// #157
ffff4168:	b90002a0 	str	w0, [x21]
ffff416c:	52800020 	mov	w0, #0x1                   	// #1
ffff4170:	97fff230 	bl	0xffff0a30		; xxdelay(1)
ffff4174:	52801380 	mov	w0, #0x9c                  	// #156
ffff4178:	b90002a0 	str	w0, [x21]
ffff417c:	52800020 	mov	w0, #0x1                   	// #1
ffff4180:	97fff22c 	bl	0xffff0a30		; xxdelay(1)
ffff4184:	52801297 	mov	w23, #0x94                  	// #148
ffff4188:	b90002b7 	str	w23, [x21]
ffff418c:	52800020 	mov	w0, #0x1                   	// #1
ffff4190:	97fff228 	bl	0xffff0a30		; xxdelay(1)
ffff4194:	b90002b7 	str	w23, [x21]
ffff4198:	52800020 	mov	w0, #0x1                   	// #1
ffff419c:	97fff225 	bl	0xffff0a30		; xxdelay(1)
ffff41a0:	52801200 	mov	w0, #0x90                  	// #144
ffff41a4:	b90002a0 	str	w0, [x21]
ffff41a8:	52800020 	mov	w0, #0x1                   	// #1
ffff41ac:	97fff221 	bl	0xffff0a30		; xxdelay(1)
ffff41b0:	2a1f03f7 	mov	w23, wzr
ffff41b4:	52801240 	mov	w0, #0x92                  	// #146
ffff41b8:	2a144014 	orr	w20, w0, w20, lsl #16
ffff41bc:	1ad722c0 	lsl	w0, w22, w23
ffff41c0:	0a130000 	and	w0, w0, w19
ffff41c4:	34000160 	cbz	w0, 0xffff41f0
ffff41c8:	51000a98 	sub	w24, w20, #0x2
ffff41cc:	b90002b8 	str	w24, [x21]
ffff41d0:	52800020 	mov	w0, #0x1                   	// #1
ffff41d4:	97fff217 	bl	0xffff0a30		; xxdelay(1)
ffff41d8:	b90002b4 	str	w20, [x21]
ffff41dc:	52800020 	mov	w0, #0x1                   	// #1
ffff41e0:	97fff214 	bl	0xffff0a30		; xxdelay(1)
ffff41e4:	b90002b8 	str	w24, [x21]
ffff41e8:	52800020 	mov	w0, #0x1                   	// #1
ffff41ec:	97fff211 	bl	0xffff0a30		; xxdelay(1)
ffff41f0:	110006f7 	add	w23, w23, #0x1
ffff41f4:	11480294 	add	w20, w20, #0x200, lsl #12
ffff41f8:	710082ff 	cmp	w23, #0x20
ffff41fc:	54fffe01 	b.ne	0xffff41bc  // b.any
ffff4200:	d2bfff53 	mov	x19, #0xfffa0000	; Efuse1
ffff4204:	52801200 	mov	w0, #0x90                  	// #144
ffff4208:	b9000260 	str	w0, [x19]
ffff420c:	52800020 	mov	w0, #0x1                   	// #1
ffff4210:	97fff208 	bl	0xffff0a30		; xxdelay(1)
ffff4214:	52801300 	mov	w0, #0x98                  	// #152
ffff4218:	b9000260 	str	w0, [x19]
ffff421c:	52800020 	mov	w0, #0x1                   	// #1
ffff4220:	97fff204 	bl	0xffff0a30		; xxdelay(1)
ffff4224:	52801320 	mov	w0, #0x99                  	// #153
ffff4228:	b9000260 	str	w0, [x19]
ffff422c:	52800020 	mov	w0, #0x1                   	// #1
ffff4230:	97fff200 	bl	0xffff0a30		; xxdelay(1)
ffff4234:	52801120 	mov	w0, #0x89                  	// #137
ffff4238:	b9000260 	str	w0, [x19]
ffff423c:	d2bfef20 	mov	x0, #0xff790000		; GPIO4
ffff4240:	b9400001 	ldr	w1, [x0]
ffff4244:	12047821 	and	w1, w1, #0xf7ffffff
ffff4248:	b9000001 	str	w1, [x0]
ffff424c:	5280fa00 	mov	w0, #0x7d0                 	// #2000
ffff4250:	97fff1f8 	bl	0xffff0a30		; xxdelay(2000)
ffff4254:	2a1f03e0 	mov	w0, wzr
ffff4258:	a94053f3 	ldp	x19, x20, [sp]
ffff425c:	a9415bf5 	ldp	x21, x22, [sp, #16]
ffff4260:	a94263f7 	ldp	x23, x24, [sp, #32]
ffff4264:	a9437bfd 	ldp	x29, x30, [sp, #48]
ffff4268:	910103ff 	add	sp, sp, #0x40
ffff426c:	d65f03c0 	ret
ffff4270:	d10043ff 	sub	sp, sp, #0x10
ffff4274:	a9007bfd 	stp	x29, x30, [sp]
ffff4278:	910003fd 	mov	x29, sp
ffff427c:	d2bfff40 	mov	x0, #0xfffa0000	; Efuse1
ffff4280:	52801521 	mov	w1, #0xa9                  	// #169
ffff4284:	b9000001 	str	w1, [x0]
ffff4288:	52800020 	mov	w0, #0x1                   	// #1
ffff428c:	97fff1e9 	bl	0xffff0a30		; xxdelay(1)
ffff4290:	aa1f03e0 	mov	x0, xzr
ffff4294:	a9407bfd 	ldp	x29, x30, [sp]
ffff4298:	910043ff 	add	sp, sp, #0x10
ffff429c:	d65f03c0 	ret

ffff42a0:	d100c3ff 	sub	sp, sp, #0x30
ffff42a4:	a9027bfd 	stp	x29, x30, [sp, #32]
ffff42a8:	910083fd 	add	x29, sp, #0x20
ffff42ac:	a90157f4 	stp	x20, x21, [sp, #16]
ffff42b0:	f90007f3 	str	x19, [sp, #8]
ffff42b4:	aa0103f3 	mov	x19, x1
ffff42b8:	aa0003f4 	mov	x20, x0
ffff42bc:	2a1f03e0 	mov	w0, wzr
ffff42c0:	b90007ff 	str	wzr, [sp, #4]
ffff42c4:	34000333 	cbz	w19, 0xffff4328
ffff42c8:	910013f5 	add	x21, sp, #0x4

ffff42cc:	52800022 	mov	w2, #0x1	; read 1 word
ffff42d0:	aa1503e0 	mov	x0, x21		; put it here
ffff42d4:	aa1403e1 	mov	x1, x20		; from this efuse
ffff42d8:	97ffff25 	bl	0xffff3f6c	; read_efuse()
ffff42dc:	b94007e0 	ldr	w0, [sp, #4]	; fetch it
ffff42e0:	0a200261 	bic	w1, w19, w0
ffff42e4:	aa1403e0 	mov	x0, x20
ffff42e8:	97ffff87 	bl	0xffff4104
ffff42ec:	d2bfff40 	mov	x0, #0xfffa0000	; Efuse1
ffff42f0:	52801521 	mov	w1, #0xa9
ffff42f4:	b9000001 	str	w1, [x0]	; efuse ctl
ffff42f8:	52800020 	mov	w0, #0x1
ffff42fc:	97fff1cd 	bl	0xffff0a30	; xxdelay(1)
ffff4300:	97fffed7 	bl	0xffff3e5c	; read efuse (waste)
ffff4304:	52800022 	mov	w2, #0x1
ffff4308:	aa1503e0 	mov	x0, x21
ffff430c:	aa1403e1 	mov	x1, x20
ffff4310:	97ffff4a 	bl	0xffff4038	; efuse stuff
ffff4314:	b94007e0 	ldr	w0, [sp, #4]
ffff4318:	2a2003e0 	mvn	w0, w0
ffff431c:	6a13001f 	tst	w0, w19
ffff4320:	1a9f07e0 	cset	w0, ne  // ne = any
ffff4324:	12000000 	and	w0, w0, #0x1
ffff4328:	f94007f3 	ldr	x19, [sp, #8]
ffff432c:	a94157f4 	ldp	x20, x21, [sp, #16]
ffff4330:	a9427bfd 	ldp	x29, x30, [sp, #32]
ffff4334:	9100c3ff 	add	sp, sp, #0x30
ffff4338:	d65f03c0 	ret

; ==============================================================
; ==============================================================
; ==============================================================

; first core starting up comes here.  GO!
;  You might call this "main()"

; Startup branches here, it does NOT do a "bl"
;
; My notation here SRAM[x] refers to 32 bit objects in SRAM

; Here we have the usual subroutine prolog
ffff433c:	d10043ff 	sub	sp, sp, #0x10		; 16 bytes on stack
ffff4340:	a9007bfd 	stp	x29, x30, [sp]		; save 2 registers
ffff4344:	910003fd 	mov	x29, sp			; get sp

; post initial cpu clock speed of 24 Mhz
ffff4348:	52800300 	mov	w0, #0x18		; w0 = 24
ffff434c:	97fff1b6 	bl	0xffff0a24		; SRAM[0] = 24

ffff4350:	97fff1dc 	bl	0xffff0ac0		; CRU setup
ffff4354:	90ffc660 	adrp	x0, 0xff8c0000
ffff4358:	b9000c1f 	str	wzr, [x0, #12]		; SRAM[3] = 0

ffff435c:	97fff02b 	bl	0xffff0408
ffff4360:	97fff207 	bl	0xffff0b7c		; CRU, cpu clocks
ffff4364:	90ffc660 	adrp	x0, 0xff8c0000
ffff4368:	b900101f 	str	wzr, [x0, #16]		; SRAM[4] = 0

ffff436c:	97fff900 	bl	0xffff276c		; try_four ()
ffff4370:	97fffe75 	bl	0xffff3d44		; usb_spin ()

ffff4374:	14000000 	b	0xffff4374		; spin

; ==============================================================

; subroutine, several calls

ffff4378:	2a010003 	orr	w3, w0, w1
ffff437c:	12000463 	and	w3, w3, #0x3
ffff4380:	7100007f 	cmp	w3, #0x0
ffff4384:	540003a1 	b.ne	0xffff43f8
; The above checks if both arguments are 8 byte aligned
; if so, we fall through to here

ffff4388:	f100105f 	cmp	x2, #0x4
ffff438c:	54000363 	b.cc	0xffff43f8

ffff4390:	d1001042 	sub	x2, x2, #0x4
ffff4394:	b8404403 	ldr	w3, [x0], #4
ffff4398:	b8404424 	ldr	w4, [x1], #4
ffff439c:	6b04007f 	cmp	w3, w4
ffff43a0:	54ffff40 	b.eq	0xffff4388
ffff43a4:	12001c60 	and	w0, w3, #0xff
ffff43a8:	12001c81 	and	w1, w4, #0xff
ffff43ac:	4b010000 	sub	w0, w0, w1
ffff43b0:	d3407c00 	ubfx	x0, x0, #0, #32
ffff43b4:	f100001f 	cmp	x0, #0x0
ffff43b8:	540001e1 	b.ne	0xffff43f4
ffff43bc:	12003c60 	and	w0, w3, #0xffff
ffff43c0:	12003c81 	and	w1, w4, #0xffff
ffff43c4:	4b010000 	sub	w0, w0, w1
ffff43c8:	d3407c00 	ubfx	x0, x0, #0, #32
ffff43cc:	f100001f 	cmp	x0, #0x0
ffff43d0:	54000121 	b.ne	0xffff43f4
ffff43d4:	12005c60 	and	w0, w3, #0xffffff
ffff43d8:	12005c81 	and	w1, w4, #0xffffff
ffff43dc:	4b010000 	sub	w0, w0, w1
ffff43e0:	d3407c00 	ubfx	x0, x0, #0, #32
ffff43e4:	f100001f 	cmp	x0, #0x0
ffff43e8:	54000061 	b.ne	0xffff43f4

ffff43ec:	53187c60 	lsr	w0, w3, #24
ffff43f0:	4b446000 	sub	w0, w0, w4, lsr #24
ffff43f4:	d65f03c0 	ret

; check count, return 0 if 0
ffff43f8:	f100005f 	cmp	x2, #0x0
ffff43fc:	54000061 	b.ne	0xffff4408
ffff4400:	52800000 	mov	w0, #0x0
ffff4404:	d65f03c0 	ret

ffff4408:	92400043 	and	x3, x2, #0x1
ffff440c:	f100007f 	cmp	x3, #0x0
ffff4410:	54000060 	b.eq	0xffff441c
ffff4414:	91000442 	add	x2, x2, #0x1
ffff4418:	14000005 	b	0xffff442c
ffff441c:	38401403 	ldrb	w3, [x0], #1
ffff4420:	38401424 	ldrb	w4, [x1], #1
ffff4424:	6b040063 	subs	w3, w3, w4
ffff4428:	54000101 	b.ne	0xffff4448
ffff442c:	38401403 	ldrb	w3, [x0], #1
ffff4430:	38401424 	ldrb	w4, [x1], #1
ffff4434:	6b040063 	subs	w3, w3, w4
ffff4438:	54000081 	b.ne	0xffff4448
ffff443c:	d1000842 	sub	x2, x2, #0x2
ffff4440:	f100005f 	cmp	x2, #0x0
ffff4444:	54fffec1 	b.ne	0xffff441c
ffff4448:	2a0303e0 	mov	w0, w3
ffff444c:	d65f03c0 	ret

;  ==============================================

; subroutine, many calls --- memcpy
; just a wrapper around call to ffff4534
;  and the only call to that routine (so why not inline it?)
; x0 = destination address (usually in SRAM)
; x1 =  source address
; x2 = count (commonly 0x100, but not always)

ffff4450:	d10083ff 	sub	sp, sp, #0x20	; standard prolog
ffff4454:	f9000bfe 	str	x30, [sp, #16]
ffff4458:	a90077f3 	stp	x19, x29, [sp]
ffff445c:	910023fd 	add	x29, sp, #0x8

ffff4460:	aa0003f3 	mov	x19, x0		; preserve x0
ffff4464:	94000034 	bl	0xffff4534
ffff4468:	aa1303e0 	mov	x0, x19

ffff446c:	a94077f3 	ldp	x19, x29, [sp]
ffff4470:	f9400bfe 	ldr	x30, [sp, #16]
ffff4474:	910083ff 	add	sp, sp, #0x20
ffff4478:	d65f03c0 	ret

;  ==============================================
;
; subroutine, "memset"
;
; a typical call looks like this and never cares about
; a return value in x0.

;		mov	x2, #0x28
;		mov	x0, x20
;		mov	x1, xzr
;		bl	0xffff447c
;
;	So x0 is some sort of address, x1 is always zero, x2 is a count

ffff447c:	d10083ff 	sub	sp, sp, #0x20	; standard prolog
ffff4480:	f9000bfe 	str	x30, [sp, #16]
ffff4484:	a90077f3 	stp	x19, x29, [sp]
ffff4488:	910023fd 	add	x29, sp, #0x8

; This is memset.
; we take the value in x1 as a byte and duplicate it 4 times in w2
; the count (in bytes) we do not change, but we do move
; the count and address to different registers

ffff448c:	aa0003f3 	mov	x19, x0		; preserve x0 (addr)
ffff4490:	2a0103e0 	mov	w0, w1		; x0 = val
ffff4494:	aa0203e1 	mov	x1, x2		; x1 = count
ffff4498:	12001c03 	and	w3, w0, #0xff		; w3 = val & 0xff
ffff449c:	0b032063 	add	w3, w3, w3, lsl #8	; w3 = val<<8 + val
ffff44a0:	0b034062 	add	w2, w3, w3, lsl #16	; w2 = w3<<16 + w3
ffff44a4:	aa1303e0 	mov	x0, x19		; restore x0 (addr)

; It is odd that this is the only call to a block of code below
; why not just put it inline right here?
; why jam "memcpy" between here and there?

; at this point --
; x0 is some address
; x1 is a count
; w2 is a value to store

ffff44a8:	94000066 	bl	0xffff4640

ffff44ac:	aa1303e0 	mov	x0, x19		; restore x0 for the caller

ffff44b0:	a94077f3 	ldp	x19, x29, [sp]	; proper return
ffff44b4:	f9400bfe 	ldr	x30, [sp, #16]
ffff44b8:	910083ff 	add	sp, sp, #0x20
ffff44bc:	d65f03c0 	ret

; ==========================================

; Accessory and "finish" to memcpy below.

; We jump here from the memcpy code below
; This copies from x1 to x0 with a count in x2
; Something has been done such that x0 and x1 are 16 byte aligned
; to start this loop.  It takes care of any extra bytes at
; the end

; what is this instruction doing?  It is a jump into the loop below
; it is jumped to from the memcpy code below.
; That code could just as well jump directly to ffff44e0
;  but maybe someone thought it would be "proper" to jump to
; this instruction at the top of this code.
ffff44c0:	14000008 	b	0xffff44e0

; ---
; This loop moves 16 bytes at a time from *x1 to *x2
; It seems odd to use a two pairs of 32 bit "w" registers for this
; rather than a single pair of 64 bit registers.

ffff44c4:	29401023 	ldp	w3, w4, [x1]		; move 16 bytes
ffff44c8:	29411825 	ldp	w5, w6, [x1, #8]
ffff44cc:	29001003 	stp	w3, w4, [x0]
ffff44d0:	29011805 	stp	w5, w6, [x0, #8]
ffff44d4:	91004000 	add	x0, x0, #0x10
ffff44d8:	91004021 	add	x1, x1, #0x10
ffff44dc:	d1004042 	sub	x2, x2, #0x10

ffff44e0:	f100405f 	cmp	x2, #0x10
ffff44e4:	54ffff02 	b.cs	0xffff44c4  ; loop if x2 >= 0x10

ffff44e8:	f100205f 	cmp	x2, #0x8
ffff44ec:	540000c3 	b.cc	0xffff4504  ; branch if x2 < 8

ffff44f0:	29401023 	ldp	w3, w4, [x1]	; move 8 bytes
ffff44f4:	29001003 	stp	w3, w4, [x0]
ffff44f8:	91002000 	add	x0, x0, #0x8
ffff44fc:	91002021 	add	x1, x1, #0x8
ffff4500:	d1002042 	sub	x2, x2, #0x8

ffff4504:	f100105f 	cmp	x2, #0x4
ffff4508:	540000e3 	b.cc	0xffff4524  ; branch if x2 < 4

ffff450c:	b8404423 	ldr	w3, [x1], #4	; move 4 bytes
ffff4510:	b8004403 	str	w3, [x0], #4
ffff4514:	d1001042 	sub	x2, x2, #0x4
ffff4518:	14000003 	b	0xffff4524

; final loop to move 0,1,2, or 3 bytes
ffff451c:	38401423 	ldrb	w3, [x1], #1	; move 1 byte
ffff4520:	38001403 	strb	w3, [x0], #1

ffff4524:	d1000442 	sub	x2, x2, #0x1
ffff4528:	b100045f 	cmn	x2, #0x1
ffff452c:	54ffff81 	b.ne	0xffff451c

; a "bare" routine, so this must be called in some way
; that entered without a prolog.
ffff4530:	d65f03c0 	ret

;  ==============================================

; subroutine -- essentially memcpy ( dest, src, count)
; called only from the wrapper above
; the wrapper provides the prolog, this code is "bare"

ffff4534:	f100105f 	cmp	x2, #0x4
ffff4538:	540004e3 	b.cc	0xffff45d4
; here with count >= 4
ffff453c:	12000403 	and	w3, w0, #0x3
ffff4540:	7100007f 	cmp	w3, #0x0
ffff4544:	54000200 	b.eq	0xffff4584
ffff4548:	38401423 	ldrb	w3, [x1], #1	; move byte, postincrement
ffff454c:	38001403 	strb	w3, [x0], #1
ffff4550:	d1000442 	sub	x2, x2, #0x1
ffff4554:	12000403 	and	w3, w0, #0x3
ffff4558:	7100007f 	cmp	w3, #0x0
ffff455c:	54000140 	b.eq	0xffff4584
ffff4560:	38401423 	ldrb	w3, [x1], #1	; move byte, postincrement
ffff4564:	38001403 	strb	w3, [x0], #1
ffff4568:	d1000442 	sub	x2, x2, #0x1
ffff456c:	12000403 	and	w3, w0, #0x3
ffff4570:	7100007f 	cmp	w3, #0x0
ffff4574:	54000080 	b.eq	0xffff4584
ffff4578:	38401423 	ldrb	w3, [x1], #1	; move byte, postincrement
ffff457c:	38001403 	strb	w3, [x0], #1
ffff4580:	d1000442 	sub	x2, x2, #0x1

; here with 64 bit aligned address
ffff4584:	12000423 	and	w3, w1, #0x3
ffff4588:	7100007f 	cmp	w3, #0x0
ffff458c:	540000e0 	b.eq	0xffff45a8
ffff4590:	cb234021 	sub	x1, x1, w3, uxtw
ffff4594:	531d7065 	lsl	w5, w3, #3
ffff4598:	52800403 	mov	w3, #0x20                  	// #32
ffff459c:	4b050064 	sub	w4, w3, w5
ffff45a0:	b8404423 	ldr	w3, [x1], #4
ffff45a4:	14000008 	b	0xffff45c4

; We jump to code up above to finish the copy
; that code expects x0 and x1 to both be 16 byte aligned
; and will finish the copy, then return directly.

ffff45a8:	17ffffc6 	b	0xffff44c0	; odd jump to up above

; loop, move 4 bytes at a time.
ffff45ac:	1ac52466 	lsr	w6, w3, w5
ffff45b0:	b8404423 	ldr	w3, [x1], #4	; fetch, postincr
ffff45b4:	1ac42067 	lsl	w7, w3, w4
ffff45b8:	2a0600e6 	orr	w6, w7, w6
ffff45bc:	b8004406 	str	w6, [x0], #4	; store, postincr
ffff45c0:	d1001042 	sub	x2, x2, #0x4
ffff45c4:	f100105f 	cmp	x2, #0x4
ffff45c8:	54ffff22 	b.cs	0xffff45ac	; greater or equal unsigned

ffff45cc:	53037c83 	lsr	w3, w4, #3
ffff45d0:	cb234021 	sub	x1, x1, w3, uxtw

ffff45d4:	f1000442 	subs	x2, x2, #0x1
ffff45d8:	54000164 	b.mi	0xffff4604
ffff45dc:	38401423 	ldrb	w3, [x1], #1	; move byte, postincr
ffff45e0:	38001403 	strb	w3, [x0], #1
ffff45e4:	f1000442 	subs	x2, x2, #0x1
ffff45e8:	540000e4 	b.mi	0xffff4604
ffff45ec:	38401423 	ldrb	w3, [x1], #1	; move byte, postincr
ffff45f0:	38001403 	strb	w3, [x0], #1
ffff45f4:	f1000442 	subs	x2, x2, #0x1
ffff45f8:	54000064 	b.mi	0xffff4604
ffff45fc:	39400021 	ldrb	w1, [x1]	; move byte
ffff4600:	39000001 	strb	w1, [x0]
ffff4604:	d65f03c0 	ret

;  ==============================================
; This block of code is the guts to "memset" above
; who knows why it is floating around down here below memcpy
;
; x0 is some address
; x1 is a count
; w2 is a value to store

; loop A
ffff4608:	14000003 	b	0xffff4614

ffff460c:	b8004402 	str	w2, [x0], #4	; *x0++ = w2 (4 bytes)
ffff4610:	d1001021 	sub	x1, x1, #0x4
ffff4614:	f100103f 	cmp	x1, #0x4
ffff4618:	54ffffa2 	b.cs	0xffff460c	; loop while x1 >= 4

ffff461c:	927f0023 	and	x3, x1, #0x2
ffff4620:	f100007f 	cmp	x3, #0x0
ffff4624:	54000040 	b.eq	0xffff462c
ffff4628:	78002402 	strh	w2, [x0], #2	; *x0++ = w2 (2 bytes)
ffff462c:	92400021 	and	x1, x1, #0x1
ffff4630:	f100003f 	cmp	x1, #0x0
ffff4634:	54000040 	b.eq	0xffff463c
ffff4638:	39000002 	strb	w2, [x0]	; *x0 = w2 (1 byte)

ffff463c:	d65f03c0 	ret			; done

; loop B -- call to here from above
ffff4640:	f100043f 	cmp	x1, #0x1
ffff4644:	540000c3 	b.cc	0xffff465c	; branch if < 1
ffff4648:	12000003 	and	w3, w0, #0x1
ffff464c:	7100007f 	cmp	w3, #0x0
ffff4650:	54000060 	b.eq	0xffff465c
ffff4654:	38001402 	strb	w2, [x0], #1	; *x0++ = w2
ffff4658:	d1000421 	sub	x1, x1, #0x1
ffff465c:	f100083f 	cmp	x1, #0x2
ffff4660:	540000c3 	b.cc	0xffff4678	; branch if < 2
ffff4664:	121f0003 	and	w3, w0, #0x2
ffff4668:	7100007f 	cmp	w3, #0x0
ffff466c:	54000060 	b.eq	0xffff4678
ffff4670:	78002402 	strh	w2, [x0], #2	; *x0++ = w2
ffff4674:	d1000821 	sub	x1, x1, #0x2
ffff4678:	17ffffe4 	b	0xffff4608		; loop up A

; no path to here ...
ffff467c:	52800002 	mov	w2, #0x0
ffff4680:	17fffff0 	b	0xffff4640		; loop up B

; no path to here either ...
ffff4684:	52800002 	mov	w2, #0x0
ffff4688:	17ffffe0 	b	0xffff4608		; loop up A

;  ==============================================
; This is a nice simple delay loop
ffff468c:	f1000400 	subs	x0, x0, #0x1
ffff4690:	54ffffe8 	b.hi	0xffff468c
ffff4694:	d65f03c0 	ret

; We do branch here from above
; the only code that branches here loads xzr into x0 !!!
; So that would not be good.
ffff4698:	d61f0000 	br	x0			; go run at address in x0

ffff469c:	00000000 	udf	#0
ffff46a0:	00000000 	udf	#0
ffff46a4:	00000000 	udf	#0
ffff46a8:	00000000 	udf	#0
ffff46ac:	00000000 	udf	#0
ffff46b0:	00000000 	udf	#0
ffff46b4:	00000000 	udf	#0
ffff46b8:	00000000 	udf	#0
ffff46bc:	00000000 	udf	#0
ffff46c0:	00000000 	udf	#0
ffff46c4:	00000000 	udf	#0
ffff46c8:	00000000 	udf	#0
ffff46cc:	00000000 	udf	#0
ffff46d0:	00000000 	udf	#0
ffff46d4:	00000000 	udf	#0
ffff46d8:	00000000 	udf	#0
ffff46dc:	00000000 	udf	#0
ffff46e0:	00000000 	udf	#0
ffff46e4:	00000000 	udf	#0
ffff46e8:	00000000 	udf	#0
ffff46ec:	00000000 	udf	#0
ffff46f0:	00000000 	udf	#0
ffff46f4:	00000000 	udf	#0
ffff46f8:	00000000 	udf	#0
ffff46fc:	00000000 	udf	#0
ffff4700:	00000000 	udf	#0
ffff4704:	00000000 	udf	#0
ffff4708:	00000000 	udf	#0
ffff470c:	00000000 	udf	#0
ffff4710:	00000000 	udf	#0
ffff4714:	00000000 	udf	#0
ffff4718:	00000000 	udf	#0
ffff471c:	00000000 	udf	#0
ffff4720:	00000000 	udf	#0
ffff4724:	00000000 	udf	#0
ffff4728:	00000000 	udf	#0
ffff472c:	00000000 	udf	#0
ffff4730:	00000000 	udf	#0
ffff4734:	00000000 	udf	#0
ffff4738:	00000000 	udf	#0
ffff473c:	00000000 	udf	#0
ffff4740:	00000000 	udf	#0
ffff4744:	00000000 	udf	#0
ffff4748:	00000000 	udf	#0
ffff474c:	00000000 	udf	#0
ffff4750:	00000000 	udf	#0
ffff4754:	00000000 	udf	#0
ffff4758:	00000000 	udf	#0
ffff475c:	00000000 	udf	#0
ffff4760:	00000000 	udf	#0
ffff4764:	00000000 	udf	#0
ffff4768:	00000000 	udf	#0
ffff476c:	00000000 	udf	#0
ffff4770:	00000000 	udf	#0
ffff4774:	00000000 	udf	#0
ffff4778:	00000000 	udf	#0
ffff477c:	00000000 	udf	#0
ffff4780:	00000000 	udf	#0
ffff4784:	00000000 	udf	#0
ffff4788:	00000000 	udf	#0
ffff478c:	00000000 	udf	#0
ffff4790:	00000000 	udf	#0
ffff4794:	00000000 	udf	#0
ffff4798:	00000000 	udf	#0
ffff479c:	00000000 	udf	#0
ffff47a0:	00000000 	udf	#0
ffff47a4:	00000000 	udf	#0
ffff47a8:	00000000 	udf	#0
ffff47ac:	00000000 	udf	#0
ffff47b0:	00000000 	udf	#0
ffff47b4:	00000000 	udf	#0
ffff47b8:	00000000 	udf	#0
ffff47bc:	00000000 	udf	#0
ffff47c0:	00000000 	udf	#0
ffff47c4:	00000000 	udf	#0
ffff47c8:	00000000 	udf	#0
ffff47cc:	00000000 	udf	#0
ffff47d0:	00000000 	udf	#0
ffff47d4:	00000000 	udf	#0
ffff47d8:	00000000 	udf	#0
ffff47dc:	00000000 	udf	#0
ffff47e0:	00000000 	udf	#0
ffff47e4:	00000000 	udf	#0
ffff47e8:	00000000 	udf	#0
ffff47ec:	00000000 	udf	#0
ffff47f0:	00000000 	udf	#0
ffff47f4:	00000000 	udf	#0
ffff47f8:	00000000 	udf	#0
ffff47fc:	00000000 	udf	#0

; VBAR points to this
ffff4800:	14000000 	b	0xffff4800
ffff4804:	d503201f 	nop
ffff4808:	d503201f 	nop
ffff480c:	d503201f 	nop
ffff4810:	d503201f 	nop
ffff4814:	d503201f 	nop
ffff4818:	d503201f 	nop
ffff481c:	d503201f 	nop
ffff4820:	d503201f 	nop
ffff4824:	d503201f 	nop
ffff4828:	d503201f 	nop
ffff482c:	d503201f 	nop
ffff4830:	d503201f 	nop
ffff4834:	d503201f 	nop
ffff4838:	d503201f 	nop
ffff483c:	d503201f 	nop
ffff4840:	d503201f 	nop
ffff4844:	d503201f 	nop
ffff4848:	d503201f 	nop
ffff484c:	d503201f 	nop
ffff4850:	d503201f 	nop
ffff4854:	d503201f 	nop
ffff4858:	d503201f 	nop
ffff485c:	d503201f 	nop
ffff4860:	d503201f 	nop
ffff4864:	d503201f 	nop
ffff4868:	d503201f 	nop
ffff486c:	d503201f 	nop
ffff4870:	d503201f 	nop
ffff4874:	d503201f 	nop
ffff4878:	d503201f 	nop
ffff487c:	d503201f 	nop
ffff4880:	14000000 	b	0xffff4880
ffff4884:	d503201f 	nop
ffff4888:	d503201f 	nop
ffff488c:	d503201f 	nop
ffff4890:	d503201f 	nop
ffff4894:	d503201f 	nop
ffff4898:	d503201f 	nop
ffff489c:	d503201f 	nop
ffff48a0:	d503201f 	nop
ffff48a4:	d503201f 	nop
ffff48a8:	d503201f 	nop
ffff48ac:	d503201f 	nop
ffff48b0:	d503201f 	nop
ffff48b4:	d503201f 	nop
ffff48b8:	d503201f 	nop
ffff48bc:	d503201f 	nop
ffff48c0:	d503201f 	nop
ffff48c4:	d503201f 	nop
ffff48c8:	d503201f 	nop
ffff48cc:	d503201f 	nop
ffff48d0:	d503201f 	nop
ffff48d4:	d503201f 	nop
ffff48d8:	d503201f 	nop
ffff48dc:	d503201f 	nop
ffff48e0:	d503201f 	nop
ffff48e4:	d503201f 	nop
ffff48e8:	d503201f 	nop
ffff48ec:	d503201f 	nop
ffff48f0:	d503201f 	nop
ffff48f4:	d503201f 	nop
ffff48f8:	d503201f 	nop
ffff48fc:	d503201f 	nop
ffff4900:	14000000 	b	0xffff4900
ffff4904:	d503201f 	nop
ffff4908:	d503201f 	nop
ffff490c:	d503201f 	nop
ffff4910:	d503201f 	nop
ffff4914:	d503201f 	nop
ffff4918:	d503201f 	nop
ffff491c:	d503201f 	nop
ffff4920:	d503201f 	nop
ffff4924:	d503201f 	nop
ffff4928:	d503201f 	nop
ffff492c:	d503201f 	nop
ffff4930:	d503201f 	nop
ffff4934:	d503201f 	nop
ffff4938:	d503201f 	nop
ffff493c:	d503201f 	nop
ffff4940:	d503201f 	nop
ffff4944:	d503201f 	nop
ffff4948:	d503201f 	nop
ffff494c:	d503201f 	nop
ffff4950:	d503201f 	nop
ffff4954:	d503201f 	nop
ffff4958:	d503201f 	nop
ffff495c:	d503201f 	nop
ffff4960:	d503201f 	nop
ffff4964:	d503201f 	nop
ffff4968:	d503201f 	nop
ffff496c:	d503201f 	nop
ffff4970:	d503201f 	nop
ffff4974:	d503201f 	nop
ffff4978:	d503201f 	nop
ffff497c:	d503201f 	nop
ffff4980:	14000000 	b	0xffff4980
ffff4984:	d503201f 	nop
ffff4988:	d503201f 	nop
ffff498c:	d503201f 	nop
ffff4990:	d503201f 	nop
ffff4994:	d503201f 	nop
ffff4998:	d503201f 	nop
ffff499c:	d503201f 	nop
ffff49a0:	d503201f 	nop
ffff49a4:	d503201f 	nop
ffff49a8:	d503201f 	nop
ffff49ac:	d503201f 	nop
ffff49b0:	d503201f 	nop
ffff49b4:	d503201f 	nop
ffff49b8:	d503201f 	nop
ffff49bc:	d503201f 	nop
ffff49c0:	d503201f 	nop
ffff49c4:	d503201f 	nop
ffff49c8:	d503201f 	nop
ffff49cc:	d503201f 	nop
ffff49d0:	d503201f 	nop
ffff49d4:	d503201f 	nop
ffff49d8:	d503201f 	nop
ffff49dc:	d503201f 	nop
ffff49e0:	d503201f 	nop
ffff49e4:	d503201f 	nop
ffff49e8:	d503201f 	nop
ffff49ec:	d503201f 	nop
ffff49f0:	d503201f 	nop
ffff49f4:	d503201f 	nop
ffff49f8:	d503201f 	nop
ffff49fc:	d503201f 	nop

; Here is a curious routine, I don't see it referenced anywhere.
ffff4a00:	f81f0fe0 	str	x0, [sp, #-16]!	; save x0
ffff4a04:	d53e4020 	mrs	x0, elr_el3	; read elr_el3
ffff4a08:	91001000 	add	x0, x0, #0x4	; add 4 to it
ffff4a0c:	d51e4020 	msr	elr_el3, x0	; write elr_el3
ffff4a10:	f84107e0 	ldr	x0, [sp], #16	; restore x0
ffff4a14:	d69f03e0 	eret			; return from exception

ffff4a18:	d503201f 	nop
ffff4a1c:	d503201f 	nop
ffff4a20:	d503201f 	nop
ffff4a24:	d503201f 	nop
ffff4a28:	d503201f 	nop
ffff4a2c:	d503201f 	nop
ffff4a30:	d503201f 	nop
ffff4a34:	d503201f 	nop
ffff4a38:	d503201f 	nop
ffff4a3c:	d503201f 	nop
ffff4a40:	d503201f 	nop
ffff4a44:	d503201f 	nop
ffff4a48:	d503201f 	nop
ffff4a4c:	d503201f 	nop
ffff4a50:	d503201f 	nop
ffff4a54:	d503201f 	nop
ffff4a58:	d503201f 	nop
ffff4a5c:	d503201f 	nop
ffff4a60:	d503201f 	nop
ffff4a64:	d503201f 	nop
ffff4a68:	d503201f 	nop
ffff4a6c:	d503201f 	nop
ffff4a70:	d503201f 	nop
ffff4a74:	d503201f 	nop
ffff4a78:	d503201f 	nop
ffff4a7c:	d503201f 	nop
ffff4a80:	14000000 	b	0xffff4a80
ffff4a84:	d503201f 	nop
ffff4a88:	d503201f 	nop
ffff4a8c:	d503201f 	nop
ffff4a90:	d503201f 	nop
ffff4a94:	d503201f 	nop
ffff4a98:	d503201f 	nop
ffff4a9c:	d503201f 	nop
ffff4aa0:	d503201f 	nop
ffff4aa4:	d503201f 	nop
ffff4aa8:	d503201f 	nop
ffff4aac:	d503201f 	nop
ffff4ab0:	d503201f 	nop
ffff4ab4:	d503201f 	nop
ffff4ab8:	d503201f 	nop
ffff4abc:	d503201f 	nop
ffff4ac0:	d503201f 	nop
ffff4ac4:	d503201f 	nop
ffff4ac8:	d503201f 	nop
ffff4acc:	d503201f 	nop
ffff4ad0:	d503201f 	nop
ffff4ad4:	d503201f 	nop
ffff4ad8:	d503201f 	nop
ffff4adc:	d503201f 	nop
ffff4ae0:	d503201f 	nop
ffff4ae4:	d503201f 	nop
ffff4ae8:	d503201f 	nop
ffff4aec:	d503201f 	nop
ffff4af0:	d503201f 	nop
ffff4af4:	d503201f 	nop
ffff4af8:	d503201f 	nop
ffff4afc:	d503201f 	nop
ffff4b00:	14000000 	b	0xffff4b00
ffff4b04:	d503201f 	nop
ffff4b08:	d503201f 	nop
ffff4b0c:	d503201f 	nop
ffff4b10:	d503201f 	nop
ffff4b14:	d503201f 	nop
ffff4b18:	d503201f 	nop
ffff4b1c:	d503201f 	nop
ffff4b20:	d503201f 	nop
ffff4b24:	d503201f 	nop
ffff4b28:	d503201f 	nop
ffff4b2c:	d503201f 	nop
ffff4b30:	d503201f 	nop
ffff4b34:	d503201f 	nop
ffff4b38:	d503201f 	nop
ffff4b3c:	d503201f 	nop
ffff4b40:	d503201f 	nop
ffff4b44:	d503201f 	nop
ffff4b48:	d503201f 	nop
ffff4b4c:	d503201f 	nop
ffff4b50:	d503201f 	nop
ffff4b54:	d503201f 	nop
ffff4b58:	d503201f 	nop
ffff4b5c:	d503201f 	nop
ffff4b60:	d503201f 	nop
ffff4b64:	d503201f 	nop
ffff4b68:	d503201f 	nop
ffff4b6c:	d503201f 	nop
ffff4b70:	d503201f 	nop
ffff4b74:	d503201f 	nop
ffff4b78:	d503201f 	nop
ffff4b7c:	d503201f 	nop
ffff4b80:	14000000 	b	0xffff4b80

ffff4b84:	5253 414b	"RSAK"

; this looks like a block of 64 bit constants.

ffff4b88: 00000000 ffff0d40
ffff4b90: 00000000 ffff1184
ffff4b98: 00000000 ffff11ec
ffff4ba0: 00000003 0000000d
ffff4ba8: 00000000 ffff0e3c
ffff4bb0: 00000000 ffff1184
ffff4bb8: 00000000 ffff11ec
ffff4bc0: 00000004 0000000d
ffff4bc8: 00000000 ffff13e4
ffff4bd0: 00000000 ffff12d0
ffff4bd8: 00000000 ffff136c
ffff4be0: 00000002 00000005
ffff4be8: 00000000 ffff17a4
ffff4bf0: 00000000 ffff237c
ffff4bf8: 00000000 ffff2428
ffff4c00: 00000005 00000005
ffff4c08: 40000000 02000112
ffff4c10: 00000100 330c2207	; vendor/product = 2207, 330c
ffff4c18: 00200209 00000100
ffff4c20: 000409c8 80000101
ffff4c28: 05070005 06ff0200
ffff4c30: 02050700 02000281
ffff4c38: 00000000 00020002
ffff4c40: 00000000 ffff3a70
ffff4c48: 00000000 ffff3a70
ffff4c50: 00000000 ffff3ab0
ffff4c58: 00000000 ffff3a70
ffff4c60: 00000000 ffff3960

; Here is a 0x200 byte block
; it is a special template used by "uncrypt"
ffff4c68: 00000000 62987d7a
ffff4c70: 00000000 be3d3a96
ffff4c78: 00000000 1246c185
ffff4c80: 00000000 89ebc6ac
ffff4c88: 00000000 780fbd97
ffff4c90: 00000000 e2b5da8b
ffff4c98: 00000000 dc613427
ffff4ca0: 00000000 0ee6f5ed
ffff4ca8: 00000000 72eceed6
ffff4cb0: 00000000 4f041a31
ffff4cb8: 00000000 254e70db
ffff4cc0: 00000000 6fc37ece
ffff4cc8: 00000000 9059793c
ffff4cd0: 00000000 c9335374
ffff4cd8: 00000000 42115884
ffff4ce0: 00000000 755b5d0a
ffff4ce8: 00000000 40c8b067
ffff4cf0: 00000000 cd602d2f
ffff4cf8: 00000000 249c555e
ffff4d00: 00000000 e0aa717c
ffff4d08: 00000000 cc6b8613
ffff4d10: 00000000 b4fea3a8
ffff4d18: 00000000 17191076
ffff4d20: 00000000 1429bff3
ffff4d28: 00000000 5f2c2a0b
ffff4d30: 00000000 41fff748
ffff4d38: 00000000 d3056ad8
ffff4d40: 00000000 d477355c
ffff4d48: 00000000 e4267ff1
ffff4d50: 00000000 00f0471c
ffff4d58: 00000000 9a8eb822
ffff4d60: 00000000 a74d2bbc
ffff4d68: 00000000 3b203609
ffff4d70: 00000000 8f9dc266
ffff4d78: 00000000 e1f87bf9
ffff4d80: 00000000 e8e76980
ffff4d88: 00000000 3ebba592
ffff4d90: 00000000 9b308ad2
ffff4d98: 00000000 4916afd0
ffff4da0: 00000000 ca4aa2cb
ffff4da8: 00000000 9f64d51e
ffff4db0: 00000000 c7d1f4e9
ffff4db8: 00000000 c5b7886e
ffff4dc0: 00000000 56abb344
ffff4dc8: 00000000 4c6883fd
ffff4dd0: 00000000 9ea1b9ae
ffff4dd8: 00000000 43ea1f08
ffff4de0: 00000000 816dfa15
ffff4de8: 00000000 028c2ed9
ffff4df0: 00000000 52b632ef
ffff4df8: 00000000 215a0cdf
ffff4e00: 00000000 fb5028cf
ffff4e08: 00000000 45013f39
ffff4e10: 00000000 51b263d7
ffff4e18: 00000000 a49123de
ffff4e20: 00000000 65dde354
ffff4e28: 00000000 99731d07
ffff4e30: 00000000 ad1ba093
ffff4e38: 00000000 c4a9066c
ffff4e40: 00000000 e5948737
ffff4e48: 00000000 1895c003
ffff4e50: 00000000 f282b14b
ffff4e58: 00000000 5738ba8d
ffff4e60: 00000000 fca60df6
; END of "uncrypt" block

; This is a curious 8 bytes of text.

ffff4e68:	524b 3333 5253 414b           "RK33RSAK"

; A big block of 32 bit constants follow.
; These are typically used by adrp instructions in the code above.

ffff4e70: ff790004
ffff4e74: ff33c000
ffff4e78: ff33e00c
ffff4e7c: ff33c200
ffff4e80: ff8b000c
ffff4e84: ff8b0188
ffff4e88: ff8b0180
ffff4e8c: ff8b0008
ffff4e90: ff8b0008
ffff4e94: ff8b001c
ffff4e98: ff8b0020
ffff4e9c: ff8b0008
ffff4ea0: ff8b0184
ffff4ea4: ff8b018c
ffff4ea8: ff8b0008
ffff4eac: ff8b0184
ffff4eb0: ff8b018c
ffff4eb4: ff8b0400
ffff4eb8: ff8b0600
ffff4ebc: ff8b0700
ffff4ec0: ff8b0500
ffff4ec4: ff8b0008
ffff4ec8: ff8b0008
ffff4ecc: ff8b0400
ffff4ed0: ff760428
ffff4ed4: ff76042c
ffff4ed8: ff8b0280
ffff4edc: ff8b0008
ffff4ee0: ff8b0400
ffff4ee4: ff8b0600
ffff4ee8: ff8b0700
ffff4eec: ff8b0500
ffff4ef0: ff8b0008
ffff4ef4: ff8b0184
ffff4ef8: ff8b018c
ffff4efc: ff8b041c
ffff4f00: ff8b0418
ffff4f04: ff8b0414
ffff4f08: ff8b0410
ffff4f0c: ff8b040c
ffff4f10: ff8b0408
ffff4f14: ff8b0404
ffff4f18: ff8b0400
ffff4f1c: ff8b000c
ffff4f20: ff8b0188
ffff4f24: ff8b0180
ffff4f28: ff8b0008
ffff4f2c: ff8b001c
ffff4f30: ff8b0020
ffff4f34: 00df0043
ffff4f38: ff760160
ffff4f3c: ff33e018
ffff4f40: ff76000c
ffff4f44: ff76008c
ffff4f48: ff760100
ffff4f4c: ff760104
ffff4f50: 00df0040
ffff4f54: ff760110
ffff4f58: 9fdf8040
ffff4f5c: ff760114
ffff4f60: ff760130
ffff4f64: 739f0080
ffff4f68: ff760138
ffff4f6c: ff76015c
ffff4f70: 079f0080
ffff4f74: ff760164
ffff4f78: ff7601e4
ffff4f7c: ff76000c
ffff4f80: 0fff00c8
ffff4f84: 773f1403
ffff4f88: ff760004
ffff4f8c: ff76008c
ffff4f90: 0fff00c0
ffff4f94: ff760080
ffff4f98: 773f2302
ffff4f9c: ff760084
ffff4fa0: ff760514
ffff4fa4: 1fdf0101
ffff4fa8: ff760100
ffff4fac: 1fdf0100
ffff4fb0: 1f1f0303
ffff4fb4: ff760104
ffff4fb8: 00df0043
ffff4fbc: ff760110
ffff4fc0: 9fdf8341
ffff4fc4: ff760114
ffff4fc8: 739f0100
ffff4fcc: ff760130
ffff4fd0: 739f3181
ffff4fd4: ff760138
ffff4fd8: ff76015c
ffff4fdc: 079f0183
ffff4fe0: ff760164
ffff4fe4: 001f8300
ffff4fe8: ff7601e0
ffff4fec: 001f0005
ffff4ff0: ff7601e4
ffff4ff4: 03000100
ffff4ff8: ff008f00
ffff4ffc: ff7601ec
ffff5000: ff1d0010
ffff5004: c0008000
ffff5008: ff320010
ffff500c: 003f002a
ffff5010: ff320014
ffff5014: ff1d0008
ffff5018: ff1d000c
ffff501c: ff1d0400
ffff5020: ff1d0024
ffff5024: ff1d0800
ffff5028: 0010113a
ffff502c: 0010123a
ffff5030: 0010113a
ffff5034: 40ff8000
ffff5038: 80ff8000
ffff503c: c0ff8000
ffff5040: 03b70200
ffff5044: 40ff8000
ffff5048: c0ff8000
ffff504c: 80ff8000
ffff5050: 00012147
ffff5054: 80202000
ffff5058: 077f0500
ffff505c: ff760140
ffff5060: fe330200
ffff5064: fe320200
ffff5068: 000186a1
ffff506c: 0003d091
ffff5070: 9f008300
ffff5074: ff760134
ffff5078: 077f051f
ffff507c: ff760140
ffff5080: 00060004
ffff5084: ff760580
ffff5088: c0004000
ffff508c: 0fff0555
ffff5090: ff77e024
ffff5094: 80202000
ffff5098: 307f0080
ffff509c: fe330028
ffff50a0: fe33002c
ffff50a4: 077f0400
ffff50a8: ff760158
ffff50ac: fe330004
ffff50b0: fe330006
ffff50b4: fe33000c
ffff50b8: fe330008
ffff50bc: fe33000e
ffff50c0: fe330030
ffff50c4: 000f0001
ffff50c8: 0003d090
ffff50cc: fe330024
ffff50d0: fe330020
ffff50d4: 0007a120
ffff50d8: 00700002
ffff50dc: fffc2f6f
ffff50e0: fe330010
ffff50e4: fe330024
ffff50e8: fff85edf
ffff50ec: fe33002f
ffff50f0: 009f0083
ffff50f4: ff760154
ffff50f8: 077f043f
ffff50fc: ff760158
ffff5100: ff77f798
ffff5104: 0c000400
ffff5108: fe330029
ffff510c: fe33002c
ffff5110: fe33002e
ffff5114: 00ff0003
ffff5118: fe330034
ffff511c: 0001414c
ffff5120: fcdc8c3b
ffff5124: ff33e014
ffff5128: fe80c100
ffff512c: fe80c704
ffff5130: bfffc2f7
ffff5134: 00020009
ffff5138: fffa0004
ffff513c: fffa0008
ffff5140: 0010010c
ffff5144: 0010010e
ffff5148: fffa0004
ffff514c: fffa0004

; A huge block of zeros fills the bootrom from here,
; almost to the end
ffff5150:	00000000
ffff5154:	00000000
    .....
    .....
    .....
ffff7fe8:	00000000
ffff7fec:	00000000

; the bootrom ends with this curious ascii signature.
ffff7ff0:	4330 3333 3631 3032 3831 3130 3030 3156   "C03361028110001V"

; THE END
